////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//            Copyright (C) 2003-2007, Coolsand Technologies, Inc.            //
//                            All Rights Reserved                             //
//                                                                            //
//      This source code is the property of Coolsand Technologies and is      //
//      confidential.  Any  modification, distribution,  reproduction or      //
//      exploitation  of  any content of this file is totally forbidden,      //
//      except  with the  written permission  of  Coolsand Technologies.      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
/// @file target_config.c                                                     //
/// That file implements the TGT module: configuration structure storage      //
/// and accessor implementation for all firmware's module needing a specific  //
/// configuration.                                                            //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


/* *************************************************************
 * DO NOT EDIT THIS FILE 
 * *************************************************************
 * To setup the board configuration, edit the appropriate board_config.h 
 * in the appropriate target.
 * This file must be recompiled for the setup to be taken into account 
 */


#include "cs_types.h"

#include "chip_id.h"

#include "hal_config.h"

#include "rfd_config.h"
#include "pmd_config.h"
#include "memd_config.h"

#include "tgt_m.h"
#include "tgt_aud_cfg.h"
#include "tgt_hal_cfg.h"
#include "tgt_pmd_cfg.h"
#include "tgt_rfd_cfg.h"
#include "csw_config.h"
#if (CHIP_HAS_USB == 1)
#include "tgt_uctls_cfg.h"
#endif /* CHIP_HAS_USB */
#include "tgt_camd_cfg.h"
#include "tgt_cams_cfg.h"

/// MCD is optional so only link to MCD if needed
#ifdef TGT_WITH_MCD
#include "mcd_config.h"
#include "mcd_m.h"
#include "tgt_mcd_cfg.h"
#endif

/// FM is optional so only link to FM if needed
#ifdef TGT_WITH_FM
#include "fmd_config.h"
#include "tgt_fmd_cfg.h"
#endif

/// GSENSOR is optional so only link to GSENSOR if needed
#ifdef TGT_WITH_GSENSOR
#include "gsensor_config.h"
#include "tgt_gsensor_cfg.h"
#endif

/// GPIOI2C is optional so only link to GPIOI2C if needed
#ifdef TGT_WITH_GPIOI2C
#include "i2cgpio_config.h"
#include "tgt_gpioi2c_cfg.h"
#endif

/// TS is optional so only link to TS if needed
#ifdef TGT_WITH_TS
#include "tsd_config.h"
#include "tgt_tsd_cfg.h"
#endif

/// BT is optional so only link to BT if needed
#ifdef TGT_WITH_BT
#include "btd_config.h"
#include "tgt_btd_cfg.h"
#include "btd_map.h"
#endif

/// ATV is optional so only link to ATV if needed
#ifdef TGT_WITH_ATV
#include "atvd_config.h"
#include "tgt_atvd_cfg.h"
#endif
#ifdef __PRJ_WITH_SPILCD__
#include "lcdd_types.h"
#endif

#include "tgt_board_cfg.h"
#include "tgt_app_cfg.h"
#include "key_defs.h"
#include "hal_key.h"
#include "hal_gpio.h"
#include "hal_ebc.h"
#include "hal_sys.h"
#include "hal_timers.h"
#include "cmn_defs.h"
#include "hal_mem_map.h"

#include "memd_config.h"

#include "aud_m.h"
#if (CSW_EXTENDED_API == 0)
#include "aud_bt.h"
#endif /* CSW_EXTENDED_API */
#include "aud_codec_gallite.h"
#include "aud_fm.h"
#include "aud_maxim.h"
#include "aud_null.h"
#include "aud_ti.h"
#include "aud_tv.h"

#if (CSW_EXTENDED_API_AUDIO_VIDEO==1)
#include "avps_map.h"
/* #include "mps_map.h" */
#else
#include "aps_map.h"
#endif /* CSW_EXTENDED_API_AUDIO_VIDEO */

#include "ars_map.h"
#include "aud_map.h"
#include "calib_map.h"
#include "hal_map.h"
#include "lcdd_map.h"
#include "memd_map.h"
#include "pal_map.h"
#include "pmd_map.h"
#include "rfd_map.h"
#include "stack_map.h"
#include "std_map.h"
#include "sx_map.h"
#include "vois_map.h"
#include "vpp_map.h"
// #include "uctls_map.h"
#ifdef WITH_MDI
#include "mdi_map.h"
#endif
#ifdef TGT_WITH_EXPKEY
#include "tgt_expkey_cfg.h"
#endif

#include "bcpu_registermap.h"
#include "dsm_dev_driver.h"
#include "dsm_config.h"

#include "tgt_dsm_cfg.h"

#include "memd_m.h"

// ---------------------------------
//  Check configuration consistency 
//  --------------------------------
/// TODO Implement a configuration consistency test ?
#if 0 
#if ((USED_SPI & 0x1) && (USED_GPIO & 0x0f800000)) 
#error "Configuration Error : SPI and GPIO23-27 both enabled on the SPI pins"
#endif
#if (USED_GPIO & NO_CONNECT_PINS) 
#error "Configuration Error : Some pins are defined as GPIO and No COnnect at the same time"
#endif
#if ((KEY_AUX_IN_MASK|KEY_AUX_OUT_MASK) & 0x8) 
#error "Configuration Error : Keyaux3 is reserved for debug clock"
#endif
#endif

/// Start address of the factory settings sector, in the flash
// Defined by the environment to the symbol _factory_start
// declared in hal_mem_map.h
#define g_tgtFactorySettings (*((TGT_FACTORY_SETTINGS_T*)&_factory_start))

// HAL configuration structure
PROTECTED CONST HAL_CFG_CONFIG_T g_tgtHalCfg = TGT_HAL_CONFIG;

#define TGT_AUD_FUNC_NAME(s, func) aud_ ## s ## func

#define TGT_STREAM_START_DRIVER(driver)         TGT_AUD_FUNC_NAME(driver, StreamStart)
#define TGT_STREAM_RECORD_DRIVER(driver)        TGT_AUD_FUNC_NAME(driver,StreamRecord)
#define TGT_STREAM_STOP_DRIVER(driver)          TGT_AUD_FUNC_NAME(driver,StreamStop)
#define TGT_STREAM_PAUSE_DRIVER(driver)         TGT_AUD_FUNC_NAME(driver,StreamPause)
#define TGT_SETUP_DRIVER(driver)                TGT_AUD_FUNC_NAME(driver,Setup)
#define TGT_TONE_DRIVER(driver)                 TGT_AUD_FUNC_NAME(driver,Tone)
#define TGT_TONE_PAUSE_DRIVER(driver)           TGT_AUD_FUNC_NAME(driver,TonePause)
#define TGT_CALIB_UPDATE_VALUES_DRIVER(driver)  TGT_AUD_FUNC_NAME(driver,CalibUpdateValues)



// AUD configuration structure
PROTECTED CONST AUD_CONFIG_T g_tgtAudCfg = 
{
    {
        TGT_STREAM_START_DRIVER(TGT_AUD_CONFIG_RECEIVER_DRIVER),      
        TGT_STREAM_RECORD_DRIVER(TGT_AUD_CONFIG_RECEIVER_DRIVER),      
        TGT_STREAM_STOP_DRIVER(TGT_AUD_CONFIG_RECEIVER_DRIVER),
        TGT_STREAM_PAUSE_DRIVER(TGT_AUD_CONFIG_RECEIVER_DRIVER),
        TGT_SETUP_DRIVER(TGT_AUD_CONFIG_RECEIVER_DRIVER),      
        TGT_TONE_DRIVER(TGT_AUD_CONFIG_RECEIVER_DRIVER),             
        TGT_TONE_PAUSE_DRIVER(TGT_AUD_CONFIG_RECEIVER_DRIVER),
        TGT_CALIB_UPDATE_VALUES_DRIVER(TGT_AUD_CONFIG_RECEIVER_DRIVER),
        TGT_AUD_CONFIG_RECEIVER_PARAM,
        TGT_AUD_CONFIG_RECEIVER_OUTPUT_PATH,
        TGT_AUD_CONFIG_RECEIVER_OUTPUT_TYPE,
        TGT_AUD_CONFIG_RECEIVER_INPUT_PATH
    },
    {
        TGT_STREAM_START_DRIVER(TGT_AUD_CONFIG_EAR_PIECE_DRIVER),      
        TGT_STREAM_RECORD_DRIVER(TGT_AUD_CONFIG_EAR_PIECE_DRIVER),      
        TGT_STREAM_STOP_DRIVER(TGT_AUD_CONFIG_EAR_PIECE_DRIVER),
        TGT_STREAM_PAUSE_DRIVER(TGT_AUD_CONFIG_EAR_PIECE_DRIVER),
        TGT_SETUP_DRIVER(TGT_AUD_CONFIG_EAR_PIECE_DRIVER),      
        TGT_TONE_DRIVER(TGT_AUD_CONFIG_EAR_PIECE_DRIVER),             
        TGT_TONE_PAUSE_DRIVER(TGT_AUD_CONFIG_EAR_PIECE_DRIVER),
        TGT_CALIB_UPDATE_VALUES_DRIVER(TGT_AUD_CONFIG_EAR_PIECE_DRIVER),
        TGT_AUD_CONFIG_EAR_PIECE_PARAM,
        TGT_AUD_CONFIG_EAR_PIECE_OUTPUT_PATH,
        TGT_AUD_CONFIG_EAR_PIECE_OUTPUT_TYPE,
        TGT_AUD_CONFIG_EAR_PIECE_INPUT_PATH
    },
    {
        TGT_STREAM_START_DRIVER(TGT_AUD_CONFIG_LOUD_SPEAKER_DRIVER),      
        TGT_STREAM_RECORD_DRIVER(TGT_AUD_CONFIG_LOUD_SPEAKER_DRIVER),      
        TGT_STREAM_STOP_DRIVER(TGT_AUD_CONFIG_LOUD_SPEAKER_DRIVER),
        TGT_STREAM_PAUSE_DRIVER(TGT_AUD_CONFIG_LOUD_SPEAKER_DRIVER),
        TGT_SETUP_DRIVER(TGT_AUD_CONFIG_LOUD_SPEAKER_DRIVER),      
        TGT_TONE_DRIVER(TGT_AUD_CONFIG_LOUD_SPEAKER_DRIVER),             
        TGT_TONE_PAUSE_DRIVER(TGT_AUD_CONFIG_LOUD_SPEAKER_DRIVER),
        TGT_CALIB_UPDATE_VALUES_DRIVER(TGT_AUD_CONFIG_LOUD_SPEAKER_DRIVER),
        TGT_AUD_CONFIG_LOUD_SPEAKER_PARAM,
        TGT_AUD_CONFIG_LOUD_SPEAKER_OUTPUT_PATH,
        TGT_AUD_CONFIG_LOUD_SPEAKER_OUTPUT_TYPE,
        TGT_AUD_CONFIG_LOUD_SPEAKER_INPUT_PATH
    },
#ifdef TGT_WITH_BT
    {
        TGT_STREAM_START_DRIVER(TGT_AUD_CONFIG_BT_DRIVER),      
        TGT_STREAM_RECORD_DRIVER(TGT_AUD_CONFIG_BT_DRIVER),      
        TGT_STREAM_STOP_DRIVER(TGT_AUD_CONFIG_BT_DRIVER),
        TGT_STREAM_PAUSE_DRIVER(TGT_AUD_CONFIG_BT_DRIVER),
        TGT_SETUP_DRIVER(TGT_AUD_CONFIG_BT_DRIVER),      
        TGT_TONE_DRIVER(TGT_AUD_CONFIG_BT_DRIVER),             
        TGT_TONE_PAUSE_DRIVER(TGT_AUD_CONFIG_BT_DRIVER),
        TGT_CALIB_UPDATE_VALUES_DRIVER(TGT_AUD_CONFIG_BT_DRIVER),
        TGT_AUD_CONFIG_BT_PARAM,
        TGT_AUD_CONFIG_BT_OUTPUT_PATH,
        TGT_AUD_CONFIG_BT_OUTPUT_TYPE,
        TGT_AUD_CONFIG_BT_INPUT_PATH
    },
#else // TGT_WITH_BT
    {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    },
#endif // TGT_WITH_BT
#ifdef TGT_WITH_FM
    {
        TGT_STREAM_START_DRIVER(TGT_AUD_CONFIG_FM_DRIVER),      
        TGT_STREAM_RECORD_DRIVER(TGT_AUD_CONFIG_FM_DRIVER),      
        TGT_STREAM_STOP_DRIVER(TGT_AUD_CONFIG_FM_DRIVER),
        TGT_STREAM_PAUSE_DRIVER(TGT_AUD_CONFIG_FM_DRIVER),
        TGT_SETUP_DRIVER(TGT_AUD_CONFIG_FM_DRIVER),      
        TGT_TONE_DRIVER(TGT_AUD_CONFIG_FM_DRIVER),             
        TGT_TONE_PAUSE_DRIVER(TGT_AUD_CONFIG_FM_DRIVER),
        TGT_CALIB_UPDATE_VALUES_DRIVER(TGT_AUD_CONFIG_FM_DRIVER),
        TGT_AUD_CONFIG_FM_PARAM,
        TGT_AUD_CONFIG_FM_OUTPUT_PATH,
        TGT_AUD_CONFIG_FM_OUTPUT_TYPE,
        TGT_AUD_CONFIG_FM_INPUT_PATH
    },
#else // TGT_WITH_FM
    {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    },
#endif // TGT_WITH_FM
#ifdef TGT_WITH_ATV
    {
        TGT_STREAM_START_DRIVER(TGT_AUD_CONFIG_TV_DRIVER),      
        TGT_STREAM_RECORD_DRIVER(TGT_AUD_CONFIG_TV_DRIVER),      
        TGT_STREAM_STOP_DRIVER(TGT_AUD_CONFIG_TV_DRIVER),
        TGT_STREAM_PAUSE_DRIVER(TGT_AUD_CONFIG_TV_DRIVER),
        TGT_SETUP_DRIVER(TGT_AUD_CONFIG_TV_DRIVER),      
        TGT_TONE_DRIVER(TGT_AUD_CONFIG_TV_DRIVER),             
        TGT_TONE_PAUSE_DRIVER(TGT_AUD_CONFIG_TV_DRIVER),
        TGT_CALIB_UPDATE_VALUES_DRIVER(TGT_AUD_CONFIG_TV_DRIVER),
        TGT_AUD_CONFIG_TV_PARAM,
        TGT_AUD_CONFIG_TV_OUTPUT_PATH,
        TGT_AUD_CONFIG_TV_OUTPUT_TYPE,
        TGT_AUD_CONFIG_TV_INPUT_PATH
    }
#else // TGT_WITH_ATV
    {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    }
#endif // TGT_WITH_ATV
};

PROTECTED CONST PMD_CONFIG_T g_tgtPmdCfg = TGT_PMD_CONFIG;

#ifdef INTERNAL_XCV_CONTROL_PASW
#include "hal_tcu.h"
#undef TGT_XCV_CONFIG
#undef TGT_PA_CONFIG
#undef TGT_SW_CONFIG
#define TGT_XCV_CONFIG    {.RST = TCO_UNUSED, .PDN  = TCO(11)               }
#define TGT_PA_CONFIG     {.ENA = TCO_UNUSED, .TXEN = TCO_UNUSED, .BS  = TCO_UNUSED }
#define TGT_SW_CONFIG     {.SW1 = TCO_UNUSED, .SW2  = TCO_UNUSED, .SW3 = TCO_UNUSED }
#endif

PROTECTED CONST XCV_CONFIG_T g_tgtXcvCfg = TGT_XCV_CONFIG;
PROTECTED CONST PA_CONFIG_T  g_tgtPaCfg  = TGT_PA_CONFIG;
PROTECTED CONST SW_CONFIG_T  g_tgtSwCfg  = TGT_SW_CONFIG;


PROTECTED CONST CSW_CONFIG_T g_tgtCswCfg = TGT_CSW_CONFIG;

#if defined(FACT_SETTING_CACHE_SUPPORT) && !defined(_T_UPGRADE_PROGRAMMER)
PROTECTED TGT_FACTORY_SETTINGS_T g_tgtFactorySetting;
PROTECTED BOOL g_tgtFactotySettingIsDirty = FALSE;
#endif
// =============================================================================
// g_tgtDsmCfg
// -----------------------------------------------------------------------------
/// Dsm configuration.
// =============================================================================
PROTECTED CONST DSM_CONFIG_T g_tgtDsmCfg = TGT_DSM_CONFIG;


// =============================================================================
// tgt_GetDsmConfig
// -----------------------------------------------------------------------------
// This function is used by DSM to get access to its configuration structure.
// 
// =============================================================================
PUBLIC CONST DSM_CONFIG_T* tgt_GetDsmCfg(VOID)
{
    return &g_tgtDsmCfg;
}


// =============================================================================
// tgt_GetCswConfig
// -----------------------------------------------------------------------------
/// User heap configration
// =============================================================================
PUBLIC CONST CSW_CONFIG_T* tgt_GetCswConfig(VOID)
{
    return &g_tgtCswCfg;
}


#ifdef TGT_WITH_MCD
// =============================================================================
// g_tgtMcdCfg
// -----------------------------------------------------------------------------
/// MCD configuration.
// =============================================================================
#ifdef DUAL_TFLASH_SUPPORT
PROTECTED CONST MCD_CONFIG_STRUCT_T g_tgtMcdCfg = TGT_MCD_CONFIG;
#else
PROTECTED CONST TGT_MCD_CONFIG_T g_tgtMcdCfg = TGT_MCD_CONFIG;
#endif
#endif


#ifdef TGT_WITH_FM
// =============================================================================
// g_tgtFmdCfg
// -----------------------------------------------------------------------------
/// FM Driver configuration.
// =============================================================================
PROTECTED CONST TGT_FMD_CONFIG_T g_tgtFmdCfg = TGT_FMD_CONFIG;
#endif

#ifdef TGT_WITH_GSENSOR
// =============================================================================
// g_tgtGsensorCfg
// -----------------------------------------------------------------------------
/// gsensor Driver configuration.
// =============================================================================
PROTECTED  CONST TGT_GSENSOR_CONFIG_T g_tgtGsensorCfg = TGT_GSENSOR_CONFIG;
#endif

#ifdef TGT_WITH_GPIOI2C
// =============================================================================
// 
// -----------------------------------------------------------------------------
/// GpioI2c Driver configuration.
// =============================================================================
PROTECTED  CONST TGT_GPIOI2C_CONFIG_T g_tgtGpioi2cCfg = TGT_GPIOI2C_CONFIG;
#endif

#ifdef TGT_WITH_BT
// =============================================================================
// g_tgtBtdCfg
// -----------------------------------------------------------------------------
/// BT Driver configuration.
// =============================================================================
PROTECTED CONST TGT_BTD_CONFIG_T g_tgtBtdCfg = TGT_BTD_CONFIG;
#endif

#ifdef TGT_WITH_ATV
// =============================================================================
// g_tgtDAtvdCfg
// -----------------------------------------------------------------------------
/// ATV driver configuration.
// =============================================================================
PROTECTED CONST TGT_ATVD_CONFIG_T g_tgtAtvdCfg = TGT_ATVD_CONFIG;
#endif

#ifdef TGT_WITH_TS
// =============================================================================
// g_tgtTsdCfg
// -----------------------------------------------------------------------------
/// TSD configuration.
// =============================================================================
PROTECTED CONST TSD_CONFIG_T g_tgtTsdCfg = TGT_TSD_CONFIG;
#endif


#ifdef TGT_WITH_EXPKEY
// =============================================================================
// g_tgtExpKeyCfg
// -----------------------------------------------------------------------------
/// Expand Key configuration.
// =============================================================================
PROTECTED CONST TGT_CFG_EXPKEY_T g_tgtExpKeyCfg = TGT_EXPKEY_CONFIG;
#endif


// =============================================================================
// g_tgtMemdFlashCfg
// -----------------------------------------------------------------------------
/// MEMD Flash configuration configuration.
// =============================================================================
PROTECTED CONST MEMD_FLASH_CONFIG_T g_tgtMemdFlashCfg = TGT_MEMD_FLASH_CONFIG;



// =============================================================================
// g_tgtMemdRamCfg
// -----------------------------------------------------------------------------
/// MEMD Ram configuration configuration.
// =============================================================================
PROTECTED CONST MEMD_RAM_CONFIG_T g_tgtMemdRamCfg = TGT_MEMD_RAM_CONFIG;

#if (CHIP_HAS_USB == 1)
// =============================================================================
// g_tgtUctlsCfg
// -----------------------------------------------------------------------------
/// UCTLS configuration (USB Controller)
// =============================================================================
PROTECTED CONST UCTLS_CONFIG_T g_tgtUctlsCfg[] = TGT_UCTLS_CONFIG;
#endif /* CHIP_HAS_USB */

// =============================================================================
// g_tgtCamdCfg
// -----------------------------------------------------------------------------
/// Camera driver configuration.
// =============================================================================
PROTECTED CONST CAMD_CONFIG_T g_tgtCamdCfg = TGT_CAMD_CONFIG;

// =============================================================================
// g_tgtCamsCfg
// -----------------------------------------------------------------------------
/// Camera service configuration.
// =============================================================================
PROTECTED CONST CAMS_CONFIG_T g_tgtCamsCfg = TGT_CAMS_CONFIG;

#ifdef __PRJ_WITH_SPILCD__
// =============================================================================
// g_tgtSpiLcdCfg
// -----------------------------------------------------------------------------
/// spilcd service configuration.
// =============================================================================
PROTECTED CONST SPILCD_CONFIG_STRUCT_T g_tgtSpiLcdCfg = TGT_SPILCD_CONFIG;
#endif

// ------------------------
// Key configuration
// ------------------------
CONST UINT8 g_tgtKeyMap[] = KEY_MAP;

#ifndef CT_PRODUCT
#define CT_PRODUCT test_version
#endif
// =============================================================================
// tgt_GetBuildVerNo
// -----------------------------------------------------------------------------
/// This function is used to access the version number of this build.
// =============================================================================
CONST CHAR* tgt_GetBuildVerNo(VOID)
{
    const static char* verno = STRINGIFY_VALUE(CT_PRODUCT);
    return verno;
}

// =============================================================================
// tgt_GetBuildDateTime
// -----------------------------------------------------------------------------
/// This function is used to access the date time of this build.
// =============================================================================
CONST CHAR* tgt_GetBuildDateTime(VOID)
{
    const static char* datetime = STRINGIFY_VALUE(BUILD_TIME);
    return datetime;
}

// =============================================================================
// tgt_GetMobileId
// -----------------------------------------------------------------------------
/// This function is used to access the Mobile ID description.
// =============================================================================
CONST TGT_MOBILE_ID_T* tgt_GetMobileId(VOID)
{
    return &(g_tgtFactorySettings.mobileId);
}

// =============================================================================
// tgt_GetFactorySettings
// -----------------------------------------------------------------------------
/// This function is used to access the factory settings.
// =============================================================================
#if defined(FACT_SETTING_CACHE_SUPPORT) && !defined(_T_UPGRADE_PROGRAMMER)

TGT_FACTORY_SETTINGS_T* tgt_GetFactorySettings(VOID)
{
    if(g_tgtFactotySettingIsDirty)
    {
        return (TGT_FACTORY_SETTINGS_T*)&g_tgtFactorySetting;
    }
    else
    {
        return (TGT_FACTORY_SETTINGS_T*)&_factory_start; 
    }
}

#else
TGT_FACTORY_SETTINGS_T* tgt_GetFactorySettings(VOID)
{
    return (TGT_FACTORY_SETTINGS_T*)&_factory_start;
}
#endif

#ifdef TGT_AUTOGEN_MODULE_NAME
#define STRINGIFY_VALUE(s) STRINGIFY(s)
#define STRINGIFY(s) #s 
#define PROJECT_NAME_STRING "[Project]:" STRINGIFY_VALUE(CT_TARGET) "\n"
//#define BB_MODEL_STRING "[BB]:" STRINGIFY_VALUE(CT_ASIC) "\n"
#define BB_MODEL_STRING "[BB]: CT1128 \n"
#define LCD_MODEL_STRING "[LCD]:" STRINGIFY_VALUE(LCD_MODEL) "\n"
#define CAM_MODEL_STRING "[Cam]:" STRINGIFY_VALUE(CAMERA_MODEL) "\n"
#define FLASH_MODEL_STRING "[Flsh]:" STRINGIFY_VALUE(FLSH_MODEL) "\n"
#define PA_MODEL_STRING "[RF]:" STRINGIFY_VALUE(PA_MODEL) "\n"
#define BT_MODEL_STRING "[BT]:" STRINGIFY_VALUE(BT_MODEL) "\n"
#define ATV_MODEL_STRING "[ATV]:" STRINGIFY_VALUE(ATV_MODEL) "\n"
#define FM_MODEL_STRING "[FM]:" STRINGIFY_VALUE(FM_MODEL) "\n"

#define LCD_STRING  "[LCD]:"    
#define CAM_STRING  "[Cam]:"
#define CR_STRING   "\n"
#define NONE_STRING " \n"

extern UINT16 AnsiiToUnicodeString(INT8 *pOutBuffer, INT8 *pInBuffer );
//extern void *memset(void *dst0, int c0,unsigned int length); 
extern char* lcdd_GetStringId(VOID);
extern char* camera_GetStringId(VOID);
extern S8 *UCS2Strcat( S8 *strDestination, const S8 *strSource );
void tgt_GetHardwareModuleSettings(TGT_MODULE_T* hardwareModule)
{

    AnsiiToUnicodeString((S8 *)hardwareModule->BB,(S8 *) BB_MODEL_STRING);
    AnsiiToUnicodeString((S8 *)hardwareModule->RFPA,(S8 *) PA_MODEL_STRING);
    AnsiiToUnicodeString((S8 *)hardwareModule->FLSH,(S8 *) FLASH_MODEL_STRING);
    AnsiiToUnicodeString((S8 *)hardwareModule->BT,(S8 *) BT_MODEL_STRING);
    AnsiiToUnicodeString((S8 *)hardwareModule->ATV,(S8 *) ATV_MODEL_STRING);
    AnsiiToUnicodeString((S8 *)hardwareModule->FM,(S8 *) FM_MODEL_STRING);

    #if(LCDD_REGINIT_NUM==1)
        AnsiiToUnicodeString((S8 *)hardwareModule->LCD,(S8 *) LCD_MODEL_STRING);
    #else
    {   
        S8 string[40]="";
        S8 *lcd_id=lcdd_GetStringId();

        UCS2Strcat(string, (S8 *)LCD_STRING);
        UCS2Strcat(string, (S8 *)lcd_id);
        AnsiiToUnicodeString((S8 *)hardwareModule->LCD,string);
    }   
    #endif
    #if(CAM_REGINIT_QTY==1)
        AnsiiToUnicodeString((S8 *)hardwareModule->CAM,(S8 *) CAM_MODEL_STRING);
    #else
    {           
        S8 *cam_id=camera_GetStringId();
        if(cam_id==NULL)
        { 
           AnsiiToUnicodeString((S8 *)hardwareModule->CAM,(S8 *) NONE_STRING);
        }
        else 
        {           
           S8 stringc[40]="";
           UCS2Strcat((S8 *)stringc, (S8 *)CAM_STRING);
           UCS2Strcat((S8 *)stringc, (S8 *)cam_id);
           AnsiiToUnicodeString((S8 *)hardwareModule->CAM,(S8 *)stringc);
        }
    }  
    #endif
    return;
}

#endif

// =============================================================================
// tgt_SetFactorySettings
// -----------------------------------------------------------------------------
/// This function is used to update the new factory settings to flash.
// =============================================================================
#include "hal_host.h"


#if defined(FACT_SETTING_CACHE_SUPPORT) && !defined(_T_UPGRADE_PROGRAMMER)
extern void sxr_TakeSemaphore (u8 Id);
extern u8 sxr_NewSemaphore (u8 InitValue);
extern void sxr_ReleaseSemaphore (u8 Id);
extern VOID hal_FintIrqSetMask(BOOL mask);
extern VOID *memcpy(VOID *dest, CONST VOID *src, UINT32 n);

static HANDLE g_hTgtSem = NULL;
static VOID tgt_WaitForSem(VOID)
{    
    if((HANDLE)0 == g_hTgtSem)
    {
        g_hTgtSem = sxr_NewSemaphore(1);
    }
    
    if((HANDLE)0 != g_hTgtSem)
    {
        sxr_TakeSemaphore(g_hTgtSem);
    }   

}

static VOID tgt_ReleaseSem(VOID)
{
    
    if((HANDLE)0 != g_hTgtSem)
    {
        sxr_ReleaseSemaphore(g_hTgtSem);
    }    
}

BOOL tgt_SetFactorySettings(TGT_FACTORY_SETTINGS_T* factorySetting)
{
     memcpy(&g_tgtFactorySetting,factorySetting,sizeof(TGT_FACTORY_SETTINGS_T)); 
     g_tgtFactotySettingIsDirty = TRUE;
     return TRUE;   
}


BOOL tgt_FlushFactorySettings(VOID)
{
    UINT32 writtenBySize;
    UINT32 fs_addr = (UINT32)(&_factory_start);
    UINT32 cri_status = 0;
    
    if(!g_tgtFactotySettingIsDirty)   
    {
        return TRUE;
    }
    
    g_tgtFactotySettingIsDirty = FALSE;
    
    fs_addr -= (UINT32)FLASH_BASE;
    hal_FintIrqSetMask(FALSE); 
    hal_TimWatchDogClose();
    tgt_WaitForSem(); 
    cri_status = hal_SysEnterCriticalSection();  
    // Erase factory sector
    if (MEMD_ERR_NO != memd_FlashErase((UINT8*)fs_addr, NULL))
    {
        hal_HstSendEvent(0x1cdd000a);
        hal_SysExitCriticalSection(cri_status);                   
        tgt_ReleaseSem();
        return FALSE;
    }
    
    // Write factory sector
    if (MEMD_ERR_NO != memd_FlashWrite((UINT8*)fs_addr, sizeof(g_tgtFactorySettings),
        &writtenBySize, (UINT8*)&g_tgtFactorySetting))
    {
        hal_HstSendEvent(0x1cdd000b);
        hal_SysExitCriticalSection(cri_status);                   
        tgt_ReleaseSem();
        return FALSE;
    }   
    hal_SysExitCriticalSection(cri_status);                   
    tgt_ReleaseSem();
    return TRUE;
}

#else


BOOL tgt_SetFactorySettings(TGT_FACTORY_SETTINGS_T* factorySetting)
{
    UINT32 writtenBySize;
    UINT32 fs_addr = (UINT32)(&_factory_start);

    fs_addr -= (UINT32)FLASH_BASE;
// Erase factory sector
    if (MEMD_ERR_NO != memd_FlashErase((UINT8*)fs_addr, NULL))
    {
        hal_HstSendEvent(0x1cdd000a);
        return FALSE;
    }
// Write factory sector
    if (MEMD_ERR_NO != memd_FlashWrite((UINT8*)fs_addr, sizeof(g_tgtFactorySettings),
        &writtenBySize, (UINT8*)factorySetting))
    {
        hal_HstSendEvent(0x1cdd000b);
        return FALSE;
    }

//    hal_HstSendEvent(0x1cdd000c);
    return TRUE;
}
#endif
// =============================================================================
// tgt_GetHalConfig
// -----------------------------------------------------------------------------
/// This function is used by HAL to get access to its configuration structure.
/// This is the only way HAL can get this information.
// =============================================================================
PUBLIC CONST HAL_CFG_CONFIG_T* tgt_GetHalConfig(VOID)
{
    return &g_tgtHalCfg;
}

// =============================================================================
// tgt_GetAudConfig
// -----------------------------------------------------------------------------
/// This function is used by Aud to get access to its configuration structure.
/// This is the only way Aud can get this information.
// =============================================================================
PUBLIC CONST AUD_ITF_CFG_T* tgt_GetAudConfig(VOID)
{
    return g_tgtAudCfg;
}


// =============================================================================
// tgt_GetPmdConfig
// -----------------------------------------------------------------------------
/// This function is used by PMD to get access to its configuration structure.
/// This is the only way PMD can get this information.
// =============================================================================
PUBLIC CONST PMD_CONFIG_T* tgt_GetPmdConfig(VOID)
{
    return &g_tgtPmdCfg;
}



#ifdef TGT_WITH_MCD
// =============================================================================
// tgt_GetMcdConfig
// -----------------------------------------------------------------------------
/// This function is used by MCD to get access to its configuration structure.
/// This is the only way MCD can get this information.
// =============================================================================
#ifdef DUAL_TFLASH_SUPPORT
PUBLIC CONST MCD_CONFIG_STRUCT_T* tgt_GetMcdConfig(VOID)
#else
PUBLIC CONST TGT_MCD_CONFIG_T* tgt_GetMcdConfig(VOID)
#endif
{
    return &g_tgtMcdCfg;
}
#endif


#ifdef TGT_WITH_FM
// =============================================================================
// tgt_GetFmdConfig
// -----------------------------------------------------------------------------
/// This function is used by FMD to get access to its configuration structure.
/// This is the only way FMD can get this information.
// =============================================================================
PUBLIC CONST TGT_FMD_CONFIG_T* tgt_GetFmdConfig(VOID)
{
    return &g_tgtFmdCfg;
}
#endif


#ifdef TGT_WITH_GSENSOR
// =============================================================================
// tgt_GetGsensorConfig
// -----------------------------------------------------------------------------
/// This function is used by gsensor to get access to its configuration structure.
/// This is the only way gsensor can get this information.
// =============================================================================
PUBLIC CONST TGT_GSENSOR_CONFIG_T* tgt_GetGsensorConfig(VOID)
{
    return &g_tgtGsensorCfg;
}
#endif


#ifdef TGT_WITH_GPIOI2C
// =============================================================================
// tgt_GetGpioi2cConfig   
// -----------------------------------------------------------------------------
/// This function is used by GpioI2c to get access to its configuration structure.
/// This is the only way GpioI2c can get this information.
// =============================================================================
PUBLIC CONST TGT_GPIOI2C_CONFIG_T* tgt_GetGpioi2cConfig(VOID)
{
    return &g_tgtGpioi2cCfg;
}
#endif


#ifdef TGT_WITH_BT
// =============================================================================
// tgt_GetBtdConfig
// -----------------------------------------------------------------------------
/// This function is used by BTD to get access to its configuration structure.
/// This is the only way BTD can get this information.
// =============================================================================
PUBLIC CONST TGT_BTD_CONFIG_T* tgt_GetBtdConfig(VOID)
{
    return &g_tgtBtdCfg;
}
#endif


#ifdef TGT_WITH_TS
// =============================================================================
// tgt_GetTsdConfig
// -----------------------------------------------------------------------------
/// This function is used by TSD to get access to its configuration structure.
/// This is the only way TSD can get this information.
// =============================================================================
PUBLIC CONST TSD_CONFIG_T* tgt_GetTsdConfig(VOID)
{
    return &g_tgtTsdCfg;
}
#endif

#ifdef TGT_WITH_ATV
// =============================================================================
// tgt_GetAtvDConfig
// -----------------------------------------------------------------------------
/// This function is used by ATVD to get access to its configuration structure.
/// This is the only way ATVD can get this information.
// =============================================================================
PUBLIC CONST TGT_ATVD_CONFIG_T* tgt_GetAtvdConfig(VOID)
{
    return &g_tgtAtvdCfg;
}
#endif

#ifdef TGT_WITH_EXPKEY
// =============================================================================
// tgt_GetExpKeyConfig
// -----------------------------------------------------------------------------
/// This function is used by expand key to get its configuration.
// =============================================================================
PUBLIC CONST TGT_CFG_EXPKEY_T* tgt_GetExpKeyConfig(VOID)
{
    return &g_tgtExpKeyCfg;
}
#endif


// =============================================================================
// tgt_GetMemdFlashConfig
// -----------------------------------------------------------------------------
/// This function is used to get access to the Flash configuration structure.
// =============================================================================
PUBLIC CONST MEMD_FLASH_CONFIG_T* tgt_GetMemdFlashConfig(VOID)
{
    return &g_tgtMemdFlashCfg;
}



// =============================================================================
// tgt_GetMemdRamConfig
// -----------------------------------------------------------------------------
/// This function is used to get access to the Ram configuration structure.
// =============================================================================
PUBLIC CONST MEMD_RAM_CONFIG_T* tgt_GetMemdRamConfig(VOID)
{
    return &g_tgtMemdRamCfg;
}

#if (CHIP_HAS_USB == 1)
///=============================================================================
// tgt_GetUctlsConfig
// -----------------------------------------------------------------------------
/// This function is used by UCTL to get access to its configuration structure.
/// This is the only way UCTLS can get this information.
// =============================================================================
PUBLIC CONST UCTLS_CONFIG_T* tgt_GetUctlsConfig(VOID)
{
    return g_tgtUctlsCfg;
}
#endif // CHIP_HAS_USB


///=============================================================================
// tgt_GetCamdConfig
// -----------------------------------------------------------------------------
/// This function is used by CAMD to get access to its configuration structure.
/// This is the only way CAMD can get this information.
// =============================================================================
PUBLIC CONST CAMD_CONFIG_T* tgt_GetCamdConfig(VOID)
{
    return &g_tgtCamdCfg;
}

///=============================================================================
// tgt_GetCamsConfig
// -----------------------------------------------------------------------------
/// This function is used by CAMS to get access to its configuration structure.
/// This is the only way CAMS can get this information.
// =============================================================================
PUBLIC CONST CAMS_CONFIG_T* tgt_GetCamsConfig(VOID)
{
    return &g_tgtCamsCfg;
}

#ifdef __PRJ_WITH_SPILCD__
// =============================================================================
// tgt_GetSpiLcdConfig
// -----------------------------------------------------------------------------
/// This function is used by SPILCD to get access to its configuration structure.
/// This is the only way SPILCD can get this information.
// =============================================================================
PUBLIC CONST SPILCD_CONFIG_STRUCT_T* tgt_GetSpiLcdConfig(VOID)
{
    return &g_tgtSpiLcdCfg;
}
#endif
// =============================================================================
// tgt_GetKeyCode
// -----------------------------------------------------------------------------
/// This function returns the code of a key from its column number. It 
/// implements thus the key mapping, between the key detected and the 
/// keyboard of a given target.
/// @param key Key number as given by the HAL Key driver
/// @return The key code as mapped for a specifc target.
// =============================================================================
PUBLIC UINT8 tgt_GetKeyCode(UINT8 key)
{
    if (key == HAL_KEY_ON_OFF)
    {
        return KP_PWR;
    }
    else if (key >= TGT_KEY_NB)
    {
        return TGT_KEY_NB;
    }
    else
    {
        return g_tgtKeyMap[key];
    }
}
PUBLIC UINT8 tgt_IsHaveKeyCode(unsigned char KeyCode)
{
	int i=0;
	for (i=0;i<TGT_KEY_NB;i++)
	{
		if ( g_tgtKeyMap[i] == KeyCode)
		{
			return 1;
		}
	}
	return 0;
}


PUBLIC CONST XCV_CONFIG_T* tgt_GetXcvConfig(VOID)
{
    return &g_tgtXcvCfg;
}

PUBLIC CONST PA_CONFIG_T* tgt_GetPaConfig(VOID)
{
    return &g_tgtPaCfg;
}

PUBLIC CONST SW_CONFIG_T* tgt_GetSwConfig(VOID)
{
    return &g_tgtSwCfg;
}


// =============================================================================
// tgt_RegisterAllModules
// -----------------------------------------------------------------------------
/// This function call the register functions for each modules of platform.
// =============================================================================
PUBLIC VOID tgt_RegisterAllModules(VOID)
{
    // Required modules.
    hal_RegisterYourself();
    calib_RegisterYourself();
    sx_RegisterYourself();
    std_RegisterYourself();
    rfd_RegisterYourself();
    memd_RegisterYourself();
    pmd_RegisterYourself();
#if (CHIP_HAS_USB == 1)
//    uctls_RegisterYourself();
#endif /* (CHIP_HAS_USB == 1) */

#ifdef TGT_REGISTER_PLATFORM_VERSIONS
    // Top level modules.
    pal_RegisterYourself();
    stack_RegisterYourself();
    vpp_RegisterYourself();

    // All BCPU modules are registered by this:
    bcpu_RegisterYourself();

    // External drivers.
    aud_RegisterYourself();
    lcdd_RegisterYourself();
    
    // Services.
#if (CSW_EXTENDED_API_AUDIO_VIDEO==1)
    avps_RegisterYourself();
/*     mps_RegisterYourself(); */
#else
    aps_RegisterYourself();
#endif /* CSW_EXTENDED_API_AUDIO_VIDEO */
#if (CSW_EXTENDED_API_MRS == 1)
// TODO Implement this AVRS registration function
//  avrs_RegisterYourself();
#else
    ars_RegisterYourself();
#endif
    vois_RegisterYourself();
    // ffs_RegisterYourself();
    // mps_RegisterYourself();
    // cams_RegisterYourself();
#ifdef WITH_MDI
    mdi_RegisterYourself();
#endif
#ifdef TGT_WITH_BT
    btd_RegisterYourself();
#endif
#endif // TGT_REGISTER_PLATFORM_VERSIONS
}
