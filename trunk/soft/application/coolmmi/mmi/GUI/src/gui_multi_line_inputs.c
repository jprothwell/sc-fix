/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 *   gui_multi_line_inputs.c
 *
 * Project:
 * --------
 
 *
 * Description:
 * ------------
 *   Editor layout
 *
 * Author:
 * -------
 * -------
 *============================================================================
 *             HISTORY
 
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 *------------------------------------------------------------------------------
 
 *============================================================================
 ****************************************************************************/
#include "gui_inputs.h"
#include "gui_themes.h"
#include "mmi_features.h"
#include "gui_theme_struct.h"
#include "gdi_include.h"
#include "lcd_sw_rnd.h"
#include "gui_ems.h"
#if defined(__UI_PAGING_IN_MULTILINE_EDITOR__)
#include "gui_setting.h"
#endif 

#ifdef __MMI_INDIC_ALG__
#include "indicenginegprot.h"
#define MAX_EDITOR_DISP_LEN      60
#endif /* __MMI_INDIC_ALG__ */ 

#ifdef __MMI_LANG_VIETNAMESE__
#include "gui_lang_viet.h"
#endif 

#include "wgui_categories.h"    
#include "wgui_categories_defs.h"
#include "wgui_categories_inputs.h"

 
#include "bididef.h"
#include "bidiprot.h"

#include "gui_inputs_internal.h"

#if defined (__MMI_ARSHAPING_ENGINE__)
#include "arabicgprot.h"
#endif 
#include "debuginitdef.h"
/* Static variable */
static const color_t g_mmi_gui_input_format_w3c_text_background_color_table[] = 
{
    {169, 169, 169, 100},
    {139, 0, 0, 100},
    {255, 255, 0, 100},
    {0, 100, 0, 100},
    {0, 139, 139, 100},
    {0, 0, 139, 100},
    {139, 0, 139, 100},
    {128, 128, 128, 100},
    {255, 255, 255, 100},
    {255, 0, 0, 100},
    {255, 255, 224, 100},
    {144, 238, 144, 100},
    {224, 255, 255, 100},
    {173, 216, 230, 100},
    {255, 0, 255, 100},
    {0, 0, 0, 100}
};

/* 147 colors */
static const color_t g_mmi_gui_input_format_w3c_color_table[] = 
{
    {240, 248, 255, 100},
    {250, 235, 215, 100},
    {0, 255, 255, 100},
    {127, 255, 212, 100},
    {240, 255, 255, 100},
    {245, 245, 220, 100},
    {255, 228, 196, 100},
    {0, 0, 0, 100},
    {255, 235, 205, 100},
    {0, 0, 235, 100},   /* Avoid transparent color_t */
    {138, 43, 226, 100},
    {165, 42, 42, 100},
    {222, 184, 135, 100},
    {95, 158, 160, 100},
    {127, 255, 0, 100},
    {210, 105, 30, 100},
    {255, 127, 80, 100},
    {100, 149, 237, 100},
    {255, 248, 220, 100},
    {220, 20, 60, 100},
    {0, 255, 255, 100},
    {0, 0, 139, 100},
    {0, 139, 139, 100},
    {184, 134, 11, 100},
    {169, 169, 169, 100},
    {0, 100, 0, 100},
    {169, 169, 169, 100},
    {189, 183, 107, 100},
    {139, 0, 139, 100},
    {85, 107, 47, 100},
    {255, 140, 0, 100},
    {153, 50, 204, 100},
    {139, 0, 0, 100},
    {233, 150, 122, 100},
    {143, 188, 143, 100},
    {72, 61, 139, 100},
    {47, 79, 79, 100},
    {47, 79, 79, 100},
    {0, 206, 209, 100},
    {148, 0, 211, 100},
    {255, 20, 147, 100},
    {0, 191, 255, 100},
    {105, 105, 105, 100},
    {105, 105, 105, 100},
    {30, 144, 255, 100},
    {178, 34, 34, 100},
    {255, 250, 240, 100},
    {34, 139, 34, 100},
    {255, 0, 255, 100},
    {220, 220, 220, 100},
    {248, 248, 255, 100},
    {255, 215, 0, 100},
    {218, 165, 32, 100},
    {128, 128, 128, 100},
    {128, 128, 128, 100},
    {0, 128, 0, 100},
    {173, 255, 47, 100},
    {240, 255, 240, 100},
    {255, 105, 180, 100},
    {205, 92, 92, 100},
    {75, 0, 130, 100},
    {255, 255, 240, 100},
    {240, 230, 140, 100},
    {230, 230, 250, 100},
    {255, 240, 245, 100},
    {124, 252, 0, 100},
    {255, 250, 205, 100},
    {173, 216, 230, 100},
    {240, 128, 128, 100},
    {224, 255, 255, 100},
    {250, 250, 210, 100},
    {211, 211, 211, 100},
    {144, 238, 144, 100},
    {211, 211, 211, 100},
    {255, 182, 193, 100},
    {255, 160, 122, 100},
    {32, 178, 170, 100},
    {135, 206, 250, 100},
    {119, 136, 153, 100},
    {119, 136, 153, 100},
    {176, 196, 222, 100},
    {255, 255, 224, 100},
    {0, 255, 0, 100},
    {50, 205, 50, 100},
    {250, 240, 230, 100},
    {255, 0, 255, 100},
    {128, 0, 0, 100},
    {102, 205, 170, 100},
    {0, 0, 205, 100},
    {186, 85, 211, 100},
    {147, 112, 219, 100},
    {60, 179, 113, 100},
    {123, 104, 238, 100},
    {0, 250, 154, 100},
    {72, 209, 204, 100},
    {199, 21, 133, 100},
    {25, 25, 112, 100},
    {245, 255, 250, 100},
    {255, 228, 225, 100},
    {255, 228, 181, 100},
    {255, 222, 173, 100},
    {0, 0, 128, 100},
    {253, 245, 230, 100},
    {128, 128, 0, 100},
    {107, 142, 35, 100},
    {255, 165, 0, 100},
    {255, 69, 0, 100},
    {218, 112, 214, 100},
    {238, 232, 170, 100},
    {152, 251, 152, 100},
    {175, 238, 238, 100},
    {219, 112, 147, 100},
    {255, 239, 213, 100},
    {255, 218, 185, 100},
    {205, 133, 63, 100},
    {255, 192, 203, 100},
    {221, 160, 221, 100},
    {176, 224, 230, 100},
    {128, 0, 128, 100},
    {255, 0, 0, 100},
    {188, 143, 143, 100},
    {65, 105, 225, 100},
    {139, 69, 19, 100},
    {250, 128, 114, 100},
    {244, 164, 96, 100},
    {46, 139, 87, 100},
    {255, 245, 238, 100},
    {160, 82, 45, 100},
    {192, 192, 192, 100},
    {135, 206, 235, 100},
    {106, 90, 205, 100},
    {112, 128, 144, 100},
    {112, 128, 144, 100},
    {255, 250, 250, 100},
    {0, 255, 127, 100},
    {70, 130, 180, 100},
    {210, 180, 140, 100},
    {0, 128, 128, 100},
    {216, 191, 216, 100},
    {255, 99, 71, 100},
    {64, 224, 208, 100},
    {238, 130, 238, 100},
    {245, 222, 179, 100},
    {255, 255, 255, 100},
    {245, 245, 245, 100},
    {255, 255, 0, 100},
    {154, 205, 50, 100}
};

static const color_t g_mmi_gui_input_format_color_table[] = 
{
    {255, 0, 0, 100},
    {255, 255, 0, 100},
    {0, 255, 0, 100},
    {0, 255, 255, 100},
    {0, 0, 235, 100},   /* Avoid transparent color_t */
    {255, 0, 255, 100},
    {255, 255, 255, 100},
    {230, 230, 230, 100},
    {218, 218, 218, 100},
    {205, 205, 205, 100},
    {192, 192, 192, 100},
    {180, 180, 180, 100},
    {168, 168, 168, 100},
    {154, 154, 154, 100},
    {141, 141, 141, 100},
    {129, 129, 129, 100},
    {230, 0, 6, 100},
    {255, 237, 0, 100},
    {0, 152, 55, 100},
    {0, 166, 234, 100},
    {45, 29, 134, 100},
    {228, 0, 132, 100},
    {116, 116, 116, 100},
    {102, 102, 102, 100},
    {89, 89, 89, 100},
    {75, 75, 75, 100},
    {62, 62, 62, 100},
    {48, 48, 48, 100},
    {33, 33, 33, 100},
    {19, 19, 19, 100},
    {10, 10, 10, 100},
    {0, 0, 0, 100},
    {240, 148, 115, 100},
    {244, 173, 124, 100},
    {249, 200, 134, 100},
    {255, 245, 148, 100},
    {209, 224, 149, 100},
    {173, 210, 149, 100},
    {141, 199, 149, 100},
    {136, 203, 199, 100},
    {129, 207, 244, 100},
    {136, 169, 217, 100},
    {141, 147, 199, 100},
    {144, 127, 186, 100},
    {169, 134, 188, 100},
    {195, 141, 187, 100},
    {238, 155, 193, 100},
    {238, 151, 156, 100},
    {233, 98, 63, 100},
    {240, 136, 70, 100},
    {245, 175, 77, 100},
    {255, 240, 87, 100},
    {138, 208, 96, 100},
    {136, 192, 102, 100},
    {79, 176, 104, 100},
    {66, 138, 177, 100},
    {12, 188, 239, 100},
    {85, 138, 199, 100},
    {98, 109, 179, 100},
    {104, 81, 159, 100},
    {139, 85, 160, 100},
    {172, 91, 161, 100},
    {233, 102, 163, 100},
    {233, 101, 117, 100},
    {230, 0, 6, 100},
    {234, 89, 0, 100},
    {242, 143, 0, 100},
    {255, 237, 0, 100},
    {153, 192, 0, 100},
    {79, 172, 37, 100},
    {0, 152, 55, 100},
    {0, 158, 150, 100},
    {0, 166, 234, 100},
    {0, 104, 180, 100},
    {1, 70, 154, 100},
    {45, 29, 134, 100},
    {107, 18, 133, 100},
    {149, 0, 133, 100},
    {228, 0, 132, 100},
    {229, 0, 79, 100},
    {159, 0, 3, 100},
    {161, 60, 0, 100},
    {167, 98, 0, 100},
    {179, 162, 0, 100},
    {102, 132, 0, 100},
    {45, 118, 21, 100},
    {0, 105, 35, 100},
    {0, 109, 103, 100},
    {0, 113, 164, 100},
    {0, 69, 128, 100},
    {0, 43, 109, 100},
    {32, 4, 95, 100},
    {74, 0, 94, 100},
    {103, 0, 92, 100},
    {159, 0, 90, 100},
    {160, 0, 52, 100},
    {117, 0, 0, 100},
    {120, 43, 0, 100},
    {124, 70, 0, 100},
    {131, 118, 0, 100},
    {69, 96, 0, 100},
    {22, 86, 10, 100},
    {0, 76, 23, 100},
    {0, 79, 74, 100},
    {0, 82, 121, 100},
    {0, 47, 93, 100},
    {0, 23, 77, 100},
    {22, 0, 68, 100},
    {56, 0, 67, 100},
    {78, 0, 65, 100},
    {119, 0, 64, 100},
    {118, 0, 33, 100},
    {203, 187, 164, 100},
    {165, 141, 121, 100},
    {125, 99, 85, 100},
    {90, 65, 58, 100},
    {63, 41, 35, 100},
    {199, 163, 111, 100},
    {176, 130, 78, 100},
    {150, 98, 46, 100},
    {124, 74, 25, 100},
    {101, 51, 7, 100}
};

#if 0//defined( __MMI_LANG_ARABIC__)||defined(__MMI_LANG_PERSIAN__)
#define IS_ARABIC_CHARACTER(c)                                                                                          \
    (( ( ((UI_character_type)(c)>=(UI_character_type)0x0391) && ((UI_character_type)(c)<=(UI_character_type)0x03A1) ) || \
    ( ((UI_character_type)(c)>=(UI_character_type)0x3A3) && ((UI_character_type)(c)<=(UI_character_type)0x03A9) ) ||    \
   ( ( ((UI_character_type)(c)>=(UI_character_type)0x0621) && ((UI_character_type)(c)<=(UI_character_type)0x0653) ) || \
   ( ((UI_character_type)(c)>=(UI_character_type)0xFB50) && ((UI_character_type)(c)<=(UI_character_type)0xFDFF) ) ||    \
    ((UI_character_type)(c) == 0x60c ))|| \
   ( ((UI_character_type)(c)>=(UI_character_type)0xFE70) && ((UI_character_type)(c)<=(UI_character_type)0xFEFF) ) )?(1):(0))
#endif
#define MAX_GUI_INPUT_COLOR         (sizeof(g_mmi_gui_input_format_color_table)/sizeof(color_t))
#define MAX_GUI_INPUT_W3C_COLOR     (sizeof(g_mmi_gui_input_format_w3c_color_table)/sizeof(color_t))
#define MAX_GUI_INPUT_W3C_TEXT_BG_COLOR      (sizeof(g_mmi_gui_input_format_w3c_text_background_color_table)/sizeof(color_t))

/* Static function declaration */
static void gui_measure_multi_line_character(
                multi_line_input_box_show_struct *bs,
                UI_character_type current_character,
                U16 cluster_count,
                S32 *width_p,
                S32 *height_p);

static U8 gui_get_multi_line_current_cluster(
            multi_line_input_box *b,
            multi_line_input_box_show_struct *bs,
            UI_character_type *current_character_p,
            U16 *cluster_count_p);

#ifdef __MMI_MESSAGES_CHAT__
static void gui_draw_multi_line_chat_icon(multi_line_input_box_show_struct *bs, UI_character_type current_character);
#endif 

#ifdef __MMI_INDIC_ALG__
static void gui_draw_multi_line_indic_cluster(multi_line_input_box *b, multi_line_input_box_show_struct *bs);
#endif 

#ifdef __MMI_BIDI_ALG__
static void gui_apply_multi_line_marker_for_bidi_text(multi_line_input_box *b, multi_line_input_box_show_struct *bs);
#endif /* __MMI_BIDI_ALG__ */ 

static void gui_apply_multi_line_marker(
                multi_line_input_box *b,
                multi_line_input_box_show_struct *bs,
                UI_character_type current_character,
                U32 which_pass);

static UI_buffer_type gui_get_multi_line_current_char_offset(
                        multi_line_input_box_show_struct *bs,
                        UI_buffer_type current_text_p);
static UI_buffer_type gui_get_multi_line_original_text(U16 index);
static void gui_draw_multi_line_current_line_highlight(multi_line_input_box *b, multi_line_input_box_show_struct *bs);
static void gui_set_multi_line_character_coordinate(multi_line_input_box *b, multi_line_input_box_show_struct *bs);
static U8 gui_truncate_multi_line_content(multi_line_input_box *b, multi_line_input_box_show_struct *bs);
static void gui_handle_multi_line_cursor(multi_line_input_box *b, multi_line_input_box_show_struct *bs);
static void gui_draw_multi_line_single_character(
                multi_line_input_box *b,
                multi_line_input_box_show_struct *bs,
                UI_character_type current_character);
static void gui_draw_multi_line_common_cluster(multi_line_input_box *b, multi_line_input_box_show_struct *bs);
static U32 gui_check_multi_line_character_highlight(multi_line_input_box *b, multi_line_input_box_show_struct *bs, U16 count);
static S32 gui_check_multi_line_cursor_validation_for_wcss(multi_line_input_box *b, multi_line_input_box_show_struct *bs, UI_buffer_type cursor_p);
#ifdef __UI_ENHANCED_HILITE_IN_MULTILINE_EDITOR__
static void gui_set_multi_line_hilite_format(multi_line_input_box *b, multi_line_input_box_show_struct *bs, U16 hilite_idx);
#endif
/*****************************************************************************
 * FUNCTION
 *  gui_init_multi_line_show_struct
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_init_multi_line_show_struct(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* maybe this init-zero can be  */
    memset(bs, 0, sizeof(multi_line_input_box_show_struct));

    bs->current_cursor_p = b->cursor_p;
    bs->previous_cursor_p = b->cursor_p;
    bs->selector_color = b->selector_color;
    bs->selected_text_color = b->selected_text_color;
    bs->flags = b->flags;
    bs->default_direction = BIDI_L;
    bs->cursor_line_found_flag = 0;
    bs->previous_line_height = 0;

#if defined(__UI_PAGING_IN_MULTILINE_EDITOR__)
    if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_VIEW_PAGING_MODE)
    {
        if (b->page_offset > 0 || b->jump_offset_from_app > 0)
            bs->adjust_view = 1;
    }
#endif

    if (b->hilite_cb)
        bs->reserve_line_height_for_hilite = 1;
    else
        bs->reserve_line_height_for_hilite = 0;

    /* init richtext structure */
    bs->rich_text.default_color = bs->rich_text.curr_color = b->normal_text_color;
    /* USAT */
    bs->rich_text.default_text_bg_color = bs->rich_text.curr_text_bg_color = gui_richtext_default_text_bg_color;
    bs->rich_text.draw_text_bg_color = 0;
    if (bs->flags & UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY)
    {
        bs->rich_text.default_alignment = GUI_INPUT_ALIGN_CENTER;
    }
    else if (bs->flags & UI_MULTI_LINE_INPUT_BOX_RIGHT_JUSTIFY)
    {
        bs->rich_text.default_alignment = GUI_INPUT_ALIGN_RIGHT;
    }
    else
    {
        bs->rich_text.default_alignment = GUI_INPUT_ALIGN_LEFT;
    }
    bs->rich_text.curr_alignment = bs->rich_text.default_alignment;
    bs->rich_text.line_end_font = bs->rich_text.line_begin_font = bs->rich_text.curr_font = *b->text_font;
    bs->rich_text.line_end_border = bs->rich_text.line_begin_border = bs->rich_text.curr_border = 0;
    bs->rich_text.line_end_color = bs->rich_text.line_begin_color = bs->rich_text.curr_color;
    bs->rich_text.line_end_strikethrough = bs->rich_text.line_begin_strikethrough 
         = bs->rich_text.curr_strikethrough = 0;
    bs->rich_text.more_line_spacing = 0;
    bs->rich_text.line_separator = 0;

    bs->end_line = 0;

    if(bs->selected_text_color.r == bs->selector_color.r 
    && bs->selected_text_color.g == bs->selector_color.g 
    && bs->selected_text_color.b == bs->selector_color.b )
    {
        bs->selected_text_color.r ^= 0xff;
        bs->selected_text_color.g ^= 0xff;
        bs->selected_text_color.b ^= 0xff;
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_init_multi_line_input_box_for_show
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_init_multi_line_input_box_for_show(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__UI_PAGING_IN_MULTILINE_EDITOR__)
    b->edit_height_displayed_lines = 0; /* ritesh */
    b->current_page_count = 0;
#endif 

    if (b->header_height > 0)
        b->header_gap = 1;
    else
        b->header_gap = 0;

    if (!bs->find_new_cursor_flag)
    {
		b->line_before_cursor_line_p = b->text;
		b->cursor_line_p = b->text;
		b->line_after_cursor_line_p = b->text;
		b->line_after_cursor_line_last_p = b->text;
		b->last_position_p = b->text;
    }
}

#if defined(__MMI_ARSHAPING_ENGINE__) && defined(__MMI_BIDI_ALG__)
/*****************************************************************************
 * FUNCTION
 *  gui_translate_multi_line_buffer_to_shaping
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
 //extern  void ArabicShapeEngine2(U16* len, U16* str, U16* Orgstr, U16* p);

void gui_translate_multi_line_buffer_to_shaping(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 text_len;
    UI_buffer_type end_p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (bs->arabic_char_flag && (b->text_length / ENCODING_LENGTH) - 1 != 0)
    {
        int i;

        pfnUnicodeStrncpy((S8*) shaping_str, (const S8*)b->text, MAX_TEXT_LENGTH - 1);
        shaping_str[MAX_TEXT_LENGTH - 1] = 0;
        bs->backup_text = b->text;
        bs->cursor_moved_by_shaping = 0;

        if (b->text_length < MAX_TEXT_LENGTH * ENCODING_LENGTH)
            unshaped_text_len = text_len = (b->text_length / 2) - 1;
        else
            unshaped_text_len = text_len = MAX_TEXT_LENGTH - 1;

        for (i = 0; i <= text_len; i++)
            OrgToSha[i] = i;

        //ArabicShapeEngine2((U16*) &text_len, (U16*) shaping_str, (U16*) OrgToSha, NULL);
        ArabicShapeEngine2_ext((U16*) &text_len, (U16*) shaping_str, (U16*) OrgToSha, NULL);

        b->text = (UI_buffer_type) shaping_str;
        shaped_text_len = text_len;
        OrgToSha[unshaped_text_len] = shaped_text_len;
        OrgToSha[unshaped_text_len + 1] = shaped_text_len + 1;

        if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_INPUT_METHOD_MODE
            && b->input_mode_cursor_p != b->cursor_p)
        {
            UI_buffer_type p1, p2;

            p1 = b->text + gui_multi_line_mapping_org_to_sha((b->cursor_p - bs->backup_text) / 2) * 2;
            p2 = b->text + gui_multi_line_mapping_org_to_sha((b->input_mode_cursor_p - bs->backup_text) / 2) * 2;
            if (p1==p2)
                bs->cursor_moved_by_shaping = 1;
        }

        b->cursor_p = b->text + gui_multi_line_mapping_org_to_sha((b->cursor_p - bs->backup_text) / 2) * 2;

#if defined(__UI_PAGING_IN_MULTILINE_EDITOR__)
        if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_VIEW_PAGING_MODE)
        {
            if (b->jump_offset_from_app > 0)
            {
                b->jump_offset_from_app = (S16)gui_multi_line_mapping_org_to_sha(b->jump_offset_from_app);
            }
            
            if (b->page_offset > 0)
            {
                b->page_offset = (S16)gui_multi_line_mapping_org_to_sha(b->page_offset);
            }
        }
#endif
        if ((b->flags & UI_MULTI_LINE_INPUT_BOX_WORD_HIGHLIGHT) && b->highlight_start_position != NULL)
        {
            S32 d = 0, index = 0;
            
            index = (b->highlight_end_position - bs->backup_text)/2;
            if (index > 0)
            {
                if (gui_multi_line_mapping_org_to_sha(index) == gui_multi_line_mapping_org_to_sha(index-1))
                    d = 1;
            }

            b->highlight_start_position = b->text
                + gui_multi_line_mapping_org_to_sha((b->highlight_start_position - bs->backup_text) / 2) * 2;
            b->highlight_end_position = b->text
                + gui_multi_line_mapping_org_to_sha((b->highlight_end_position - bs->backup_text) / 2) * 2;
            
            if (d)
            {
                b->highlight_end_position += ENCODING_LENGTH;
            }

            if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_INPUT_METHOD_MODE)
            {
                if (b->cursor_p > b->highlight_start_position
                    && b->cursor_p < b->highlight_end_position)
                    b->cursor_p = b->highlight_end_position;
            }
        }

        if(b->hilite_str_number > 0 && b->hilite_list != NULL)
        {
            /* all the highlighted member should be mapped to the shaping data */
            for (i = 0; i<b->hilite_str_number; i++)
            {
                end_p = (UI_buffer_type)b->hilite_list[i].str_addr + b->hilite_list[i].length * 2;
                end_p = (UI_buffer_type)b->text
                    + gui_multi_line_mapping_org_to_sha(((UI_buffer_type)end_p - bs->backup_text) / 2) * 2;
                
                b->hilite_list[i].str_addr = (PS8)b->text
                    + gui_multi_line_mapping_org_to_sha(((UI_buffer_type)b->hilite_list[i].str_addr - bs->backup_text) / 2) * 2;
                
                b->hilite_list[i].length = (U16)(end_p - (UI_buffer_type)b->hilite_list[i].str_addr)/2;
            }
        }

        if (bs->find_new_cursor_flag)
        {
           /*
            * Commonly, these variables are recalculated using cursor_p.
            * But if find_new_cursor_flag is true, the cursor_p is invalid
            * and need to find its value. The following variables need to be
            * used.
            */
            ASSERT(!b->debug_flag);
           
            b->line_before_cursor_line_p = 
				b->text + gui_multi_line_mapping_org_to_sha((b->line_before_cursor_line_p - bs->backup_text) / 2) * 2;
            b->line_after_cursor_line_p = 
				b->text + gui_multi_line_mapping_org_to_sha((b->line_after_cursor_line_p - bs->backup_text) / 2) * 2;
            b->line_after_cursor_line_last_p = 
				b->text + gui_multi_line_mapping_org_to_sha((b->line_after_cursor_line_last_p - bs->backup_text) / 2) * 2;

            b->debug_flag = 1;
        }
        else
        {
            b->line_before_cursor_line_p = b->text;
            b->cursor_line_p = b->text;
            b->line_after_cursor_line_p = b->text;
            b->line_after_cursor_line_last_p = b->text;
            b->last_position_p = b->text;

            b->debug_flag = 0;
        }
    }
}

/*****************************************************************************
 * FUNCTION
 *  gui_retore_multi_line_buffer_from_shaping
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_retore_multi_line_buffer_from_shaping(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_buffer_type end_p;
    U32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (bs->arabic_char_flag && (b->text_length / ENCODING_LENGTH) - 1 != 0)
    {
        b->text = bs->backup_text;

        if ((b->flags & UI_MULTI_LINE_INPUT_BOX_WORD_HIGHLIGHT) && b->highlight_start_position != NULL)
        {
            b->highlight_start_position = b->text
                + gui_multi_line_mapping_sha_to_org((b->highlight_start_position - (UI_buffer_type) shaping_str) / 2) *
                2;
            b->highlight_end_position =
                b->text +
                gui_multi_line_mapping_sha_to_org((b->highlight_end_position - (UI_buffer_type) shaping_str) / 2) * 2;
        }

        if(b->hilite_str_number > 0 && b->hilite_list != NULL)
        {
            /* all the highlighted member should be mapped to the shaping data */
            for (i = 0; i<b->hilite_str_number; i++)
            {
                end_p = (UI_buffer_type)b->hilite_list[i].str_addr + b->hilite_list[i].length * 2;
                end_p = (UI_buffer_type)b->text
                    + gui_multi_line_mapping_org_to_sha(((UI_buffer_type)end_p - (UI_buffer_type) shaping_str) / 2) * 2;
                
                b->hilite_list[i].str_addr = (PS8)b->text
                    + gui_multi_line_mapping_org_to_sha(((UI_buffer_type)b->hilite_list[i].str_addr - (UI_buffer_type) shaping_str) / 2) * 2;
                
                b->hilite_list[i].length = (U16)(end_p - (UI_buffer_type)b->hilite_list[i].str_addr)/2;
            }
        }
         

        b->cursor_p = 
				b->text + gui_multi_line_mapping_sha_to_org((b->cursor_p - (UI_buffer_type) shaping_str) / 2) * 2;
        
		if (!bs->find_new_cursor_flag)
		{
			b->line_before_cursor_line_p =
				b->text + gui_multi_line_mapping_sha_to_org((b->line_before_cursor_line_p - (UI_buffer_type) shaping_str) / 2) * 2;
			b->cursor_line_p =
				b->text + gui_multi_line_mapping_sha_to_org((b->cursor_line_p - (UI_buffer_type) shaping_str) / 2) * 2;
			b->line_after_cursor_line_p =
				b->text + gui_multi_line_mapping_sha_to_org((b->line_after_cursor_line_p - (UI_buffer_type) shaping_str) / 2) * 2;
			b->line_after_cursor_line_last_p =
				b->text + gui_multi_line_mapping_sha_to_org((b->line_after_cursor_line_last_p - (UI_buffer_type) shaping_str) / 2) * 2;
			b->last_position_p =
				b->text + gui_multi_line_mapping_sha_to_org((b->last_position_p - (UI_buffer_type) shaping_str) / 2) * 2;
		}
    }
}
#endif /* defined(__MMI_ARSHAPING_ENGINE__) && defined(__MMI_BIDI_ALG__) */ 


/*****************************************************************************
 * FUNCTION
 *  gui_prepare_multi_line_show_area
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_prepare_multi_line_show_area(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((b->flags & UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW)
        && b->flags & UI_MULTI_LINE_INPUT_BOX_AUTO_DISABLE_SCROLLBAR
        && !(b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_VIEW_PAGING_MODE)
        && bs->find_new_cursor_flag != FINDING_CURSOR)
    {
        gui_set_vertical_scrollbar_range(&b->vbar, 0);
        gui_set_vertical_scrollbar_scale(&b->vbar, 0);
    }

    if (r2lMMIFlag)
    {
        if (b->flags & UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR)
        {
            bs->x1 = b->x;
        }
        else if (b->flags & UI_MULTI_LINE_INPUT_BOX_AUTO_DISABLE_SCROLLBAR)
        {
            if (b->vbar.scale != 0
                && (b->vbar.scale < b->vbar.range + 2))
            {
                bs->x1 = b->x + b->vbar.width + 1;  /* hjf it should not  - 5; */
            }
            else
            {
                bs->x1 = b->x;
            }
        }
        else
        {
            bs->x1 = b->x + b->vbar.width + 1;  /* hjf it should not - 5; */
        }
    }
    else
    {
        bs->x1 = b->x;
    }

    bs->y1 = b->y;
    bs->x2 = b->x + b->width - 1;   /* b->width contains the width of vbar */
    bs->y2 = bs->y1 + b->height - 1;
    bs->edit_width = b->edit_width;
    bs->edit_height = b->edit_height;
}


/*****************************************************************************
 * FUNCTION
 *  gui_draw_multi_line_background_area
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_multi_line_background_area(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_filled_area f;
    S32 l_height = 0, l_clip;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    bs->l_clip = l_clip = 0;

 
#if defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__)
    if (MMI_multi_line_inputbox_present)
    {
        b->flags |= UI_MULTI_LINE_INPUT_BOX_AUTO_DISABLE_SCROLLBAR;
        b->flags |= UI_MULTI_LINE_INPUT_BOX_INSIDE_INLINE_MENU;
        bs->l_clip = l_clip = bs->y2 - (MMI_content_height + MMI_content_y - 1);

        if (l_clip < 0)
        {
            l_clip = 0;
        }
    }
#endif /* defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__) */ 

    if (!(bs->flags & UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW))    /* If not disable draw then do it.. */
    {
        if (bs->flags & UI_MULTI_LINE_INPUT_BOX_STATE_FOCUSSED)
        {
            f = *b->focussed_filler;
            bs->rich_text.default_color = bs->rich_text.curr_color = b->focussed_text_color;
        }
        else if (bs->flags & UI_MULTI_LINE_INPUT_BOX_STATE_DISABLED)
        {
            f = *b->disabled_filler;
            bs->rich_text.default_color = bs->rich_text.curr_color = b->disabled_text_color;
        }
        else
        {
            f = *b->normal_filler;
            bs->rich_text.default_color = bs->rich_text.curr_color = b->normal_text_color;
        }

        if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_SET_BG_COLOR)
        {
            f.c = b->default_bg_color;
        }

    #if defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__)
        if (MMI_multi_line_inputbox_present == 1)
        {
 
            l_height = INFORMATION_BAR_HEIGHT + 2;
  
        #if(!INSCREEN_MUTLILINE_TITLE_ENABLE)
            if (b->flags & UI_MULTI_LINE_INPUT_BOX_VIEW_MODE)
            {
                l_height = 0;
            }
        #endif /* (!INSCREEN_MUTLILINE_TITLE_ENABLE) */ 
        }
    #endif /* defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__) */ 

        gui_push_clip();

        if (bs->flags & UI_MULTI_LINE_INPUT_BOX_USE_PRESET_CLIPPING)
        {
            gui_set_clip_preset(b->x, bs->y1 - l_height, bs->x2 + 2, bs->y2 + 2 - l_clip);
        }
        else
        {
             
            gui_set_clip(b->x, bs->y1 - l_height, bs->x2 + 2, bs->y2 - l_clip);
        }

        if (!(bs->flags & UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND))  /* if not disable background then do .. */
        {
            if (b->ext_flags &
                (GUI_MULTI_LINE_INPUT_BOX_NONE_BORDER
                 | GUI_MULTI_LINE_INPUT_BOX_SINGLE_BORDER | GUI_MULTI_LINE_INPUT_BOX_DOUBLE_BORDER))
            {
                /* If user set these flag, use the user setting instead of the theme setting */
                f.flags &= ~(UI_FILLED_AREA_SINGLE_BORDER | UI_FILLED_AREA_DOUBLE_BORDER);
                if (!(b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_NONE_BORDER))
                {
                    if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_SINGLE_BORDER)
                    {
                        f.flags |= UI_FILLED_AREA_SINGLE_BORDER;
                    }
                    else if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_DOUBLE_BORDER)
                    {
                        f.flags |= UI_FILLED_AREA_DOUBLE_BORDER;
                    }
                }

            }

            if (!(bs->flags & UI_MULTI_LINE_INPUT_BOX_INCLUDE_INFO_AREA))       /* if not include info_area then do .. */
            {
                /* Draw standard background filler */
                 
                if (r2lMMIFlag)
                {
                    if ((wgui_is_wallpaper_on_bottom() == MMI_TRUE) &&
                        (bs->flags & UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND))
                    {
                        gdi_draw_solid_rect(
                            b->x,
                            bs->y1 - l_height,
                            bs->x2 /* +b->vbar.width */ ,
                            bs->y2,
                            GDI_COLOR_TRANSPARENT);
                    }
                    else
                    {
                        gui_draw_filled_area(b->x, bs->y1 - l_height, bs->x2 /* +b->vbar.width */ , bs->y2, &f);
                    }
                }
                else
                {
                    if ((wgui_is_wallpaper_on_bottom() == MMI_TRUE) &&
                        (bs->flags & UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND))
                    {
                        gdi_draw_solid_rect(bs->x1, bs->y1 - l_height, bs->x2, bs->y2, GDI_COLOR_TRANSPARENT);
                    }
                    else
                    {
                        gui_draw_filled_area(bs->x1, bs->y1 - l_height, bs->x2, bs->y2, &f);
                    }
                }
                 

                /*
                 * Draw b->text_filler for text area only.
                 * (typically when b->header_height or b->footer_callback is non-zero)
                 */
                if (b->text_filler)
                {
                    /*
                     * This filler can only be used in View Mode such that b->text_height can be pre-computed
                     * at the first time in something like show_multiline_inputbox_no_draw().
                     */

                    S32 text_border_y1, text_border_y2;

                    MMI_ASSERT((bs->flags & UI_MULTI_LINE_INPUT_BOX_VIEW_MODE) != 0 && l_clip == 0);

                    text_border_y1 = bs->y1 + b->text_y + b->text_offset_y + b->header_height - 1;
                    text_border_y2 = bs->y1 + b->text_y + b->text_offset_y + 2 + b->text_height - b->footer_height;

                    /* If text_height is large, we should shrink the filling area */
                    if (text_border_y1 < 0)
                    {
                        text_border_y1 = 0;
                    }
                    if (text_border_y2 >= UI_device_height)
                    {
                        text_border_y2 = UI_device_height - 1;
                    }

                    gui_push_clip();
                    if ((f.flags & UI_FILLED_AREA_DOUBLE_BORDER) == UI_FILLED_AREA_DOUBLE_BORDER)
                    {
                        gui_set_clip(bs->x1 + 2, bs->y1 + 2, bs->x2 - 2, bs->y2 - 2);
                    }
                    else if (f.flags & UI_FILLED_AREA_BORDER)
                    {
                        gui_set_clip(bs->x1 + 1, bs->y1 + 1, bs->x2 - 1, bs->y2 - 1);
                    }
                    gui_draw_filled_area(
                        bs->x1 + b->text_x + b->text_offset_x - 1,
                        text_border_y1,
                        bs->x1 + b->text_x + b->text_offset_x + b->edit_width,
                        text_border_y2,
                        b->text_filler);
                    gui_pop_clip();
                }
            }
            else    /* if including info_area then do .. */
            {
                gui_set_clip(b->x, bs->y1 - wgui_inputbox_information_bar_height - l_height, bs->x2, bs->y2 - l_clip);
                f.flags = UI_FILLED_AREA_TYPE_BITMAP;
                f.b = get_image(WGUI_VOLUME_LEVEL1);    /* test */

                 
                if ((wgui_is_wallpaper_on_bottom() == MMI_TRUE) &&
                    (bs->flags & UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND))
                {
                    gdi_draw_solid_rect(
                        b->x,
                        bs->y1 - wgui_inputbox_information_bar_height - l_height,
                        bs->x2,
                        bs->y2,
                        GDI_COLOR_TRANSPARENT);
                }
                else
                {
                    gui_draw_filled_area(
                        b->x,
                        bs->y1 - wgui_inputbox_information_bar_height - l_height,
                        bs->x2,
                        bs->y2,
                        &f);
                }
                 

                if (r2lMMIFlag)
                {
                    gui_draw_rectangle(
                        b->x,
                        bs->y1 - l_height,
                        bs->x2 /* +b->vbar.width */ ,
                        bs->y2,
                        b->boundary_color);
                }
                else
                {
                    gui_draw_rectangle(bs->x1, bs->y1 - l_height, bs->x2, bs->y2, b->boundary_color);
                }

                if (bs->flags & UI_MULTI_LINE_INPUT_BOX_USE_PRESET_CLIPPING)
                {
                    gui_set_clip_preset(bs->x1, bs->y1 - l_height, bs->x2 + 2, bs->y2 + 2 - l_clip);
                }
                else
                {
                    gui_set_clip(bs->x1, bs->y1 - l_height, bs->x2 + 2, bs->y2 + 2 - l_clip);
                }
            }
        }

    #if defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__)
        if (MMI_multi_line_inputbox_present)
        {
 
            if (!(b->flags & UI_MULTI_LINE_INPUT_BOX_VIEW_MODE))
            {
                //Show Information Bar
                 
                if (wgui_inputbox_information_flag)
                {
                    wgui_redraw_input_information_bar();
                }
                 
            }
        #if(INSCREEN_MUTLILINE_TITLE_ENABLE)
 
            else
            {
                /* Show Signature Text.... */
                gui_draw_inscreen_multi_line_input_box_title(bs->x1, bs->y1 - l_height + 1, bs->x2 - 2, bs->y1 - 1);
            }
        #endif /* (INSCREEN_MUTLILINE_TITLE_ENABLE) */ 
        }
    #endif /* defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__) */ 
    }
}

#ifdef __MMI_BIDI_ALG__


/*****************************************************************************
 * FUNCTION
 *  gui_get_multi_line_text_language_type
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_get_multi_line_text_language_type(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 iCount;
    U8 lastest_char_type;
    UI_character_type dummy_c;
    U16 strongCharType = 0xFFFF;
    UI_buffer_type text_p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((b->text_length / ENCODING_LENGTH) - 1 != 0)
    {
        for (iCount = 0; iCount < (U32) ((b->text_length >> 1) - 1); iCount++)
        {
            text_p = (UI_buffer_type)(b->text + iCount * ENCODING_LENGTH);
            UI_STRING_GET_NEXT_CHARACTER(text_p, dummy_c);
                
#ifdef __MMI_MESSAGES_CHAT__
            if(b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_CHAT_ICON_DISPLAY)
            {
                if (UI_TEST_GRP_SEP_CHARACTER(dummy_c)
                    ||UI_TEST_FILE_SEP_CHARACTER(dummy_c)
                    ||UI_TEST_SENDER_TRUNCATE_SEP_CHARACTER(dummy_c)
                    ||UI_TEST_RECEIVER_TRUNCATE_SEP_CHARACTER(dummy_c))
                    continue;
            }
#endif /* __MMI_MESSAGES_CHAT__ */

            if ((bs->flags & UI_MULTI_LINE_INPUT_BOX_RICHTEXT) && GUI_INPUT_IS_MARKER(dummy_c))
                continue;

            bidi_get_char_type((U8*) (b->text + iCount * ENCODING_LENGTH), (U8*) & lastest_char_type);
            if ((lastest_char_type == AL 
                 || lastest_char_type == BIDI_L 
                 || lastest_char_type == BIDI_R
                 || lastest_char_type == AN)
                && strongCharType == 0xFFFF)
            {
                strongCharType = lastest_char_type;
            }
            
            if ((lastest_char_type == AL) || (lastest_char_type == AN) || (lastest_char_type == BIDI_R))
            {
                bs->arabic_char_flag = MMI_TRUE;
                break;
            }
        }

        bidi_get_char_type(b->text, (U8*) & bs->default_direction);
    #ifdef GUI_INPUTBOX_ALIGNMENT_WHEN_EXIST_R2L_CHAR
        if (bs->arabic_char_flag)
    #else 
        if (strongCharType == AL || strongCharType == BIDI_R || strongCharType == AN)
    #endif 
        {
            bs->default_direction = BIDI_R;
        }
        else
        {
            bs->default_direction = BIDI_L;
        }
    }
}
#endif /* __MMI_BIDI_ALG__ */ 


/*****************************************************************************
 * FUNCTION
 *  gui_set_multi_line_text_area_range
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_multi_line_text_area_range(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* hjf recalculate the x boundary */
    if (!(bs->flags & UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR) && !r2lMMIFlag)
    {
        if (bs->flags & UI_MULTI_LINE_INPUT_BOX_AUTO_DISABLE_SCROLLBAR)
        {
            if (b->vbar.scale != 0
                && (b->vbar.scale < b->vbar.range))
                bs->x2 -= b->vbar.width;
        }
        else
            bs->x2 -= b->vbar.width;
    }

    bs->x1 += b->left_width;
    bs->x2 -= (b->text_x2_gap_width + b->right_width);

    if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_FIXED_TEXT_AREA)
    {
        bs->backup_x1 = bs->x1;
        bs->backup_x2 = bs->x2;
        bs->x1 += b->fixed_text_start_x;
        bs->x2 = bs->x1 + b->fixed_text_width;
    }

    bs->edit_width = (bs->x2 - bs->x1 - b->text_x);

    if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_SINGLE_BORDER)
    {
        bs->edit_width -= 2;
    }
    else if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_DOUBLE_BORDER)
    {
        bs->edit_width -= 4;
    }

    b->edit_width = bs->edit_width;
}


/*****************************************************************************
 * FUNCTION
 *  gui_setup_multi_line_text_clip
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_setup_multi_line_text_clip(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_filled_area f;
    S32 clip_x1, clip_y1, clip_x2, clip_y2, l_clip = bs->l_clip;
    U32 chk_flags;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (bs->flags & UI_MULTI_LINE_INPUT_BOX_STATE_FOCUSSED)
    {
        f = *b->focussed_filler;
    }
    else if (bs->flags & UI_MULTI_LINE_INPUT_BOX_STATE_DISABLED)
    {
        f = *b->disabled_filler;
    }
    else
    {
        f = *b->normal_filler;
    }
    
    if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_SET_BG_COLOR)
    {
        f.c = b->default_bg_color;
    }
    
    if (b->ext_flags &
        (GUI_MULTI_LINE_INPUT_BOX_NONE_BORDER
        | GUI_MULTI_LINE_INPUT_BOX_SINGLE_BORDER | GUI_MULTI_LINE_INPUT_BOX_DOUBLE_BORDER))
    {
        /* If user set these flag, use the user setting instead of the theme setting */
        f.flags &= ~(UI_FILLED_AREA_SINGLE_BORDER | UI_FILLED_AREA_DOUBLE_BORDER);
        if (!(b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_NONE_BORDER))
        {
            if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_SINGLE_BORDER)
            {
                f.flags |= UI_FILLED_AREA_SINGLE_BORDER;
            }
            else if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_DOUBLE_BORDER)
            {
                f.flags |= UI_FILLED_AREA_DOUBLE_BORDER;
            }
        }
    }
    chk_flags = f.flags;
    
    /* Clipping is poped after the editor has finished drawing */
    if (!(bs->flags & UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW))    /* if not disable draw then do ... */
    {
        gui_push_text_clip();
        gui_push_clip();
    }
    
    if ((chk_flags & UI_FILLED_AREA_DOUBLE_BORDER) == UI_FILLED_AREA_DOUBLE_BORDER)
    {
        bs->border_y = 2;
        clip_x1 = bs->x1 + 2;
        clip_y1 = bs->y1 + 2;
        clip_x2 = bs->x2 - 2;
        clip_y2 = bs->y2 - ((l_clip > 2) ? l_clip : 2);
    }
    else if (chk_flags & UI_FILLED_AREA_BORDER)
    {
        bs->border_y = 1;
        clip_x1 = bs->x1 + 1;
        clip_y1 = bs->y1 + 1;
        clip_x2 = bs->x2 - 1;
        clip_y2 = bs->y2 - ((l_clip > 1) ? l_clip : 1);
    }
    else
    {
        bs->border_y = 0;
        clip_x1 = bs->x1;
        clip_y1 = bs->y1;
        clip_x2 = bs->x2;
        clip_y2 = bs->y2 - l_clip;
    }
    
    clip_y1 += b->text_y;
    
    if (!(bs->flags & UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW))    /* if not disable draw then do ... */
    {
        if (bs->flags & UI_MULTI_LINE_INPUT_BOX_USE_PRESET_CLIPPING)
        {
            gui_set_text_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
            gui_set_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
        }
        else
        {
            gui_set_text_clip(clip_x1, clip_y1, clip_x2, clip_y2);
            gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
        }
    }
    
    bs->edit_height = b->edit_height = clip_y2 - clip_y1 + 1;
}


/*****************************************************************************
 * FUNCTION
 *  gui_set_multi_line_default_font
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_multi_line_default_font(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
#ifdef __UI_PAGING_IN_MULTILINE_EDITOR__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_VIEW_PAGING_MODE)
    {
        switch (b->font_style)
        {
            case FONT_DEFAULT:
                bs->rich_text.curr_font.italic = bs->rich_text.curr_font.bold = 0;
                break;
            case FONT_BOLD:
                bs->rich_text.curr_font.bold = 1;
                bs->rich_text.curr_font.italic = 0;
                break;
            case FONT_ITALIC:
                bs->rich_text.curr_font.italic = 1;
                bs->rich_text.curr_font.bold = 0;
                break;
        }
        bs->rich_text.line_end_font = bs->rich_text.line_begin_font = bs->rich_text.curr_font;
    }
#endif /* __UI_PAGING_IN_MULTILINE_EDITOR__ */ 

    gui_set_font(&(bs->rich_text.curr_font));   /* set text font */

}


/*****************************************************************************
 * FUNCTION
 *  gui_adjust_multi_line_cursor_for_language
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_adjust_multi_line_cursor_for_language(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
#if defined(__MMI_LANG_VIETNAMESE__)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    viet_tone_mark tone_mark = VIET_TONE_NONE;
    viet_vowel_letter viet_vowel = VIET_VOWEL_NONE;
    UI_buffer_type temp_cursor_p = b->cursor_p;
    UI_character_type temp_tone, temp_vowel, dummy_c;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
     
    if (((b->text_length >> 1) - 1) != 0)
    {
        UI_STRING_GET_NEXT_CHARACTER(temp_cursor_p, temp_tone);
        if ((temp_tone >= 0x0300) && (temp_tone <= 0x0323))
        {
            temp_cursor_p = b->cursor_p;
            UI_STRING_GET_PREVIOUS_CHARACTER(temp_cursor_p, temp_vowel);        /* get next character */
            viet_vowel = mmi_viet_vowel_letter(temp_vowel);
            if (VIET_VOWEL_NONE != viet_vowel)
            {
                tone_mark = mmi_viet_tone_mark(temp_tone);
                if (VIET_TONE_NONE != tone_mark)
                {
                    dummy_c = mmi_viet_combine_vowel_tone(viet_vowel, tone_mark);
                    UI_STRING_GET_NEXT_CHARACTER(b->cursor_p, dummy_c);
                }
            }
        }
    }
#endif /* defined(__MMI_LANG_VIETNAMESE__) */ 
}


/*****************************************************************************
 * FUNCTION
 *  gui_prepare_multi_line_new_line_loop
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_prepare_multi_line_new_line_loop(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_set_font(&(bs->rich_text.curr_font));

    /* Restore the text_gap and line spacing */
    bs->rich_text.more_line_spacing = 0;
    bs->rich_text.line_separator = 0;

    bs->previous_line_height = g_editor_line.line_height;
    bs->draw_separator = FALSE;

    /*
     * Backup the font at the beginning of line
     * Alignment is setup in the first pass only, and color_t is set in the second pass only.
     */
    bs->rich_text.curr_font = bs->rich_text.line_begin_font = bs->rich_text.line_end_font;
    bs->rich_text.curr_border = bs->rich_text.line_begin_border = bs->rich_text.line_end_border;
    bs->rich_text.curr_strikethrough = bs->rich_text.line_begin_strikethrough = bs->rich_text.line_end_strikethrough;
    bs->rich_text.curr_color = bs->rich_text.line_begin_color = bs->rich_text.line_end_color;

    g_editor_line.bidi_done_flag = 0;
    g_editor_line.cursor_line_flag = 0;
    g_editor_line.override_flag = 0;
    g_editor_line.marker_flag = 0;

}


/*****************************************************************************
 * FUNCTION
 *  gui_end_multi_line_new_line_loop
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_end_multi_line_new_line_loop(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 y;
    static const U8 dotted_line_bitvalues[] = {1, 1, 0, 0};
    static const U8 line_separator_value[] = {1, 0};
    S32 gap = b->edit_width >> 3;
    S32 yoffset = (bs->rich_text.more_line_spacing >> 1) + 1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* draw the seperator line */
    if (!(bs->flags & UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW) &&
        (bs->flags & UI_MULTI_LINE_INPUT_BOX_DRAW_SEPARATOR) && bs->draw_separator)
    {
        if (!(b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_HIDE_TEXT_CONTENT))
        {
        #ifdef __MMI_BIDI_ALG__
            if (bs->arabic_char_flag)
            {
                y = bs->yty + g_editor_line.line_height - 1;
            }
            else
                y = bs->yty + g_editor_line.line_height;
        #else /* __MMI_BIDI_ALG__ */ 
            y = bs->yty + g_editor_line.line_height;
        #endif /* __MMI_BIDI_ALG__ */ 

            gdi_draw_line_style(
                bs->xx + 5,
                y,
                bs->xx + b->edit_width - 1 - 5,
                y,
                gdi_act_color_from_rgb(255, 112, 125, 240),
                sizeof(dotted_line_bitvalues),
                dotted_line_bitvalues);
        }
    }

    if (bs->rich_text.line_separator)
    {
        if (!(b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_HIDE_TEXT_CONTENT))
        {
            gdi_draw_line_style(
                (S32) bs->xx + gap,
                (S32) bs->yty + yoffset,
                (S32) bs->xx + b->edit_width - 1 - gap,
                (S32) bs->yty + yoffset,
                (gdi_color) gdi_act_color_from_rgb(255, bs->rich_text.curr_color.r, bs->rich_text.curr_color.g, bs->rich_text.curr_color.b),
                sizeof(line_separator_value),
                line_separator_value);
        }
    }

    bs->ty += g_editor_line.line_height;

    if (bs->flags & UI_MULTI_LINE_INPUT_BOX_VIEW_MODE
        && g_editor_line.line_unit_count == 0
        && bs->end_line)
        bs->ty -= g_editor_line.line_height;

    if (g_editor_line.line_height > b->max_line_height)
    {
        b->max_line_height = g_editor_line.line_height;
    }

    bs->line_counter++;

    /* forward the current_text_p to the next line */
    bs->current_text_p = g_editor_line.line_start_p + g_editor_line.line_char_count * ENCODING_LENGTH;

}


/*****************************************************************************
 * FUNCTION
 *  gui_find_multi_line_one_line
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  
 *****************************************************************************/
U8 gui_find_multi_line_one_line(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 break_highlight = 0;
    U16 count = 0, cluster_count = 0, icon_count;
    U16 break_line_count = 0, auto_break = 1, break_unit_count = 0, break_line_width = 0;
    S32 width, height, temp_height;
    UI_character_type current_character = 0, pre_character = 0, next_character = 0;
    UI_buffer_type temp_text_p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_editor_line.line_width = 0;
    g_editor_line.line_height = gui_get_character_height() + 2;
    g_editor_line.line_char_count = 0;
    g_editor_line.line_unit_count = 0;
    g_editor_line.highlight_flag = 0;
    g_editor_line.line_start_p = bs->current_text_p;

    if (b->flags & UI_MULTI_LINE_INPUT_BOX_DISABLE_WRAPPING_BY_WORD)
        auto_break = 0;

    while (g_editor_line.line_char_count < 128)
    {
        gui_set_font(&(bs->rich_text.curr_font));

        pre_character = current_character;
        /* get the current character type */
        g_editor_line.line_char[count].char_type = gui_get_multi_line_current_cluster(b, bs, &current_character, &cluster_count);
        g_editor_line.line_char[count].width = 0;
        g_editor_line.line_char[count].adv_width = 0;
        g_editor_line.line_char[count].height = 0;
        g_editor_line.line_char[count].text_gap = b->text_gap;
        
#if defined(__MMI_LANG_THAI__)
        if (g_editor_line.line_char[count].char_type == THAI_CLUSTER)
        {
            if (b->cursor_p > bs->current_text_p
                && b->cursor_p < bs->current_text_p + cluster_count* ENCODING_LENGTH)
            {
                /* adjust the cursor position for THAI cluster */
                b->cursor_p = bs->current_text_p + cluster_count* ENCODING_LENGTH;
            }
        }
#endif
        if (UI_STRING_END_OF_STRING_CHARACTER(current_character))
        {
            /* the end of the whole text is reached */
            b->last_position_p = bs->current_text_p + ENCODING_LENGTH;
            
#ifdef __MMI_INDIC_ALG__
            gui_adjust_former_unit_width(count);
#endif
            return 0;
        }

        g_editor_line.line_char[count].char_count = cluster_count;

    #ifdef __MMI_MESSAGES_CHAT__
        if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_CHAT_ICON_DISPLAY)
        {
            if (UI_TEST_GRP_SEP_CHARACTER(current_character))
            {
                gdi_image_get_dimension((U8*) GetImage(CHAT_LOCAL_IMG), &width, &height);
                g_editor_line.line_char[count].char_type = CHAT_ICON_CHAR;
            }
            else if (UI_TEST_FILE_SEP_CHARACTER(current_character))
            {
                gdi_image_get_dimension((U8*) GetImage(CHAT_REMOTE_IMG), &width, &height);
                g_editor_line.line_char[count].char_type = CHAT_ICON_CHAR;
            }
            else if (UI_TEST_SENDER_TRUNCATE_SEP_CHARACTER(current_character))
            {
                gdi_image_get_dimension((U8*) GetImage(CHAT_SENDER_TRUNCATE_IMG), &width, &height);
                g_editor_line.line_char[count].char_type = CHAT_ICON_CHAR;
            }
            else if (UI_TEST_RECEIVER_TRUNCATE_SEP_CHARACTER(current_character))
            {
                gdi_image_get_dimension((U8*) GetImage(CHAT_RECEIVER_TRUNCATE_IMG), &width, &height);
                g_editor_line.line_char[count].char_type = CHAT_ICON_CHAR;
            }
        }
    #endif /* __MMI_MESSAGES_CHAT__ */ 

        if ((bs->flags & UI_MULTI_LINE_INPUT_BOX_RICHTEXT) && GUI_INPUT_IS_MARKER(current_character))
        {
            g_editor_line.line_char[count].char_type = MARKER_CHAR;
            gui_apply_multi_line_marker(b, bs, current_character, 1);
        }

    #if(MULTILINE_INPUTBOX_USE_CRLF_COMBINATION)
        if (UI_TEST_CR_CHARACTER(current_character))
        {
            temp_text_p = bs->current_text_p + ENCODING_LENGTH;
            UI_STRING_GET_NEXT_CHARACTER(temp_text_p, next_character);
            if (UI_TEST_LF_CHARACTER(next_character))
            {
                g_editor_line.line_char[count].char_type = CRLF_CLUSTER;
                g_editor_line.line_char[count].height = gui_get_character_height();
                g_editor_line.line_char[count].char_count = 2;
                g_editor_line.line_char[count].text_gap = 0;
                g_editor_line.line_char[count].width = 0;
            }
        }
    #endif /* (MULTILINE_INPUTBOX_USE_CRLF_COMBINATION) */ 

        if (b->icon_callback && (icon_count = b->icon_callback(bs->current_text_p, MMI_FALSE, &width, &height, 0, 0)))
        {

            g_editor_line.line_char[count].char_type = ICON_CALLBACK_CLUSTER;
            g_editor_line.line_char[count].text_gap = 0;
            g_editor_line.line_char[count].char_count = icon_count;
            g_editor_line.override_flag = 1;
            cluster_count = icon_count;
        }

        switch (g_editor_line.line_char[count].char_type)
        {
            case SINGLE_CHAR:
            {
            #if defined(__MMI_BIDI_ALG__) && defined(__MMI_ARSHAPING_ENGINE__)
                if (IS_ARABIC_CHARACTER(current_character))
                    g_editor_line.line_char[count].text_gap = 0;
            #endif /* defined(__MMI_BIDI_ALG__) && defined(__MMI_ARSHAPING_ENGINE__) */ 
            #ifdef __MMI_INDIC_ALG__
                if (IRE_INDIC_LANGUAGE_RANGE(current_character))
                {
                    g_editor_line.line_char[count].text_gap = 0;
                    g_editor_line.line_char[count].adv_width = gui_measure_character_adv_width(bs->current_text_p, 1);
                }
            #endif
                gui_measure_multi_line_character(bs, current_character, cluster_count, &width, &height);
                if ((bs->flags & UI_MULTI_LINE_INPUT_BOX_DRAW_SEPARATOR) && UI_TEST_ESC_CHARACTER(current_character))
                {
                    width = 0;
                #ifdef __MMI_BIDI_ALG__
                    if (bs->arabic_char_flag)
                    {
                        height = gui_get_character_height() + 3;
                    }
                    else
                #endif /* __MMI_BIDI_ALG__ */ 
                        height = gui_get_character_height() + 2;        /* reserve one more pixel */

                    bs->draw_separator = TRUE;
                }

            #if(MULTILINE_INPUTBOX_DISPLAY_SPECIAL_CHARACTERS)
                if (UI_TEST_CR_CHARACTER(current_character) ||
                    UI_TEST_LF_CHARACTER(current_character) || UI_TEST_ESC_CHARACTER(current_character))
                {
                    width = 10;
                    height = 10;
                }
            #else /* (MULTILINE_INPUTBOX_DISPLAY_SPECIAL_CHARACTERS) */ 
                if (UI_TEST_LF_CHARACTER(current_character) || UI_TEST_CR_CHARACTER(current_character))
                {
                    width = 0;
                    height = 0;
                }
            #endif /* (MULTILINE_INPUTBOX_DISPLAY_SPECIAL_CHARACTERS) */ 

                g_editor_line.line_char[count].width = width;
                g_editor_line.line_char[count].height = height;
            }
                break;

            case CRLF_CLUSTER:
                break;

            case MARKER_CHAR:
                /* size = 0 */
                g_editor_line.line_char[count].text_gap = 0;
                break;

            case CHAT_ICON_CHAR:
            case ICON_CALLBACK_CLUSTER:
                g_editor_line.line_char[count].width = width;
                g_editor_line.line_char[count].height = height;
                break;

#ifdef __MMI_INDIC_ALG__
            case INDIC_CLUSTER:
                g_editor_line.line_char[count].text_gap = 0;
                g_editor_line.line_char[count].adv_width = gui_measure_character_adv_width(bs->current_text_p, cluster_count);

                gui_measure_multi_line_character(bs, current_character, cluster_count, &width, &height);
                
                g_editor_line.line_char[count].width = width;
                g_editor_line.line_char[count].height = height;
                break;
#endif

            case VIET_CLUSTER:
            case THAI_CLUSTER:
                gui_measure_multi_line_character(bs, current_character, cluster_count, &width, &height);

                g_editor_line.line_char[count].width = width;
                g_editor_line.line_char[count].height = height;
                break;

            default:
                gui_measure_multi_line_character(bs, current_character, cluster_count, &width, &height);
                
                g_editor_line.line_char[count].width = width;
                g_editor_line.line_char[count].height = height;
                break;
        }

        /* check the highlight information */
        g_editor_line.line_char[count].highlight_flag = (U8)gui_check_multi_line_character_highlight(b, bs, count);
        if (g_editor_line.highlight_flag == 0 && g_editor_line.line_char[count].highlight_flag)
            g_editor_line.highlight_flag = 1;
        
#ifdef __MMI_INDIC_ALG__
        gui_adjust_former_unit_width(count);
#endif

        if (g_editor_line.line_width + g_editor_line.line_char[count].width + g_editor_line.line_char[count].text_gap
            < (bs->edit_width - 1)
            || g_editor_line.line_char[count].width == 0)
        {
            /* the current character is belong to the current line */

            /* check the whether to cut line by 0x20 or '-' */
            if (!UI_MULTI_LINE_INPUT_BOX_ALPHABETIC_CHARACTER_NEW(current_character)
                && g_editor_line.line_char[count].char_type != MARKER_CHAR && (1 == auto_break))
            {
                auto_break = 0;
            }

            g_editor_line.line_width += g_editor_line.line_char[count].width + g_editor_line.line_char[count].text_gap;
            temp_height = g_editor_line.line_char[count].height + bs->rich_text.more_line_spacing + 2;
            if (g_editor_line.line_height < temp_height)
                g_editor_line.line_height = temp_height;

            g_editor_line.line_char_count += g_editor_line.line_char[count].char_count;
            bs->current_text_p += g_editor_line.line_char[count].char_count * ENCODING_LENGTH;
            count++;
            g_editor_line.line_unit_count = count;

            if (auto_break)
            {
#if defined(__MMI_BIDI_ALG__) && defined(__MMI_ARSHAPING_ENGINE__)
                if (current_character == 0x20 
                    || current_character == 0x2D
                    || IS_ARABIC_CHARACTER(current_character))
#else
                if (current_character == 0x20 || current_character == 0x2D)
#endif
                {
                    break_line_count = g_editor_line.line_char_count;
                    break_unit_count = g_editor_line.line_unit_count;
                    break_line_width = g_editor_line.line_width;
                    break_highlight = bs->word_highlight;
                }
            }
        }
        else
        {
            /* the current line is end */
            break;
        }

        if (UI_TEST_LF_CHARACTER(current_character) || UI_TEST_CR_CHARACTER(current_character))
        {
            /* the current line is end */
            return 1;
        }
    }

    if (auto_break && break_line_count)
    {
        /* This line should be cut by 0x20 */
        g_editor_line.line_char_count = break_line_count;
        g_editor_line.line_unit_count = break_unit_count;
        g_editor_line.line_width = break_line_width;
        bs->word_highlight = break_highlight;
    }
    return 1;
}


/*****************************************************************************
 * FUNCTION
 *  gui_set_multi_line_cursor_information
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b               [?]         
 *  bs              [?]         
 *  end_line        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_multi_line_cursor_information(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_buffer_type current_line_end;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (bs->find_new_cursor_flag)
    {
        /* In this case, We can't use the b->cursor_p to find the cursor line */
        return;
    }

    current_line_end = bs->end_line ? (g_editor_line.line_start_p + (g_editor_line.line_char_count + 1) * ENCODING_LENGTH)
        : (g_editor_line.line_start_p + g_editor_line.line_char_count * ENCODING_LENGTH);

    if (b->cursor_p >= g_editor_line.line_start_p && b->cursor_p < current_line_end)
    {
        /* the cursor is at the current line */
        bs->cursor_line_found_flag = 1;
        g_editor_line.cursor_line_flag = 1;

        b->cursor_y = bs->ty;
        b->cursor_line_p = g_editor_line.line_start_p;
        b->cursor_line_position_counter = g_editor_line.line_char_count;
        bs->cursor_line_height = g_editor_line.line_height;
        if (bs->end_line)
        {
            b->line_after_cursor_line_p = b->cursor_line_p;
            b->line_after_cursor_line_last_p = g_editor_line.line_start_p + g_editor_line.line_char_count * ENCODING_LENGTH;
        }
    }
    else if (bs->cursor_line_found_flag)
    {
        if (g_editor_line.line_start_p == b->cursor_line_p + b->cursor_line_position_counter * ENCODING_LENGTH)
        {
            /* this is the next line of the cursor line */
            b->line_after_cursor_line_p = g_editor_line.line_start_p;
            b->line_after_cursor_line_last_p = b->line_after_cursor_line_p
                + g_editor_line.line_char_count * ENCODING_LENGTH;
        }
    }
    else if (!bs->cursor_line_found_flag)
    {
        b->line_before_cursor_line_p = g_editor_line.line_start_p;
    }

}

#ifdef __MMI_INDIC_ALG__
/*****************************************************************************
 * FUNCTION
 *  gui_measure_character_adv_width
 * DESCRIPTION
 *  
 * PARAMETERS
 *  bs                      [IN]         
 *  text_p                  [IN]        
 *  cluster_count           [IN]               
 * RETURNS
 *  S32
 *****************************************************************************/
S32 gui_measure_character_adv_width(UI_buffer_type text_p, U16 cluster_count)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fe_get_string_info_param_struct string_info;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    string_info.String = (U8 *)text_p;
    string_info.w = 0;
    string_info.n = cluster_count;
    string_info.enableTruncated = MMI_FALSE;
    string_info.targetWidth = -1;
    string_info.checklinebreak = 0;
    string_info.checkCompleteWord = 0;

    mmi_fe_get_string_widthheight_indic(&string_info);

    return string_info.adv_w;
}


/*****************************************************************************
 * FUNCTION
 *  gui_adjust_former_unit_width
 * DESCRIPTION
 *  
 * PARAMETERS
 *  count                      [IN]                       
 * RETURNS
 *  void
 *****************************************************************************/
void gui_adjust_former_unit_width(U16 count)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (count == 0)
        return;

    if (g_editor_line.line_char[count-1].adv_width != 0
        && g_editor_line.line_char[count-1].adv_width != g_editor_line.line_char[count-1].width)
    {
        /* the former is an Indic unit */
        if (g_editor_line.line_char[count].adv_width == 0)
        {
            /* the current is not an Indic unit */
            g_editor_line.line_width += g_editor_line.line_char[count-1].adv_width -
                g_editor_line.line_char[count-1].width;
            g_editor_line.line_char[count-1].width = g_editor_line.line_char[count-1].adv_width;
        }
    }

}
#endif

/*****************************************************************************
 * FUNCTION
 *  gui_measure_multi_line_character
 * DESCRIPTION
 *  
 * PARAMETERS
 *  bs                      [?]         
 *  current_character       [IN]        
 *  cluster_count           [IN]        
 *  width_p                 [?]         
 *  height_p                [?]         
 * RETURNS
 *  void
 *****************************************************************************/
void gui_measure_multi_line_character(
        multi_line_input_box_show_struct *bs,
        UI_character_type current_character,
        U16 cluster_count,
        S32 *width_p,
        S32 *height_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 width, height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_measure_character(current_character, &width, &height);
//    mmi_fe_get_char_info(current_character, &width, &width);

#ifdef __MMI_INDIC_ALG__
    {
        if (cluster_count > 1)
        {
            UI_buffer_type next_text_p = bs->current_text_p + cluster_count * ENCODING_LENGTH;
            
            if (IRE_INDIC_LANGUAGE_RANGE(current_character))
            {
                ire_get_next_cluster_p_with_size(bs->current_text_p, next_text_p, &width);
            }
        }
    }
#endif /* __MMI_INDIC_ALG__ */ 

    *width_p = width;
    *height_p = height;
}


/*****************************************************************************
 * FUNCTION
 *  gui_get_multi_line_current_cluster
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b                       [?]     
 *  bs                      [?]     
 *  current_character_p     [?]     
 *  cluster_count_p         [?]     
 * RETURNS
 *  
 *****************************************************************************/
U8 gui_get_multi_line_current_cluster(
    multi_line_input_box *b,
    multi_line_input_box_show_struct *bs,
    UI_character_type *current_character_p,
    U16 *cluster_count_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_character_type current_character;
    UI_buffer_type text_p = bs->current_text_p;

#if defined(__MMI_LANG_THAI__)
    U8 i;
#endif

#if defined(__MMI_LANG_VIETNAMESE__) || defined(__MMI_LANG_ARMENIAN__)
    UI_character_type dummy_c;
#endif

#if defined(__MMI_LANG_VIETNAMESE__)
    viet_tone_mark tone_mark = VIET_TONE_NONE;
    viet_vowel_letter viet_vowel = VIET_VOWEL_NONE;
#endif /* defined(__MMI_LANG_VIETNAMESE__) */ 

#ifdef __MMI_INDIC_ALG__
    UI_buffer_type temp_p;
#endif

#if defined(__MMI_LANG_THAI__)
    UI_character_type prechar, curchar;
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_STRING_GET_NEXT_CHARACTER(text_p, current_character);

#if defined(__MMI_FULL_SCREEN_EDITOR__) || defined(__MMI_TOUCH_SCREEN__)
    if (bs->flags & UI_MULTI_LINE_INPUT_BOX_MASK_CHARACTERS
        && !(UI_TEST_LF_CHARACTER(current_character) 
           || UI_TEST_CR_CHARACTER(current_character) 
           || UI_STRING_LINE_BREAK_CHARACTER(current_character)
           || UI_STRING_END_OF_STRING_CHARACTER(current_character)))
    {
        /* if this is a mask style, we will not find any cluster */
        if (!((bs->flags & UI_MULTI_LINE_INPUT_BOX_STATE_MULTITAP) 
            && (bs->current_text_p == bs->previous_cursor_p)))
        {
            current_character = b->mask_character;
        }
        
        *current_character_p = current_character;
        *cluster_count_p = 1;
        return SINGLE_CHAR;
    }
    else
#endif /* defined(__MMI_FULL_SCREEN_EDITOR__) || defined(__MMI_TOUCH_SCREEN__) */
    /* check the armenian */
#if defined(__MMI_LANG_ARMENIAN__)
    if ((current_character >= 0x0530) && (current_character <= 0x058A))
    {
        UI_STRING_GET_NEXT_CHARACTER(text_p, dummy_c);  /* get next character */
        if ((dummy_c >= 0x0530) && (dummy_c <= 0x058A))
        {
            dummy_c = mmi_fe_armenian_get_cluster(current_character, dummy_c);
            if (dummy_c)
            {  
                *current_character_p = dummy_c;
                *cluster_count_p = 2;
                return OTHER_CLUSTER;
            } 
        }
        
        UI_STRING_GET_PREVIOUS_CHARACTER(text_p, dummy_c);
    }
    else
#endif /* defined(__MMI_LANG_ARMENIAN__) */ 
    /* check the vietnamese */
#if defined(__MMI_LANG_VIETNAMESE__)
    if ((current_character > 0x0040) && (current_character < 0x01B1))
    {
        UI_STRING_GET_NEXT_CHARACTER(text_p, dummy_c);  /* get next character */
        tone_mark = mmi_viet_tone_mark(dummy_c);
        if (VIET_TONE_NONE != tone_mark)
        {
            viet_vowel = mmi_viet_vowel_letter(current_character);
            if (VIET_VOWEL_NONE != viet_vowel)
            {
                current_character = mmi_viet_combine_vowel_tone(viet_vowel, tone_mark);
                
                *current_character_p = current_character;
                *cluster_count_p = 2;
                return VIET_CLUSTER;
            }
            else
            {
                UI_STRING_GET_PREVIOUS_CHARACTER(text_p, dummy_c);
            }
        }
        else
        {
            UI_STRING_GET_PREVIOUS_CHARACTER(text_p, dummy_c);
        }
    }
    else
#endif /* defined(__MMI_LANG_VIETNAMESE__) */ 
#if defined(__MMI_LANG_THAI__)
    /* check the Thai */
    if (current_character >= 0x0E01 && current_character <= 0x0E7F)
    {
        curchar = current_character;

        for (i = 0; i < 2; i++)
        {
            prechar = curchar;
            UI_STRING_GET_NEXT_CHARACTER(text_p, curchar);
            if (RequireToMoveCursor(prechar, curchar))
                break;
        }

        if (i == 0)
        {
            *current_character_p = current_character;
            *cluster_count_p = 1;
            return SINGLE_CHAR;
        }
        else if (i == 1)
        {
            *current_character_p = current_character;
            *cluster_count_p = 2;
            return THAI_CLUSTER;
        }
        else if (i == 2)
        {
            *current_character_p = current_character;
            *cluster_count_p = 3;
            return THAI_CLUSTER;
        }
    }
    else
#endif /* defined(__MMI_LANG_THAI__) */ 
#ifdef __MMI_INDIC_ALG__
    if (IRE_INDIC_LANGUAGE_RANGE(current_character))
    {
        text_p = bs->current_text_p;
        temp_p = (UI_buffer_type)ire_get_next_cluster_p(text_p, b->text + b->text_length - 2);

        *current_character_p = current_character;
        *cluster_count_p = (temp_p - text_p) >> 1;
        if (*cluster_count_p > 1)
            return INDIC_CLUSTER;
        else
            return SINGLE_CHAR;
    }
    else
#endif /* __MMI_INDIC_ALG__ */ 
    *current_character_p = current_character; /* temp solution */

    /* common single character */
    *current_character_p = current_character;
    *cluster_count_p = 1;
    return SINGLE_CHAR;
}


/*****************************************************************************
 * FUNCTION
 *  gui_prepare_multi_line_one_line_show
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_prepare_multi_line_one_line_show(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 temp_x;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Restore the font at the beginning of line  */
    bs->rich_text.line_end_font = bs->rich_text.curr_font;
    bs->rich_text.line_end_border = bs->rich_text.curr_border;
    bs->rich_text.line_end_strikethrough = bs->rich_text.curr_strikethrough;
    bs->rich_text.line_end_color = bs->rich_text.curr_color;

    bs->rich_text.curr_font = bs->rich_text.line_begin_font;
    bs->rich_text.curr_border = bs->rich_text.line_begin_border;
    bs->rich_text.curr_strikethrough = bs->rich_text.line_begin_strikethrough;
    bs->rich_text.curr_color = bs->rich_text.line_begin_color;

    gui_set_font(&(bs->rich_text.curr_font));
    UI_MULTI_LINE_INPUT_BOX_SET_TEXT_COLOR(bs->rich_text.curr_color);

    bs->tx = 0;

	if (bs->rich_text.curr_alignment == GUI_INPUT_ALIGN_CENTER)
	{
		bs->tx = ((bs->edit_width >> 1) - (g_editor_line.line_width >> 1));
		if (bs->tx < 0)
		{
			bs->tx = 0;
		}
	}
	else if (bs->rich_text.curr_alignment == GUI_INPUT_ALIGN_RIGHT)
	{
		bs->tx = bs->edit_width - g_editor_line.line_width;
		if (bs->tx < 0)
		{
			bs->tx = 0;
		}
	}
	else
	{
		if (bs->default_direction == BIDI_L)
			bs->tx = 0;
		else
		{
			temp_x = (bs->x2 - b->text_x - b->text_offset_x) - g_editor_line.line_width;
			bs->tx = temp_x - bs->x1;
			if (bs->tx < 0)
			{
				bs->tx = 0;
			}
		}
	}

    bs->current_text_p = g_editor_line.line_start_p;
    /* adjust the current line height by the min_line_height */
    if (b->min_line_height > g_editor_line.line_height)
    {
        g_editor_line.line_height = b->min_line_height;
    }

    /* set the current line y offset */
    bs->yty = bs->yy + bs->ty;
}

#ifdef __UI_PAGING_IN_MULTILINE_EDITOR__


/*****************************************************************************
 * FUNCTION
 *  gui_calculate_multi_line_paging_information
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_calculate_multi_line_paging_information(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 current_line_height;
    U8 shared_data_count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    current_line_height = g_editor_line.line_height;
    if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_VIEW_PAGING_MODE)
    {
        /** to determine the height of the currently displayed window.if condition is taken here to get the current **/
        if (bs->total_page_height + b->header_gap + b->header_height >= -(b->text_offset_y)
            && (bs->total_page_height + b->header_gap + b->header_height < (-(b->text_offset_y) + bs->edit_height))
            && b->edit_height_displayed_lines + current_line_height <= bs->edit_height)
        {

            if (bs->total_page_height + b->header_gap + b->header_height == -b->text_offset_y)
            {
                if (b->text_offset_y == -(b->header_gap + b->header_height))
                {
                    b->text_offset = 0;
                }
                else
                {
                    b->text_offset = bs->char_count;
                }
            }
            if (bs->total_page_height + b->header_gap + b->header_height > -b->text_offset_y
                && bs->total_page_height + b->header_gap + b->header_height - (-b->text_offset_y) < bs->previous_line_height)
            {
                b->text_offset = bs->char_count;
            }
            
            if (bs->char_count == 0 && -b->text_offset_y <= b->header_gap + b->header_height)
                b->text_offset = bs->char_count;

            bs->total_page_height += current_line_height;
            b->edit_height_displayed_lines += current_line_height;
            b->current_page_count += g_editor_line.line_char_count;
        }
        else
        {
            bs->total_page_height += current_line_height;
        }

        bs->char_count += g_editor_line.line_char_count;  /* for every line ,char_count is incermented by the no of containing in that line */

        /* if concerned application wants to show the text from the particular offset then this offset value is copied into 
           page_offset element of the multiline structure.According to this text_offset_y is calculated.This page_offset is compared against char_count to get text_offset_y */
        if ((b->page_offset > 0 || b->jump_offset_from_app > 0)
            && (b->page_offset >= bs->char_count || b->jump_offset_from_app >= bs->char_count))
        {
            if (b->text_offset_y == b->header_height)
                b->text_offset_y -= b->header_gap;  /* for 1 gap between header and text content */

            b->text_offset_y -= current_line_height;
            b->text_offset = bs->char_count;
            b->edit_height_displayed_lines = 0;
            b->current_page_count = 0;
        }
        else if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_LOCATE_CURSOR
                 && (bs->ty + b->text_offset_y + current_line_height > 0) && bs->locate_cursor == 0)
        {
            b->cursor_p = g_editor_line.line_start_p;
            bs->locate_cursor = 1;
        }

        /*
         * this condition is tested for the 1st page.
         * "b->previous_shared_bytes" is considered to be the part of the page at 0th index in the buffer.it is needed to maintain the height of page 
         * available in the buffer.height of page is also dependent on the shared_bytes with next or previous page.
         * In case of next page entry,the page at 0th index will be out from the buffer and the page next to the removed one will come to 0th index and so on
         * 
         * check_flag: check_flag is needed to prevent the body of every if should be executed once.
         * 
         * page_size=512 bytes.if char_count>=512 then it should go through the if condition and set the check_flag to 1. 
         */
        if (bs->char_count >= (GUI_PAGE_SIZE + (b->previous_shared_bytes / ENCODING_LENGTH)) && bs->check_flag == 0)
        {
            /* if shared bytes is zero. previous_shared_bytes is the bytes which is shared between page at 0th and 1st index in the buffer** */
            if ((shared_data_count =
                 bs->char_count % (GUI_PAGE_SIZE + (b->previous_shared_bytes / ENCODING_LENGTH))) == 0)
            {
                b->page_details[PAGE_ZERO].page_id = b->start_id;
                b->page_details[PAGE_ZERO].page_height = bs->total_page_height;
                b->page_details[PAGE_ZERO].shared_no_of_bytes = 0;

            }
            else
            {
                memcpy(
                    b->page_details[PAGE_ZERO].shared_data,
                    b->text + (GUI_PAGE_SIZE + (b->previous_shared_bytes / ENCODING_LENGTH) - g_editor_line.line_char_count + shared_data_count) * ENCODING_LENGTH,
                    (g_editor_line.line_char_count - shared_data_count) * ENCODING_LENGTH);
                b->page_details[PAGE_ZERO].page_id = b->start_id;
                b->page_details[PAGE_ZERO].page_height = bs->total_page_height - current_line_height;
                b->page_details[PAGE_ZERO].shared_no_of_bytes =
                    (g_editor_line.line_char_count - shared_data_count) * ENCODING_LENGTH;
            }
            bs->check_flag = 1;
        }
        /*
         * 2nd page details calculation:
         * GUI_PAGE_SIZE=512 bytes.if char_count>=GUI_PAGE_SIZE*2 then it should go through the if condition and set the check_flag to 2. 
         */
        else if (bs->char_count >= GUI_PAGE_SIZE * 2 && bs->check_flag == 1)
        {
            if ((shared_data_count = bs->char_count % (GUI_PAGE_SIZE * 2)) == 0)
            {
                b->page_details[PAGE_ONE].page_id = b->start_id + 1;
                b->page_details[PAGE_ONE].page_height = bs->total_page_height - b->page_details[PAGE_ZERO].page_height;
                b->page_details[PAGE_ONE].shared_no_of_bytes = 0;
            }
            else
            {
                memcpy(
                    b->page_details[PAGE_ONE].shared_data,
                    b->text + ((GUI_PAGE_SIZE * 2) - g_editor_line.line_char_count + shared_data_count) * ENCODING_LENGTH,
                    (g_editor_line.line_char_count - shared_data_count) * ENCODING_LENGTH);
                b->page_details[PAGE_ONE].page_id = b->start_id + 1;
                b->page_details[PAGE_ONE].page_height =
                    bs->total_page_height - b->page_details[PAGE_ZERO].page_height - current_line_height;
                b->page_details[PAGE_ONE].shared_no_of_bytes =
                    (g_editor_line.line_char_count - shared_data_count) * ENCODING_LENGTH;
            }
            bs->check_flag = 2;
        }
        /*
         * 3rd page details calculation: 
         * GUI_PAGE_SIZE=512 bytes.if char_count>=GUI_PAGE_SIZE*3 then it should go through the if condition and set the check_flag to 3. 
         */
        else if (bs->char_count >= GUI_PAGE_SIZE * 3 && bs->check_flag == 2)
        {
            if ((shared_data_count = bs->char_count % (GUI_PAGE_SIZE * 3)) == 0)
            {
                b->page_details[PAGE_TWO].page_id = b->start_id + 2;
                b->page_details[PAGE_TWO].page_height =
                    bs->total_page_height - b->page_details[PAGE_ONE].page_height -
                    b->page_details[PAGE_ZERO].page_height;
                b->page_details[PAGE_TWO].shared_no_of_bytes = 0;
            }
            else
            {
                memcpy(
                    b->page_details[PAGE_TWO].shared_data,
                    b->text + ((GUI_PAGE_SIZE * 3) - g_editor_line.line_char_count + shared_data_count) * ENCODING_LENGTH,
                    (g_editor_line.line_char_count - shared_data_count) * ENCODING_LENGTH);
                b->page_details[PAGE_TWO].page_id = b->start_id + 2;
                b->page_details[PAGE_TWO].page_height =
                    bs->total_page_height - b->page_details[1].page_height -
                    b->page_details[0].page_height + current_line_height;
                b->page_details[PAGE_TWO].shared_no_of_bytes =
                    (g_editor_line.line_char_count - shared_data_count) * ENCODING_LENGTH;
            }
            bs->check_flag = 3;
        }
        /*
         * 4th page details calculation: 
         * GUI_PAGE_SIZE=512 bytes.if char_count>=GUI_PAGE_SIZE*4 then it should go through the if coditon. 
         */
        else if ((bs->char_count >= GUI_PAGE_SIZE * 4) && bs->check_flag == 3)
        {
            b->page_details[PAGE_THREE].shared_no_of_bytes = 0;
            b->page_details[PAGE_THREE].page_id = b->start_id + 3;
            b->page_details[PAGE_THREE].page_height =
                bs->total_page_height - b->page_details[PAGE_TWO].page_height -
                b->page_details[PAGE_ONE].page_height - b->page_details[PAGE_ZERO].page_height;
            bs->check_flag = 4;
        }
    }
}
#endif /* __UI_PAGING_IN_MULTILINE_EDITOR__ */ 

#ifdef __MMI_BIDI_ALG__
/*****************************************************************************
 * FUNCTION
 *  gui_translate_multi_line_bidi_text
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
 extern void bidi_main_ext(
                U8 *logicalStr,
                U16 logicalStrLen,
                U16 logicalCurPos,
                U8 *visualStr,
                U16 *visualStrLen,
                U16 *visualCurPos,
                U16 *pLToV,
                U16 *pVToL,
                pBOOL fSwap,
                U8 inputMode,
                U8 fUseOverride,
                BIDI_PARAGRAPH_TYPES paratype);
void gui_translate_multi_line_bidi_text(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 num_char, iCount;
    pBOOL line_arabic_char_flag = MMI_FALSE;
    UI_character_type dummy_c = 0;
    UI_buffer_type text_p;
    U8 char_type;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (bs->arabic_char_flag)
    {
        num_char = g_editor_line.line_char_count;

        MMI_ASSERT(num_char < MAX_NUM_OF_CHAR_FOR_EACH_LINE);

        if (num_char == 0)
        {
            if (g_editor_line.cursor_line_flag)
                bs->current_cursor_p = g_editor_line.line_start_p;
            return;
        }

        /* adjust the cursor position */
        if (g_editor_line.cursor_line_flag)
            bs->logical_cur_pos = (b->cursor_p - g_editor_line.line_start_p) / ENCODING_LENGTH;
        else
            bs->logical_cur_pos = 0xFFFF;

        for (iCount = 0; iCount < num_char; iCount++)
        {
            bidi_get_char_type((U8*) (g_editor_line.line_start_p + iCount * ENCODING_LENGTH), (U8*) & char_type);
            if ((char_type == AL) || (char_type == AN) || (char_type == BIDI_R)|| (char_type == WS))
            {
                line_arabic_char_flag = MMI_TRUE;
                break;
            }

#ifdef __MMI_MESSAGES_CHAT__
            if(b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_CHAT_ICON_DISPLAY)
            {
                text_p = (UI_buffer_type)(b->text + iCount * ENCODING_LENGTH);
                UI_STRING_GET_NEXT_CHARACTER(text_p, dummy_c);

                if (UI_TEST_GRP_SEP_CHARACTER(dummy_c)
                    ||UI_TEST_FILE_SEP_CHARACTER(dummy_c)
                    ||UI_TEST_SENDER_TRUNCATE_SEP_CHARACTER(dummy_c)
                    ||UI_TEST_RECEIVER_TRUNCATE_SEP_CHARACTER(dummy_c))
                {
                    line_arabic_char_flag = MMI_TRUE;
                    break;
                }
            }
#endif /* __MMI_MESSAGES_CHAT__ */
        }

        bidi_main_ext(
            g_editor_line.line_start_p,
            (U16) num_char,
            bs->logical_cur_pos,
            g_editor_line.visual_str,
            &bs->visual_str_len,
            &bs->visual_cur_pos,
            g_editor_line.logic_to_visual_map,
            g_editor_line.visual_to_logic_map,
            0,
            MMI_bidi_input_type,
            g_editor_line.override_flag,
            (bs->default_direction == BIDI_L) ? P_LTR : (line_arabic_char_flag ? P_RTL : P_LTR));

        bs->current_text_p = g_editor_line.visual_str;

        if (bs->visual_cur_pos != 0xFFFF)
        {
            bs->current_cursor_p = bs->current_text_p + (bs->visual_cur_pos) * ENCODING_LENGTH;
        }
        else
        {
            bs->current_cursor_p = NULL;
        }

        g_editor_line.bidi_done_flag = 1;
    }
}
#endif /* __MMI_BIDI_ALG__ */ 


/*****************************************************************************
 * FUNCTION
 *  gui_draw_multi_line_one_line
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_multi_line_one_line(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count, done = 0, character_width, character_height;
    U8 highlight = 0;
    color_t line_color;
    UI_buffer_type current_text_p = NULL;
    UI_character_type current_character, dummy_c;
#ifdef __UI_ENHANCED_HILITE_IN_MULTILINE_EDITOR__
    U16 hilite_idx = 0;
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!g_editor_line.bidi_done_flag)
    {
        count = g_editor_line.line_char_count;
    }
#ifdef __MMI_BIDI_ALG__
    else
    {
        count = bs->visual_str_len;
    }
#endif /* __MMI_BIDI_ALG__ */ 

    g_editor_line.cur_read = 0;

    if (!(b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_HIDE_TEXT_CONTENT))
    {
        /* draw all the highlight for current line */
        if (g_editor_line.highlight_flag)
            gui_draw_multi_line_current_line_highlight(b, bs);
    
        while (!done)
        {
            bs->xtx = bs->xx + bs->tx;

            if (g_editor_line.line_char_count == 0)
            {
                /* this is a blank line, try to draw the cursor and back */
                gui_handle_multi_line_cursor(b, bs);
                break;
            }

            /* 
             * get the character to draw. we need to do two things: 
             * 1. get the right *current_text_p 
             * 2. set the right g_editor_line.cur_read
             */
            bs->current_text_p = current_text_p = gui_get_multi_line_current_char_offset(bs, current_text_p);
            if (current_text_p == NULL)
            {
                /* to the line end */
                break;
            }

            character_width = g_editor_line.line_char[g_editor_line.cur_read].width;
            character_height = g_editor_line.line_char[g_editor_line.cur_read].height;

            UI_STRING_GET_NEXT_CHARACTER(current_text_p, current_character);
            UI_STRING_GET_PREVIOUS_CHARACTER(current_text_p, dummy_c);
            highlight = g_editor_line.line_char[g_editor_line.cur_read].highlight_flag;

            if (!(bs->flags & UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW))
            {
                /* draw the text content */
                if (highlight && highlight != EDITOR_HILITE_LIST_HIGHLIGHT)
                {
                    UI_MULTI_LINE_INPUT_BOX_SET_TEXT_COLOR(bs->selected_text_color);
                }
                else
                {
                    UI_MULTI_LINE_INPUT_BOX_SET_TEXT_COLOR(bs->rich_text.curr_color);
                }

#ifdef __UI_ENHANCED_HILITE_IN_MULTILINE_EDITOR__
                /* support to highlight the words in the hilite list */
                if (b->hilite_cb != NULL
                    && b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_USE_HILITE_FORMAT
                    && highlight == EDITOR_HILITE_LIST_HIGHLIGHT)
                {
                    if (gui_multi_line_input_box_is_pos_inside_hilite_ext(b, current_text_p, &hilite_idx))
                    {
                        gui_set_multi_line_hilite_format(b, bs, hilite_idx);
                    }
                }
#endif

            #ifdef __MMI_BIDI_ALG__
                if (g_editor_line.bidi_done_flag && g_editor_line.marker_flag)
                {
                    /*
 
  
                     */
                    gui_apply_multi_line_marker_for_bidi_text(b, bs);
                }
            #endif /* __MMI_BIDI_ALG__ */ 

                /* set the current character x, y coordinate */
                gui_set_multi_line_character_coordinate(b, bs);

                /* check whether to truncate the content */
                if (gui_truncate_multi_line_content(b, bs))
                {
                    break;
                }

                /* handle the current character */
                switch (g_editor_line.line_char[g_editor_line.cur_read].char_type)
                {
                    case SINGLE_CHAR:
                        MMI_ASSERT(current_text_p != NULL);
                        gui_draw_multi_line_single_character(b, bs, current_character);
                        break;

                    case MARKER_CHAR:
                        if (!g_editor_line.bidi_done_flag)
                            gui_apply_multi_line_marker(b, bs, current_character, 2);
                        break;

                #ifdef __MMI_MESSAGES_CHAT__
                    case CHAT_ICON_CHAR:
                        gui_draw_multi_line_chat_icon(bs, current_character);
                        break;
                #endif /* __MMI_MESSAGES_CHAT__ */ 
                    case ICON_CALLBACK_CLUSTER:
                        {
                            UI_buffer_type icon_p;

                            icon_p = gui_get_multi_line_original_text(g_editor_line.cur_read);
                            b->icon_callback(icon_p, MMI_TRUE, NULL, NULL, bs->xtx, bs->yty);
                        }
                        break;

                #ifdef __MMI_INDIC_ALG__
                    case INDIC_CLUSTER:
                        gui_draw_multi_line_indic_cluster(b, bs);
                        break;
                #endif /* __MMI_INDIC_ALG__ */ 

                    default:    /* draw the common cluster */
                        gui_draw_multi_line_common_cluster(b, bs);
                        break;

                }

                /* Draw the strikethrough */
                if (bs->rich_text.curr_strikethrough)
                {
                    if (!(b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_HIDE_TEXT_CONTENT))
                    {
                        UI_draw_horizontal_line(
                            bs->xtx,
                            bs->xtx + character_width - 1,
                            bs->yty + (g_editor_line.line_height >> 1),
                            gui_richtext_strikethrough_color);
                    }
                }

                /* Draw the  highlight list underline */
                if (b->hilite_cb != NULL && highlight == EDITOR_HILITE_LIST_HIGHLIGHT)
                    {
#ifdef __UI_ENHANCED_HILITE_IN_MULTILINE_EDITOR__
                    if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_USE_HILITE_FORMAT
                        && b->hilite_format_list[hilite_idx].format_flag & GUI_MULTI_LINE_INPUT_HILITE_UNDERLINE_COLOR)
                        line_color = b->hilite_format_list[hilite_idx].underline_color;
                    else
#endif    
                        line_color = gui_hilite_underline_color;

                    UI_draw_horizontal_line(
                        bs->xtx,
                        bs->xtx + character_width,
                        bs->yty + g_editor_line.line_height - 1,
                        line_color);
                }
            }

            /* handle the cursor */
            gui_handle_multi_line_cursor(b, bs);

            bs->tx += character_width + g_editor_line.line_char[g_editor_line.cur_read].text_gap;
        }
    }
}

#ifdef __MMI_MESSAGES_CHAT__


/*****************************************************************************
 * FUNCTION
 *  gui_draw_multi_line_chat_icon
 * DESCRIPTION
 *  
 * PARAMETERS
 *  bs                      [?]         
 *  current_character       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_multi_line_chat_icon(multi_line_input_box_show_struct *bs, UI_character_type current_character)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 *img_p = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (UI_TEST_GRP_SEP_CHARACTER(current_character))
    {
        img_p = GetImage(CHAT_LOCAL_IMG);
    }
    else if (UI_TEST_FILE_SEP_CHARACTER(current_character))
    {
        img_p = GetImage(CHAT_REMOTE_IMG);
    }
    else if (UI_TEST_SENDER_TRUNCATE_SEP_CHARACTER(current_character))
    {
        img_p = GetImage(CHAT_SENDER_TRUNCATE_IMG);
    }
    else if (UI_TEST_RECEIVER_TRUNCATE_SEP_CHARACTER(current_character))
    {
        img_p = GetImage(CHAT_RECEIVER_TRUNCATE_IMG);
    }
    else
    {
        MMI_ASSERT(0);
    }

    gui_show_transparent_image(
        bs->xtx,
        g_editor_line.line_height - g_editor_line.line_char[g_editor_line.cur_read].height + bs->yty,
        (PU8) img_p,
        0);
}
#endif /* __MMI_MESSAGES_CHAT__ */ 

#ifdef __MMI_BIDI_ALG__


/*****************************************************************************
 * FUNCTION
 
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_apply_multi_line_marker_for_bidi_text(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 i, j;
    UI_buffer_type p;
    UI_character_type current_character;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    /* restore the current font and color_t to the beginning of the line start */
    bs->rich_text.curr_font = bs->rich_text.line_begin_font;
    bs->rich_text.curr_border = bs->rich_text.line_begin_border;
    bs->rich_text.curr_strikethrough = bs->rich_text.line_begin_strikethrough;
    bs->rich_text.curr_color = bs->rich_text.line_begin_color;

    gui_set_font(&(bs->rich_text.curr_font));
    UI_MULTI_LINE_INPUT_BOX_SET_TEXT_COLOR(bs->rich_text.curr_color);

    for (i = 0; i <= g_editor_line.cur_read; i++)
    {
        if (g_editor_line.line_char[i].char_type == MARKER_CHAR)
        {
            p = g_editor_line.line_start_p;

            for (j = 0; j < i; j++)
                p += g_editor_line.line_char[j].char_count * ENCODING_LENGTH;

            UI_STRING_GET_NEXT_CHARACTER(p, current_character);

            gui_apply_multi_line_marker(b, bs, current_character, 2);
        }
    }

    return;

}
#endif /* __MMI_BIDI_ALG__ */ 


/*****************************************************************************
 * FUNCTION
 
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b                       [?]         
 *  bs                      [?]         
 *  current_character       [IN]        
 *  which_pass              [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void gui_apply_multi_line_marker(
        multi_line_input_box *b,
        multi_line_input_box_show_struct *bs,
        UI_character_type current_character,
        U32 which_pass)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    BOOL change_font_tmp = MMI_FALSE;
    BOOL change_color = MMI_FALSE, change_others = MMI_FALSE;
    gui_input_richtext_struct rich_text = bs->rich_text;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (current_character)
    {
        case GUI_INPUT_MARKER_RESET_ALL:
            /* Reset font format and color_t (no paragraph) */
            rich_text.curr_font = *b->text_font;
            rich_text.curr_border = 0;
            /* USAT */
            rich_text.curr_strikethrough = 0;
            rich_text.curr_text_bg_color = bs->rich_text.default_text_bg_color;
            rich_text.draw_text_bg_color = 0;
            rich_text.curr_color = bs->rich_text.default_color;
            change_font_tmp = MMI_TRUE;
            change_color = MMI_TRUE;
            break;

        case GUI_INPUT_MARKER_RESET_PARAGRAPH:
            if (which_pass == 1)
            {
                /* this format only affect at the first pass */
                rich_text.curr_alignment = bs->rich_text.default_alignment;
                rich_text.more_line_spacing = 0;
                rich_text.line_separator = 0;
            }
            break;

        case GUI_INPUT_MARKER_RESET_FORMAT:
            rich_text.curr_font = *b->text_font;
            rich_text.curr_border = 0;
            /* USAT */
            rich_text.curr_strikethrough = 0;
            change_font_tmp = MMI_TRUE;
            break;

        case GUI_INPUT_MARKER_RESET_COLOR:
            rich_text.curr_color = bs->rich_text.default_color;
            /* USAT */
            rich_text.curr_text_bg_color = bs->rich_text.default_text_bg_color;
            rich_text.draw_text_bg_color = 0;
            change_color = MMI_TRUE;
            break;

        default:
            if (current_character >= GUI_INPUT_MARKER_COLOR_BEGIN && current_character <= GUI_INPUT_MARKER_COLOR_END)
            {
                if (current_character - GUI_INPUT_MARKER_COLOR_BEGIN < MAX_GUI_INPUT_COLOR)
                {
                    rich_text.curr_color =
                        g_mmi_gui_input_format_color_table[current_character - GUI_INPUT_MARKER_COLOR_BEGIN];
                    change_color = MMI_TRUE;
                }
            }
            else if (current_character >= GUI_INPUT_MARKER_W3C_COLOR_BEGIN &&
                     current_character <= GUI_INPUT_MARKER_W3C_COLOR_END)
            {
                if (current_character - GUI_INPUT_MARKER_W3C_COLOR_BEGIN < MAX_GUI_INPUT_W3C_COLOR)
                {
                    rich_text.curr_color =
                        g_mmi_gui_input_format_w3c_color_table[current_character - GUI_INPUT_MARKER_W3C_COLOR_BEGIN];
                    change_color = MMI_TRUE;
                }
            }
            /* USAT */
            else if (current_character >= GUI_INPUT_MARKER_TEXT_BACKGROUND_COLOR_BEGIN &&
                     current_character <= GUI_INPUT_MARKER_TEXT_BACKGROUND_COLOR_END)
            {
                if (current_character - GUI_INPUT_MARKER_TEXT_BACKGROUND_COLOR_BEGIN < MAX_GUI_INPUT_W3C_TEXT_BG_COLOR)
                {
                    rich_text.curr_text_bg_color =
                        g_mmi_gui_input_format_w3c_text_background_color_table[current_character
                                                                               -
                                                                               GUI_INPUT_MARKER_TEXT_BACKGROUND_COLOR_BEGIN];
                    rich_text.draw_text_bg_color = 1;
                }
            }

            if (current_character >= GUI_INPUT_MARKER_BORDER_COLOR_BEGIN &&
                current_character <= GUI_INPUT_MARKER_BORDER_COLOR_END)
            {
                if (current_character - GUI_INPUT_MARKER_BORDER_COLOR_BEGIN < MAX_GUI_INPUT_COLOR)
                {
                    gui_set_text_border_color(g_mmi_gui_input_format_color_table
                                              [current_character - GUI_INPUT_MARKER_BORDER_COLOR_BEGIN]);
                }
            }
            else if (current_character >= GUI_INPUT_MARKER_W3C_BORDER_COLOR_BEGIN &&
                     current_character <= GUI_INPUT_MARKER_W3C_BORDER_COLOR_END)
            {
                if (current_character - GUI_INPUT_MARKER_W3C_BORDER_COLOR_BEGIN < MAX_GUI_INPUT_W3C_COLOR)
                {
                    gui_set_text_border_color(g_mmi_gui_input_format_w3c_color_table
                                              [current_character - GUI_INPUT_MARKER_W3C_BORDER_COLOR_BEGIN]);
                }
            }
            else if (GUI_INPUT_IS_FORMAT_MARKER(current_character))
            {
                if (GUI_INPUT_CHECK_FORMAT_MARKER(current_character, GUI_INPUT_MARKER_BOLD))
                {
                    rich_text.curr_font.bold = 1;
                    change_font_tmp = MMI_TRUE;
                }
                if (GUI_INPUT_CHECK_FORMAT_MARKER(current_character, GUI_INPUT_MARKER_ITALIC))
                {
                    rich_text.curr_font.italic = 1;
                    change_font_tmp = MMI_TRUE;
                }
                if (GUI_INPUT_CHECK_FORMAT_MARKER(current_character, GUI_INPUT_MARKER_UNDERLINE))
                {
                    rich_text.curr_font.underline = 1;
                    change_font_tmp = MMI_TRUE;
                }
                /* USAT */
                if (GUI_INPUT_CHECK_FORMAT_MARKER(current_character, GUI_INPUT_MARKER_STRIKETHROUGH))
                {
                    rich_text.curr_strikethrough = 1;
                    change_others = MMI_TRUE;
                }

                if (GUI_INPUT_CHECK_FORMAT_MARKER(current_character, GUI_INPUT_MARKER_BORDER))
                {
                    /* We do not increase font size for bordered font because text gap is already enlarged */
                    rich_text.curr_border = 1;
                    change_others = MMI_TRUE;
                }

                if (GUI_INPUT_CHECK_SIZE_MARKER(current_character, GUI_INPUT_MARKER_SMALL))
                {
                    rich_text.curr_font.size = SMALL_FONT;
                    change_font_tmp = MMI_TRUE;
                }
                else if (GUI_INPUT_CHECK_SIZE_MARKER(current_character, GUI_INPUT_MARKER_MEDIUM))
                {
                    rich_text.curr_font.size = MEDIUM_FONT;
                    change_font_tmp = MMI_TRUE;
                }
                else if (GUI_INPUT_CHECK_SIZE_MARKER(current_character, GUI_INPUT_MARKER_LARGE))
                {
                    rich_text.curr_font.size = LARGE_FONT;
                    change_font_tmp = MMI_TRUE;
                }
            }
            else if (GUI_INPUT_IS_PARAGRAPH_MARKER(current_character) && which_pass == 1)
            {
                /* Paragraph handled only in the first pass */
                if (GUI_INPUT_CHECK_ALIGN_MARKER(current_character, GUI_INPUT_MARKER_ALIGN_LEFT))
                {
                    rich_text.curr_alignment = GUI_INPUT_ALIGN_LEFT;
                }
                else if (GUI_INPUT_CHECK_ALIGN_MARKER(current_character, GUI_INPUT_MARKER_ALIGN_CENTER))
                {
                    rich_text.curr_alignment = GUI_INPUT_ALIGN_CENTER;
                }
                else if (GUI_INPUT_CHECK_ALIGN_MARKER(current_character, GUI_INPUT_MARKER_ALIGN_RIGHT))
                {
                    rich_text.curr_alignment = GUI_INPUT_ALIGN_RIGHT;
                }

                if (GUI_INPUT_CHECK_LINE_SPACING_MARKER(current_character, GUI_INPUT_MARKER_LINE_SPACING_1))
                {
                    rich_text.more_line_spacing = 1;
                }
                else if (GUI_INPUT_CHECK_LINE_SPACING_MARKER(current_character, GUI_INPUT_MARKER_LINE_SPACING_2))
                {
                    rich_text.more_line_spacing = 2;
                }
                else if (GUI_INPUT_CHECK_LINE_SPACING_MARKER(current_character, GUI_INPUT_MARKER_LINE_SPACING_3))
                {
                    rich_text.more_line_spacing = 3;
                }
                else if (GUI_INPUT_CHECK_LINE_SPACING_MARKER(current_character, GUI_INPUT_MARKER_LINE_SPACING_4))
                {
                    rich_text.more_line_spacing = 4;
                }
                else if (GUI_INPUT_CHECK_LINE_SPACING_MARKER(current_character, GUI_INPUT_MARKER_LINE_SPACING_5))
                {
                    rich_text.more_line_spacing = 5;
                }
                else if (GUI_INPUT_CHECK_LINE_SPACING_MARKER(current_character, GUI_INPUT_MARKER_LINE_SPACING_6))
                {
                    rich_text.more_line_spacing = 6;
                }
                else if (GUI_INPUT_CHECK_LINE_SPACING_MARKER(current_character, GUI_INPUT_MARKER_LINE_SPACING_7))
                {
                    rich_text.more_line_spacing = 7;
                }

                if (GUI_INPUT_CHECK_PARAGRAPH_MARKER(current_character, GUI_INPUT_MARKER_LINE_SEPARATOR))
                {
                    rich_text.line_separator = 1;
                }

                /* Reserve minimum line spacing for line separator */
                if (bs->rich_text.line_separator && bs->rich_text.more_line_spacing < 3)
                {
                    rich_text.more_line_spacing = 3;
                }
            }
            break;
    }

    if (change_font_tmp)
    {
        gui_set_font(&rich_text.curr_font);
    }

    if (change_color && which_pass == 2)
    {
        UI_MULTI_LINE_INPUT_BOX_SET_TEXT_COLOR(rich_text.curr_color);
    }

    if ( which_pass == 1
        && (change_font_tmp || change_color || change_others))
    {
         
        g_editor_line.marker_flag = 1;
    }

    bs->rich_text = rich_text;
}


/*****************************************************************************
 * FUNCTION
 *  gui_get_multi_line_current_char_offset
 * DESCRIPTION
 *  
 * PARAMETERS
 *  bs                  [?]         
 *  current_text_p      [IN]        
 * RETURNS
 *  
 *****************************************************************************/
UI_buffer_type gui_get_multi_line_current_char_offset(multi_line_input_box_show_struct *bs, UI_buffer_type current_text_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    int i;
    UI_buffer_type p = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!g_editor_line.bidi_done_flag)
    {
        if (current_text_p == NULL)
        {
            /* the first character */
            g_editor_line.cur_read = 0;
            return g_editor_line.line_start_p;
        }

        g_editor_line.cur_read++;

        if (g_editor_line.cur_read >= g_editor_line.line_unit_count)
        {
            /* to the current line end */
            return NULL;
        }

        p = current_text_p;
        for (i = g_editor_line.cur_read - 1; i < g_editor_line.cur_read; i++)
        {
            MMI_ASSERT(i < MAX_NUM_OF_CHAR_FOR_EACH_LINE);
            p += g_editor_line.line_char[i].char_count * ENCODING_LENGTH;
        }
    }
#ifdef __MMI_BIDI_ALG__
    else
    {
        if (current_text_p == NULL)
        {
            /* the first character */
            gui_set_g_editor_line_unit_by_bidi_text((UI_buffer_type)g_editor_line.visual_str);
            return g_editor_line.visual_str;
        }
        current_text_p += g_editor_line.line_char[g_editor_line.cur_read].char_count * ENCODING_LENGTH;

        if ((U32) current_text_p >= (U32) (g_editor_line.visual_str + bs->visual_str_len * ENCODING_LENGTH))
        {
            /* to the current line end */
            return NULL;
        }

        gui_set_g_editor_line_unit_by_bidi_text(current_text_p);
        p = current_text_p;
    }

#endif /* __MMI_BIDI_ALG__ */ 

    return p;
}


/*****************************************************************************
 * FUNCTION
 *  gui_get_original_text
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
UI_buffer_type gui_get_multi_line_original_text(U16 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;
    UI_buffer_type text_p = g_editor_line.line_start_p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < index; i++)
    {
        text_p += g_editor_line.line_char[i].char_count * ENCODING_LENGTH;
    }

    return text_p;
}

#ifdef __MMI_BIDI_ALG__
/*****************************************************************************
 * FUNCTION
 *  gui_set_g_editor_line_unit_by_bidi_text
 * DESCRIPTION
 *  
 * PARAMETERS
 *  visual_text_p       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_g_editor_line_unit_by_bidi_text(UI_buffer_type visual_text_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 visual_index, logic_index;
    U32 i, count = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(visual_text_p >= g_editor_line.visual_str);
    visual_index = (U32) (visual_text_p - g_editor_line.visual_str) / ENCODING_LENGTH;
    logic_index = g_editor_line.visual_to_logic_map[visual_index];

    for (i = 0; i < g_editor_line.line_unit_count; i++)
    {
        count += g_editor_line.line_char[i].char_count;

        if (count > logic_index 
            &&g_editor_line.line_char[i].char_count != 0)
        {
            /* have found the current text unit */
            g_editor_line.cur_read = i;
            return;
        }
    }

    MMI_ASSERT(0);
}
#endif /* __MMI_BIDI_ALG__ */ 


/*****************************************************************************
 * FUNCTION
 *  gui_draw_multi_line_highlight_background
 * DESCRIPTION
 *  
 * PARAMETERS
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_multi_line_current_line_highlight(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 xtx, xx, tx, done = 0, gap;
    S32 char_width, char_height;
    U8 highlight;
    UI_buffer_type current_text_p = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (bs->flags & UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW)
        return;
    
    xx = bs->xx;
    tx = bs->tx;
    
    if(bs->flags & UI_MULTI_LINE_INPUT_BOX_DRAW_UNDERLINE)
        gap = 2;
    else
        gap = 1;

    if (g_editor_line.highlight_flag)
    {
        while (!done)
        {
            xtx = xx + tx;

            current_text_p = gui_get_multi_line_current_char_offset(bs, current_text_p);
            if (current_text_p == NULL)
            {
                /* to the line end */
                break;
            }

            char_width = g_editor_line.line_char[g_editor_line.cur_read].width;
            char_height = g_editor_line.line_height;
            highlight = g_editor_line.line_char[g_editor_line.cur_read].highlight_flag;

            if (highlight)
            {
                if (highlight != EDITOR_HILITE_LIST_HIGHLIGHT)
                    gui_fill_rectangle(xtx, bs->yty, xtx + char_width, bs->yty + char_height - gap, bs->selector_color);
#ifdef  __UI_ENHANCED_HILITE_IN_MULTILINE_EDITOR__
                else
                {
                    U16 hilite_idx;

                    hilite_idx = g_editor_line.line_char[g_editor_line.cur_read].hilite_idx;

                    if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_USE_HILITE_FORMAT
                        &&b->hilite_format_list[hilite_idx].format_flag & GUI_MULTI_LINE_INPUT_HILITE_BACKGROUND_COLOR)
                    gui_fill_rectangle(xtx, bs->yty, xtx + char_width, bs->yty + char_height - gap, b->hilite_format_list[hilite_idx].filler_color);
                }
#endif
            }

            tx += char_width + g_editor_line.line_char[g_editor_line.cur_read].text_gap;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_set_multi_line_character_coordinate
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_multi_line_character_coordinate(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 current_line_height = g_editor_line.line_height;
    U16 character_height = g_editor_line.line_char[g_editor_line.cur_read].height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(bs->flags & UI_MULTI_LINE_INPUT_BOX_DRAW_UNDERLINE)
    {
        UI_MULTI_LINE_INPUT_BOX_MOVE_TEXT_CURSOR(bs->xtx, bs->yty + current_line_height - character_height - 2);
    }
    else
    {
        UI_MULTI_LINE_INPUT_BOX_MOVE_TEXT_CURSOR(bs->xtx, bs->yty + current_line_height - character_height - 1);
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_check_multi_line_character_highlight
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  
 *****************************************************************************/
U32 gui_check_multi_line_character_highlight(multi_line_input_box *b, multi_line_input_box_show_struct *bs, U16 count)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 highlight = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* Check for hilite list, which maybe overrided by common highlight */
    if (b->hilite_cb != NULL)
    {
        if (gui_multi_line_input_box_is_pos_inside_hilite_ext(b, bs->current_text_p, &g_editor_line.line_char[count].hilite_idx))
        {
            highlight = EDITOR_HILITE_LIST_HIGHLIGHT;
        }
    }
    
    /* Check for common highlight */
    if ((bs->flags & UI_MULTI_LINE_INPUT_BOX_WORD_HIGHLIGHT) && b->highlight_start_position != NULL)
    {
        if (bs->current_text_p == b->highlight_start_position
            || (!bs->word_highlight 
            && bs->current_text_p < b->highlight_start_position
            && (bs->current_text_p + g_editor_line.line_char[count].char_count * ENCODING_LENGTH) > b->highlight_start_position))
        {
            /* barcode */
            int temp_y = bs->ty;
            
            bs->word_highlight = 1;
            b->curr_hilite_text_offset_y = -temp_y;

            if (b->hilite_cb != NULL)
            {
                if (b->hilite_str_number == 0)
                {
                    bs->word_highlight = 0;
                }
            }
        }
        
        if (bs->current_text_p == b->highlight_end_position
            || (bs->word_highlight && bs->current_text_p > b->highlight_end_position))
        {
            bs->word_highlight = 0;
            bs->highlight_end_y = bs->yy + bs->ty + g_editor_line.line_height;
        }

        if (bs->word_highlight)
        {
            highlight = EDITOR_COMMON_HIGHLIGHT;
            bs->highlight_end_y = bs->yy + bs->ty + g_editor_line.line_height;
        }

    }

    /* Check for multitap highlight */
    if (bs->multitap_flag)
    {
        if ((bs->current_text_p <= bs->previous_cursor_p)
            && (bs->previous_cursor_p < bs->current_text_p + g_editor_line.line_char[count].char_count * ENCODING_LENGTH))
            highlight = EDITOR_MULTITAP_HIGHLIGHT;
    }

    /* Check for overwrite highlight */
    if (bs->overwrite_flag && !bs->multitap_flag)
    {
        if (bs->current_text_p == bs->current_cursor_p)
        {
            highlight = EDITOR_OVERWRITE_HIGHLIGHT;
        }
    }

    return highlight;
}


/*****************************************************************************
 * FUNCTION
 *  gui_truncate_multi_line_content
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  
 *****************************************************************************/
U8 gui_truncate_multi_line_content(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 current_line_height = g_editor_line.line_height;
    U16 character_width = g_editor_line.line_char[g_editor_line.cur_read].width;
    U16 character_height = g_editor_line.line_char[g_editor_line.cur_read].height;
    S32 y;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_TRUNCATE_CONTENT) &&
        (bs->flags & UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR))
    {
        if (b->text_height > b->edit_height)
        {
            if (bs->yty + current_line_height * 2 > bs->y2
                || bs->line_counter == b->n_lines - 2)
            {
                UI_character_type next_char;
                S32 width, height;

                {
                    UI_buffer_type tmp = bs->current_text_p;

                    UI_STRING_GET_NEXT_CHARACTER(tmp, next_char);
                }

                gui_measure_character((UI_character_type) '.', &width, &height);
                y = UI_text_y + character_height - height;

                if (g_editor_line.line_char_count == 1 
                    || UI_text_x + character_width + 4 * width >= b->x + b->edit_width
                    || g_editor_line.cur_read == g_editor_line.line_unit_count - 1)
                {
                    gui_move_text_cursor(UI_text_x, y);
                    FONT_CANCEL_WIDTH(1);
                    if (!(b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_HIDE_TEXT_CONTENT))
                    {
                        gui_print_character((UI_character_type) '.');
                    }
                    gui_move_text_cursor(UI_text_x + 3, y);
                    if (!(b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_HIDE_TEXT_CONTENT))
                    {
                        gui_print_character((UI_character_type) '.');
                    }
                    gui_move_text_cursor(UI_text_x + 3, y);
                    if (!(b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_HIDE_TEXT_CONTENT))
                    {
                        gui_print_character((UI_character_type) '.');
                    }
                    FONT_CANCEL_WIDTH(0);
                    bs->end_line = 1;
                    return 1;
                }

            }
        }
    }

    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  gui_find_multi_line_cursor_position
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_find_multi_line_cursor_position(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x = b->cursor_fixed_x;
    UI_buffer_type current_text_p = bs->current_text_p, cursor_p;
#ifdef __MMI_BIDI_ALG__
    UI_buffer_type next_text_p;
#endif
    S32 d = 0;
    S32 found = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (x == -1)
        x = b->cursor_x;

    if ((b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_PREVIOUSE_LINE)
        && g_editor_line.line_start_p == b->line_before_cursor_line_p)
    {
        if (b->cursor_fixed_x == -1)
            b->cursor_fixed_x = b->cursor_x;
        d = 1;
    }
    else if ((b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_NEXT_LINE)
             && g_editor_line.line_start_p == b->line_after_cursor_line_p)
    {
        if (b->cursor_fixed_x == -1)
            b->cursor_fixed_x = b->cursor_x;
        d = 2;
    }
    else if(bs->move_to_x != -1 || bs->move_to_y != -1)
    {
        /* find cursor by move_to_x and move_to_y */
        x = bs->move_to_x;
        if (bs->move_to_y >= bs->ty + b->y + b->text_offset_y
            && bs->move_to_y < bs->ty + b->y + g_editor_line.line_height + b->text_offset_y)
            d = 3;

        if (bs->end_line 
            && (bs->move_to_y >= bs->ty + b->y + g_editor_line.line_height + b->text_offset_y))
        {
            d = 3;
            x = b->x + b->width;
        }
    }

    if (d)
    {
        if (bs->xtx + g_editor_line.line_char[g_editor_line.cur_read].width >= x)
        {
            /* ok, have found it */
            if (bs->default_direction == BIDI_R 
                && bs->xtx >= x
                && bs->end_line)
            {
                
#ifdef __MMI_BIDI_ALG__
                if ((g_editor_line.bidi_done_flag
                    && current_text_p == g_editor_line.visual_str)
                    || (!g_editor_line.bidi_done_flag
                    && current_text_p == g_editor_line.line_start_p))
#else
                if (current_text_p == g_editor_line.line_start_p)
#endif
                {
                    /* 
                     * the x offset is less than the first display character,
                     * we need to set the cursor to the end of this line.
                     */

                    cursor_p = g_editor_line.line_start_p + g_editor_line.line_char_count * ENCODING_LENGTH;
                }
                else
                    cursor_p = gui_get_multi_line_original_text(g_editor_line.cur_read);
                }
                else
                cursor_p = gui_get_multi_line_original_text(g_editor_line.cur_read);

            if (d == 3)
            {
                if (gui_check_multi_line_cursor_validation_for_wcss(b, bs, cursor_p))
                    b->cursor_p = cursor_p;
            }
            else
                b->cursor_p = cursor_p;
            
            bs->find_new_cursor_flag = FOUND_CURSOR;
            found = 1;
        }
        else
        {
#ifdef __MMI_BIDI_ALG__
            if (g_editor_line.bidi_done_flag)
            {
                next_text_p = current_text_p + g_editor_line.line_char[g_editor_line.cur_read].char_count * ENCODING_LENGTH;
                if (next_text_p - g_editor_line.visual_str >= g_editor_line.line_char_count * ENCODING_LENGTH)
                {
                    /*
                     * the current character is the last one of this line, 
                     * * but we still can't find the cursor_p.
                     */
                    if (bs->end_line)
                    {
                        /* 
                         * This is the last line of the whole text, we should set the cursor
                         * at the front of the NULL, not the last unit.
                         */
                        cursor_p = g_editor_line.line_start_p + g_editor_line.line_char_count * ENCODING_LENGTH;
                    }
                    else
                    {
                        cursor_p = gui_get_multi_line_original_text(g_editor_line.cur_read);
                    }

                    if (d == 3)
                    {
                        if (gui_check_multi_line_cursor_validation_for_wcss(b, bs, cursor_p))
                            b->cursor_p = cursor_p;
                    }
                    else
                        b->cursor_p = cursor_p;

                    bs->find_new_cursor_flag = FOUND_CURSOR;
                    found = 1;
                }
            }
            else
#endif
            {
                if (g_editor_line.cur_read + 1 >= g_editor_line.line_unit_count)
                {
                    /*
                     * the current character is the last one of this line, 
                     * * but we still can't find the cursor_p. 
                     */
                    if (bs->end_line)
                    {
                        /* 
                         * This is the last line of the whole text, we should set the cursor
                         * at the front of the NULL, not the last unit.
                         */
                        cursor_p = g_editor_line.line_start_p + g_editor_line.line_char_count * ENCODING_LENGTH;
                    }
                    else
                    {
                        cursor_p = gui_get_multi_line_original_text(g_editor_line.cur_read);
                    }

                    if (d == 3)
                    {
                        if (gui_check_multi_line_cursor_validation_for_wcss(b, bs, cursor_p))
                            b->cursor_p = cursor_p;
                    }
                    else
                        b->cursor_p = cursor_p;

                    bs->find_new_cursor_flag = FOUND_CURSOR;
                    found = 1;
                }
            }
        }

        if (found == 1)
        {
        #if defined(__UI_PAGING_IN_MULTILINE_EDITOR__)
            if (d == 3 && b->locate_cursor_callback != NULL)
            {
                b->locate_cursor_callback(
                    b->text,
                    b->cursor_p,
                    (S32) (b->cursor_p - b->text - b->previous_shared_bytes + (b->start_id) * GUI_PAGE_SIZE * ENCODING_LENGTH),
                    b->text_length);
            }
        #endif /* defined(__UI_PAGING_IN_MULTILINE_EDITOR__) */ 
        }
    }

}


/*****************************************************************************
 * FUNCTION
 *  gui_handle_multi_line_cursor
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_handle_multi_line_cursor(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x, y, height;
    U8 show_cursor = 0;
    S32 cx2 = bs->x2, cy2 = bs->y2 - 2;
    S32 line_x, line_x2, line_y;
    UI_character_type current_character = 0;
    UI_buffer_type current_text_p = bs->current_text_p;
    UI_buffer_type next_text_p = bs->current_text_p + g_editor_line.line_char[g_editor_line.cur_read].char_count * ENCODING_LENGTH;
    U8 gap = g_editor_line.line_char[g_editor_line.cur_read].text_gap;
    U16 character_width = g_editor_line.line_char[g_editor_line.cur_read].width;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (bs->find_new_cursor_flag == FINDING_CURSOR)
    {
        gui_find_multi_line_cursor_position(b, bs);
        return;
    }

    if (g_editor_line.cursor_line_flag)
    {
        if (current_text_p == bs->current_cursor_p)
        {
            show_cursor = 1;
        }

        if (bs->current_cursor_p > current_text_p
            && bs->current_cursor_p < next_text_p)
        {
            show_cursor = 2;
        }

        if (bs->current_cursor_p == next_text_p
            && *(next_text_p) == 0 && *(next_text_p+1) == 0)
        {
        /* 
         * the current character is the last one of this line, and
         * the cursor is pointed to the end NULL   
         */
            show_cursor = 2;
        }

        if (!(bs->flags & UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW)
            && !(bs->flags & UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW))
        {
            if (show_cursor)
            {
                x = bs->xtx;
                y = bs->yty;
                height = g_editor_line.line_height;

                if(bs->flags & UI_MULTI_LINE_INPUT_BOX_DRAW_UNDERLINE)
                    height -= 1;

                UI_STRING_GET_NEXT_CHARACTER(current_text_p, current_character);

                if (g_mmi_wgui_halfline_marquee_scroll_enable)
                    y = bs->y1;

#if defined(__MMI_BIDI_ALG__) && defined(__MMI_ARSHAPING_ENGINE__)
                if (IS_ARABIC_CHARACTER(current_character))
                    x--;
#endif
                if (show_cursor == 2)
                    x = bs->xtx + character_width + gap;

                /* show cursor */
                gui_multi_line_input_box_show_cursor(b, x, y, height, bs->x1, bs->y1, cx2, cy2);
            }
        }

        if (show_cursor)
        {
            /* update cursor information */
            b->cursor_x = (show_cursor == 1) ? bs->xtx : bs->xtx + character_width + gap;

            if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_UNDERLINE_CURSOR_LINE)
            {
                line_x = b->x + b->text_x;
                line_x2 = line_x + b->width - 1;
                line_y = bs->yty + g_editor_line.line_height - 1;
                if (line_y < b->y + b->height)
                {
                    gdi_draw_line(
                        line_x,
                        line_y,
                        line_x2,
                        line_y,
                        gdi_act_color_from_rgb(255, b->underline_color.r, b->underline_color.g, b->underline_color.b));
                }

            #if defined(__UI_PAGING_IN_MULTILINE_EDITOR__)
                if (b->underline_callback != NULL)
                    b->underline_callback(
                        b->text,
                        (S32) (b->cursor_line_p - b->text - b->previous_shared_bytes + (b->start_id) * GUI_PAGE_SIZE * ENCODING_LENGTH),
                        g_editor_line.line_char_count);
            #endif /* defined(__UI_PAGING_IN_MULTILINE_EDITOR__) */ 
            }
        }
    }

}


/*****************************************************************************
 * FUNCTION
 *  gui_draw_multi_line_single_character
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b                       [?]         
 *  bs                      [?]         
 *  current_character       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_multi_line_single_character(
        multi_line_input_box *b,
        multi_line_input_box_show_struct *bs,
        UI_character_type current_character)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 current_line_height = g_editor_line.line_height;
    U16 character_width = g_editor_line.line_char[g_editor_line.cur_read].width;

#if(MULTILINE_INPUTBOX_DISPLAY_SPECIAL_CHARACTERS)
    U16 character_height = g_editor_line.line_char[g_editor_line.cur_read].height;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Special character */
#if(MULTILINE_INPUTBOX_DISPLAY_SPECIAL_CHARACTERS)
    if (UI_TEST_CR_CHARACTER(current_character))
    {
        gdi_image_draw_id(bs->xtx, current_line_height - character_height + bs->yty, WGUI_CR_CHARACTER_IMAGE_ID);
        return;
    }
    else if (UI_TEST_LF_CHARACTER(current_character))
    {
        gdi_image_draw_id(bs->xtx, current_line_height - character_height + bs->yty, WGUI_LF_CHARACTER_IMAGE_ID);
        return;
    }
    else if (UI_TEST_ESC_CHARACTER(current_character))
    {
        gdi_image_draw_id(bs->xtx, current_line_height - character_height + bs->yty, WGUI_ESC_CHARACTER_IMAGE_ID);
        return;

    }
#endif /* (MULTILINE_INPUTBOX_DISPLAY_SPECIAL_CHARACTERS) */ 

    if (!(UI_STRING_END_OF_STRING_CHARACTER(current_character) ||
          UI_TEST_LF_CHARACTER(current_character) ||
          UI_TEST_CR_CHARACTER(current_character) || UI_TEST_ESC_CHARACTER(current_character)))
    {
        /* USAT */
        if ((bs->rich_text).draw_text_bg_color)
        {
            UI_fill_rectangle(
                bs->xtx,
                bs->yty - 1,
                bs->xtx + character_width,
                bs->yty + current_line_height - 1,
                bs->rich_text.curr_text_bg_color);
        }

        if (bs->flags & UI_MULTI_LINE_INPUT_BOX_MASK_CHARACTERS)
        {
        #if defined(__MMI_FULL_SCREEN_EDITOR__) || defined(__MMI_TOUCH_SCREEN__)
            if ((bs->flags & UI_MULTI_LINE_INPUT_BOX_STATE_MULTITAP) 
                && g_editor_line.line_char[g_editor_line.cur_read].highlight_flag == EDITOR_MULTITAP_HIGHLIGHT)
            {

                FONT_CANCEL_WIDTH(1);
                if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_USE_BORDER_FONT)
                {
                    gui_set_text_border_color(b->border_color);
                    gui_print_bordered_character(current_character);
                }
                else
                    gui_print_character(current_character);
                FONT_CANCEL_WIDTH(0);

            }
            else
        #endif /* defined(__MMI_FULL_SCREEN_EDITOR__) || defined(__MMI_TOUCH_SCREEN__) */ 
            {
                FONT_CANCEL_WIDTH(1);
                if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_USE_BORDER_FONT)
                {
                    gui_set_text_border_color(b->border_color);
                    gui_print_bordered_character(b->mask_character);
                }
                else
                    gui_print_character(b->mask_character);
                FONT_CANCEL_WIDTH(0);
            }

            return;
        }

        FONT_CANCEL_WIDTH(1);
        if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_USE_BORDER_FONT)
        {
            gui_set_text_border_color(b->border_color);
            gui_print_bordered_character(current_character);
        }
        else
            gui_print_character(current_character);
        FONT_CANCEL_WIDTH(0);
    }

    return;
}


/*****************************************************************************
 * FUNCTION
 *  gui_draw_multi_line_common_cluster
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_multi_line_common_cluster(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 disp_cluster[MAX_CLUSTER_LEN];
    UI_buffer_type current_text_p = gui_get_multi_line_original_text(g_editor_line.cur_read);
    UI_character_type current_character;
    U16 character_width = g_editor_line.line_char[g_editor_line.cur_read].width;
    U16 character_height = g_editor_line.line_char[g_editor_line.cur_read].height;
    U16 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < g_editor_line.line_char[g_editor_line.cur_read].char_count; i++)
    {
        UI_STRING_GET_NEXT_CHARACTER(current_text_p, current_character);
        disp_cluster[i] = current_character;
    }
    disp_cluster[i] = 0;

    UI_text_height = character_height;
    gui_set_text_color(UI_text_color);

    FONT_CANCEL_WIDTH(1);

    if (character_width != 0)
    {
        if (bs->rich_text.curr_border)
        {
            ShowStringBordered(UI_text_x, UI_text_y, *UI_font, 0, (U8*) (disp_cluster), UI_text_height);
        }
        else
        {
            ShowString(UI_text_x, UI_text_y, *UI_font, 0, (U8*) (disp_cluster), UI_text_height);
        }
    }
    UI_text_height = 0;
    FONT_CANCEL_WIDTH(0);

    return;
}


/*****************************************************************************
 * FUNCTION
 *  gui_end_multi_line_text_display
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_end_multi_line_text_display(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if defined(__UI_PAGING_IN_MULTILINE_EDITOR__)
    U32 height_previous_page = 0;
    U32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_VIEW_PAGING_MODE)
    {
        if (bs->check_flag <= PAGE_THREE)
        {
            /* the all text is less than four buffer, should set the last page information */
            for (i = 0; i < bs->check_flag; i++)
                height_previous_page += b->page_details[i].page_height;

            b->page_details[bs->check_flag].shared_no_of_bytes = 0;
            b->page_details[bs->check_flag].page_id = b->start_id + bs->check_flag;
            b->page_details[bs->check_flag].page_height = bs->total_page_height - height_previous_page;
        }
    }
#endif /* defined(__UI_PAGING_IN_MULTILINE_EDITOR__) */ 

    /* update the line count */
    b->n_lines = bs->line_counter;

    if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_FIXED_TEXT_AREA)
    {
        bs->x1 = bs->backup_x1;
        bs->x2 = bs->backup_x2;
    }

    /* Set global font to default because rich_text.curr_font is local variable released dynamically. */
    gui_set_font(b->text_font);
}


/*****************************************************************************
 * FUNCTION
 *  gui_set_multi_line_scroll_bar
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_multi_line_scroll_bar(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (b->text == NULL)
    {
        gui_set_vertical_scrollbar_scale(&b->vbar, b->edit_height);
        gui_set_vertical_scrollbar_range(&b->vbar, 0);
        gui_set_vertical_scrollbar_value(&b->vbar, 0);
        return;
    }

#ifdef __UI_PAGING_IN_MULTILINE_EDITOR__
    if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_VIEW_PAGING_MODE)
    {
        if (b->jump_offset_from_app != 0 && b->search_flag_is_on)
        {
            b->text_offset_y += 40;
            if (b->text_offset_y > 0)
                b->text_offset_y = 0;

            if ((bs->flags & UI_MULTI_LINE_INPUT_BOX_WORD_HIGHLIGHT) 
                && b->highlight_start_position != NULL
                && b->hilite_str_number == 0)
            {
                if (bs->highlight_end_y >= b->y + b->height)
                    b->text_offset_y = b->curr_hilite_text_offset_y;
            }
        }

        if (-b->text_offset_y == b->text_height && b->text_height > b->edit_height_displayed_lines)
        {
            b->text_offset_y += b->edit_height_displayed_lines;
        }
        /* end steve ebook */
        b->page_offset = 0;
        b->jump_offset_from_app = 0;

        if (b->size_of_total_data < GUI_PAGE_SIZE)
        {
            gui_set_vertical_scrollbar_scale(&b->vbar, b->edit_height);
        }
        else
        {
            gui_set_vertical_scrollbar_scale(&b->vbar, 1);
        }

        bs->rich_text.curr_font.bold = bs->rich_text.curr_font.italic = 0;
    }
    else
#endif /* __UI_PAGING_IN_MULTILINE_EDITOR__ */ 
    {
        gui_set_vertical_scrollbar_scale(&b->vbar, b->edit_height);

        /* if content is empty, don't show the scrollbar */
        if (b->text_length <= 1 * ENCODING_LENGTH && b->header_height <= 0 && b->footer_height <= 0)
            gui_set_vertical_scrollbar_range(&b->vbar, 0);
        else
            gui_set_vertical_scrollbar_range(&b->vbar, bs->ty);

        gui_set_vertical_scrollbar_value(&b->vbar, -b->text_offset_y);
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_show_multi_line_scroll_bar
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_show_multi_line_scroll_bar(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!(bs->flags & UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW))    /* if not disable draw then do .. */
    {
        gui_pop_clip();

        if (!(bs->flags & UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR) && (bs->edit_width > 0))
        {
            if (bs->flags & UI_MULTI_LINE_INPUT_BOX_AUTO_DISABLE_SCROLLBAR)
            {
                if (b->vbar.scale != 0
                    && (b->vbar.scale < b->vbar.range))
                {
                    if (r2lMMIFlag)
                    {
                        /* move vertical scrollbar to the left side */
                        gui_move_vertical_scrollbar(&b->vbar, b->x, b->vbar.y);
                    }

                    gui_show_vertical_scrollbar(&b->vbar);
                }
            }
            else
            {
                if (r2lMMIFlag)
                {
                    /* move vertical scrollbar to the left side */
                    gui_move_vertical_scrollbar(&b->vbar, b->x, b->vbar.y);
                }

                gui_show_vertical_scrollbar(&b->vbar);
            }
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_update_multi_line_extern_module_infomation
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_update_multi_line_extern_module_infomation(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
#ifdef __MMI_UI_DALMATIAN_EDITOR__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 image_width, image_height, x, y;
    PU8 img_p;
#endif /* __MMI_UI_DALMATIAN_EDITOR__ */ 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_SMART_MESSAGE_MO__) && !defined(__MMI_MESSAGES_EMS__)
    if (GetMessagesCurrScrnID() == SCR_ID_MSG_WRITE)
    {
        g_nsm_msg_context.UCS2_count = b->UCS2_count;   /* To fix outbox edit bug */
        g_nsm_msg_context.textlength = b->text_length;
    }

    if ((GetExitScrnID() == SCR_ID_MSG_OUTBOX_MSG) && (mmi_nsm_get_msg_type() == PICTURE_MESSAGE))
    {
        g_nsm_msg_context.UCS2_count = b->UCS2_count;   /* To fix outbox SEND bug */
    }
#endif /* defined(__MMI_SMART_MESSAGE_MO__) && !defined(__MMI_MESSAGES_EMS__) */ 

#ifdef __MMI_UI_DALMATIAN_EDITOR__
    if (!(b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_DISABLE_DALMATIAN_EDITOR))
    {
        if (!(bs->flags & UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW)
            && !(b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_HIDE_TEXT_CONTENT))
        {
            S32 draw_dal_image = 1;

            if (!(bs->flags & UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW) &&
                b->header_callback && (b->header_height > 0) && (b->text_offset_y + b->header_height >= 0))
            {
                draw_dal_image = 0; /* Not to draw image when image insert in editor. */
            }

            /* Draw Dalmatian editor image */
            if (b->height >= 100)   /* To draw image according to screen size. */
            {
                gui_measure_image(get_image(IMG_EDITOR_DALMATIAN), &image_width, &image_height);
            }
            else
            {
                gui_measure_image(get_image(IMG_EDITOR_DALMATIAN_SMALL), &image_width, &image_height);
            }

            /* The image will be drawn if the editor height is 25% more than image height */
            if (image_height > (b->height - (image_height >> 2)))
            {
                draw_dal_image = 0;
            }
#if defined(__MMI_MAINLCD_220X176__)
		if (b->height < 83)
            {
                draw_dal_image = 0;
            }
#endif
            if (draw_dal_image && b->text_length <= 2 && (!(bs->flags & UI_MULTI_LINE_INPUT_BOX_VIEW_MODE)) &&
                (0 == b->footer_height))
            {
                if (b->height >= 100)
                {
                    img_p = get_image(IMG_EDITOR_DALMATIAN);
                }
                else
                {
                    img_p = get_image(IMG_EDITOR_DALMATIAN_SMALL);
                }

                if (!r2lMMIFlag)
                {
                    x = b->x + b->width - (b->vbar.width + image_width + 2);
                }
                else
                {
                    x = b->x + (b->vbar.width + 2);
                }

                y = b->y + b->height - (image_height + 4);

                gui_show_image((U16) x, (U16) y, img_p);
            }
        }
    }
#endif /* __MMI_UI_DALMATIAN_EDITOR__ */ 

#if defined(__MMI_SMART_MESSAGE_MT__)
    /* Update ucs2 flag when entering outbox msg */
    if ((GetMessagesCurrScrnID() == SCR_ID_NSM_EDITOR) ||
        ((GetExitScrnID() == SCR_ID_MSG_OUTBOX_MSG) && (mmi_nsm_get_msg_type() == PICTURE_MESSAGE)))
    {
        picmsg_text_struct.ucs2_count = b->UCS2_count;
    }
#endif /* defined(__MMI_SMART_MESSAGE_MT__) */ 
}

#ifdef __MMI_INDIC_ALG__


/*****************************************************************************
 * FUNCTION
 *  gui_draw_multi_line_indic_cluster
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_multi_line_indic_cluster(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 disp_cluster[MAX_EDITOR_DISP_LEN];
    UI_buffer_type current_text_p, next_text_p;
    U16 character_height = g_editor_line.line_char[g_editor_line.cur_read].height;
    S32 disp_multi_clust_len = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    current_text_p = bs->current_text_p;
    next_text_p = bs->current_text_p + g_editor_line.line_char[g_editor_line.cur_read].char_count * ENCODING_LENGTH;

    /* 
     * now we have to call the function ire_get_next_cluster_p first to display the hindi correctly
     */
    ire_get_next_cluster_p(current_text_p, next_text_p);

    ire_get_current_cluster(current_text_p, next_text_p, disp_cluster);

    disp_multi_clust_len = mmi_ucs2strlen((PS8) disp_cluster);
    MMI_ASSERT(!(disp_multi_clust_len > MAX_EDITOR_DISP_LEN));

    UI_text_height = character_height;

    ire_disable_indic_rules_parsing();
    ire_indic_padding_value(0);
    gui_set_text_color(UI_text_color);

    FONT_CANCEL_WIDTH(1);

    if (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_USE_BORDER_FONT)
    {
        gui_set_text_border_color(b->border_color);
        ShowStringBordered(UI_text_x, UI_text_y, *UI_font, 0, (U8*) (disp_cluster), UI_text_height);
    }
    else 
        ShowString(UI_text_x, UI_text_y, *UI_font, 0, (U8*) (disp_cluster), UI_text_height);

    UI_text_height = 0;
    FONT_CANCEL_WIDTH(0);

    ire_enable_indic_rules_parsing();
    ire_indic_padding_def_value();
}
#endif /* __MMI_INDIC_ALG__ */ 


/*****************************************************************************
 * FUNCTION
 *  gui_draw_multi_line_under_line
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_multi_line_under_line(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 line_x, line_x2, line_y, line_y_end;
    S32 line_jump = (b->min_line_height < b->max_line_height) ? b->max_line_height : b->min_line_height;
    /* use this theme only after 07B*/
    gdi_color line_color = gdi_act_color_from_rgb(255, b->underline_color.r, b->underline_color.g, b->underline_color.b);


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (b->min_line_height > 0)
    {
        line_y = bs->yy + (b->header_height + b->header_gap) + line_jump - 1;
        line_y_end = bs->y1 + b->text_y + bs->border_y + b->edit_height - 1;

        if (b->footer_height > 0 && (line_y_end > bs->yy + bs->ty))
            line_y_end = bs->yy + bs->ty;

        /* we always draw line in whole area, only depeonds on the clipping area is correct */
        line_x = b->x;
        line_x2 = b->x + b->width - 1;

        while (line_y <= line_y_end && line_y < b->y)
            line_y += line_jump;    /* loop until line_y is visible */

        while (line_y <= line_y_end)
        {
            gdi_draw_line(line_x, line_y, line_x2, line_y, line_color);
            line_y += line_jump;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_draw_multi_line_callback_area
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_multi_line_callback_area(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* ty + b->footer_height will become b->text_height */
    if (b->min_text_height > 0 && bs->ty + b->footer_height < b->min_text_height)
    {
        bs->ty = b->min_text_height - b->footer_height;
    }

    if (b->max_empty_text_height > 0 && !b->text[0] && !b->text[1])
    {
        bs->ty = b->header_height + b->max_empty_text_height;
    }

    /* Draw header region */
    if (!(bs->flags & UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW) && b->header_callback)
    {
        /* Not overlapped with single-pixel border */
        b->header_callback(
            //(MMI_BOOL) ((b->header_height > 0) && (b->text_offset_y + b->header_height > 0)),
            bs->yy,
            //b->header_height,
            bs->x1 + 1,
            bs->y1 + 1,
            bs->x2 - 1,
            bs->y2 - 1);
    }

    /* Draw footer region */
    if (!(bs->flags & UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW) && b->footer_callback)
    {
        /* Not overlapped with single-pixel border */
        b->footer_callback(
            //(MMI_BOOL) ((b->footer_height > 0) && (b->text_offset_y + bs->ty < b->edit_height)),
            bs->yy + bs->ty,
            //b->footer_height,
            bs->x1 + 1,
            bs->y1 + 1,
            bs->x2 - 1,
            bs->y2 - 1);
    }

    if (!(bs->flags & UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW)
        && b->text != NULL)
    {
        gui_pop_text_clip();
        gui_pop_clip();
    }
    
    /* Draw left region */
    if (!(bs->flags & UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW) && b->left_callback)
    {
        /* Not overlapped with single-pixel border */
        b->left_callback(
            (MMI_BOOL) ((b->left_height > 0) && (b->text_offset_y + b->left_height > 0)),
            bs->yy,
            b->left_height,
            bs->x1 - b->left_width, bs->y1 + 1, bs->x1 - 1, bs->y2 - 1);
    }
    
    /* Draw right region */
    if (!(bs->flags & UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW) && b->right_callback)
    {
        /* Not overlapped with single-pixel border */
        b->right_callback(
            (MMI_BOOL) ((b->right_height > 0) && (b->text_offset_y + b->right_height > 0)),
            bs->yy,
            b->right_height,
            bs->x2 + 1, bs->y1 + 1, bs->x2 + b->right_width, bs->y2 - 1);
    }
    
    if (b->max_line_height > 0)
    {
        if (b->text_length == 0)
        {
            b->max_line_height = 0;
        }
        else if ((b->text != NULL) && (b->text[0] == 0 && b->text[1] == 0))
        {
            b->max_line_height = 0;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_adjust_multi_line_text_offset_y
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_adjust_multi_line_text_offset_y(multi_line_input_box *b, multi_line_input_box_show_struct *bs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 temp_d;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    temp_d = b->text_offset_y + bs->ty;

    if (bs->find_new_cursor_flag == FOUND_CURSOR)
    {
        b->ext_flags &= ~GUI_MULTI_LINE_INPUT_BOX_DISABLE_FORCE_CURSOR_APPEAR;
    }

    /* View mode condition added. Nov-19, TESTFIX   */
    if (!(b->flags & UI_MULTI_LINE_INPUT_BOX_VIEW_MODE))
    {
        if (temp_d < bs->edit_height)
        {
        #if defined(__MMI_SMART_MESSAGE_MO__) && !defined(__MMI_MESSAGES_EMS__)
            if (GetMessagesCurrScrnID() == SCR_ID_MSG_WRITE)
            {
                b->text_offset_y += 15;
            }
            else
        #endif /* defined(__MMI_SMART_MESSAGE_MO__) && !defined(__MMI_MESSAGES_EMS__) */ 
                b->text_offset_y += (bs->edit_height - temp_d);
            if (b->text_offset_y > 0)
            {
                b->text_offset_y = 0;
            }
        }
    }

    /* if not view mode then adjust the view point by cursor position */

#if defined(__UI_PAGING_IN_MULTILINE_EDITOR__)
    if (! (b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_VIEW_PAGING_MODE && bs->adjust_view)
        && !(b->flags & UI_MULTI_LINE_INPUT_BOX_VIEW_MODE)
        && !(b->ext_flags &GUI_MULTI_LINE_INPUT_BOX_DISABLE_FORCE_CURSOR_APPEAR))
#else
    if (!(b->flags & UI_MULTI_LINE_INPUT_BOX_VIEW_MODE)
        && !(b->ext_flags &GUI_MULTI_LINE_INPUT_BOX_DISABLE_FORCE_CURSOR_APPEAR))
#endif
    {
        if (bs->cursor_line_height == 0)
            bs->cursor_line_height = g_editor_line.line_height;
        
        if (bs->edit_height <= bs->cursor_line_height)
        {
            b->text_offset_y = -b->cursor_y;
            StopTimer(BLINKING_CURSOR);
        }
        else if ((b->cursor_y + bs->cursor_line_height + b->text_offset_y) > bs->edit_height &&
            bs->edit_height > bs->cursor_line_height)
        {
            b->text_offset_y = -(b->cursor_y + bs->cursor_line_height - bs->edit_height);
            StopTimer(BLINKING_CURSOR);
        }
        else if ((b->cursor_y + b->text_offset_y) < 0)
        {
            b->text_offset_y = -(b->cursor_y);
            StopTimer(BLINKING_CURSOR);
        }
    }

    if (b->flags & UI_MULTI_LINE_INPUT_BOX_VIEW_MODE
        && !(b->flags & UI_MULTI_LINE_INPUT_BOX_AUTO_DISABLE_SCROLLBAR
		     && b->flags & UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW)
        && !(b->ext_flags & GUI_MULTI_LINE_INPUT_BOX_FIXED_Y_OFFSET))
    {
        if (b->text_offset_y < b->edit_height - b->text_height)
        {
            b->text_offset_y = b->edit_height - b->text_height;
        }
        
        if( b->text_offset_y >0) 
            b->text_offset_y = 0;
    }
}

/*****************************************************************************
 * FUNCTION
 *  gui_check_multi_line_cursor_validation_for_wcss
 * DESCRIPTION
 *  
 * PARAMETERS
 *  b       [?]     
 *  bs      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
S32 gui_check_multi_line_cursor_validation_for_wcss(multi_line_input_box *b, multi_line_input_box_show_struct *bs, UI_buffer_type cursor_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 cursor_offset;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (b->predefine_char_pos != NULL)
    {

        cursor_offset = (cursor_p - b->text)/ENCODING_LENGTH;
        if (!gui_multi_line_input_box_test_cursor_pos(b, cursor_offset))
           return 0;
    }

    return 1;
}


#ifdef  __UI_ENHANCED_HILITE_IN_MULTILINE_EDITOR__
/*****************************************************************************
* FUNCTION
*  gui_set_multi_line_hilite_format
* DESCRIPTION
*  
* PARAMETERS
*  b       [?]     
*  bs      [?]     
* RETURNS
*  void
*****************************************************************************/
void gui_set_multi_line_hilite_format(multi_line_input_box *b, multi_line_input_box_show_struct *bs, U16 hilite_idx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 char_width, char_height;
    U8 format_flag;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(b->hilite_list != NULL);
    if (b->hilite_format_list[hilite_idx].format_flag != 0)
    {
        format_flag = b->hilite_format_list[hilite_idx].format_flag;
            
        if (format_flag & GUI_MULTI_LINE_INPUT_HILITE_TEXT_COLOR)
        {
            UI_MULTI_LINE_INPUT_BOX_SET_TEXT_COLOR(b->hilite_format_list[hilite_idx].text_color);
        }
    }
}
#endif

