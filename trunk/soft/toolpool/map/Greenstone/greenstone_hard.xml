<bigarchive>

<archive relative="****phantomglobalvars****">

</archive>

<archive relative='usbc.xml' >

<var name="SPFIFORAM_SIZE" value="264"/>
<module name="usbc" category="Periph">
    <var name="DIEP_NUM" value="3"/>
    <var name="DOEP_NUM" value="2"/>
    
    <reg name="GOTGCTL" protect="rw">
        <bits name="SesReqScs" pos="0" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SesReq" pos="1" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="HstNegScs" pos="8" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="HNPReq" pos="9" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="HstSetHNPEn" pos="10" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DevHNPEn" pos="11" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ConlDSts" pos="16" access="r" rst="1">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DbncTime" pos="17" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ASesVld" pos="18" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="BSesVld" pos="19" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GOTGINT" protect="rw">
        <bits name="SesEndDet" pos="2" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SesReqSucStsChng" pos="8" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="HstNegSucStsChng" pos="9" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="HstNegDet" pos="17" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ADevTOUTChg" pos="18" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DbnceDone" pos="19" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        
    </reg>
    <reg name="GAHBCFG" protect="rw">
        <bits name="GlblIntrMsk" pos="0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="HBstLen" pos="4:1" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DMAEn" pos="5" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NPTxFEmpLvl" pos="7" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PTxFEmpLvl" pos="8" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GUSBCFG" protect="rw">
        <bits name="TOutCal" pos="2:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PHYIf" pos="3" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ULPI_UTMI_Sel" pos="4" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="FSIntf" pos="5" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PHYSel" pos="6" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>        
        <bits name="DDRSel" pos="7" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>         
        <bits name="SRPCap" pos="8" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>         
        <bits name="HNPCap" pos="9" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>       
        <bits name="USBTrdTim" pos="13:10" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>            
        <bits name="PhyPwrClkSel" pos="15" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>       
        <bits name="OtgI2CSel" pos="16" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name="ULPIFsLs" pos="17" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name="ULPIAutoRes" pos="18" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name="ULPIClkSusM" pos="19" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name="ULPIExtVbusDrv" pos="20" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name="ULPIExtVbusIndicator" pos="21" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name="TermSelDLPulse" pos="22" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name="ForceHstMode" pos="29" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name="ForceDevMode" pos="30" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name="CorruptTxPacket" pos="31" access="rw" rst="0">
            <comment> 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
    </reg>
    <reg name="GRSTCTL" protect="rw">
        <bits name="CSftRst" pos="0" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="HSftRst" pos="1" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="FrmCntrRst" pos="2" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INTknQFlsh" pos="3" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="RxFFlsh" pos="4" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TxFFlsh" pos="5" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TxFNum" pos="10:6" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DMAReq" pos="30" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="AHBIdle" pos="31" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GINTSTS" protect="rw">
        <bits name="CurMod" pos="0" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ModeMis" pos="1" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OTGInt" pos="2" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Sof" pos="3" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="RxFLvl" pos="4" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NPTxFEmp" pos="5" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="GINNakEff" pos="6" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="GOUTNakEff" pos="7" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ULPICKINT" pos="8" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="I2CINT" pos="9" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ErlySusP" pos="10" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="USBSusp" pos="11" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="USBRst" pos="12" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EnumDone" pos="13" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ISOOutDrop" pos="14" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EOPF" pos="15" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPMis" pos="17" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="IEPInt" pos="18" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OEPInt" pos="19" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="incomplSOIN" pos="20" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="incompIP" pos="21" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="FetSusp" pos="22" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PrtInt" pos="24" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="HChInt" pos="25" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PTxFEmp" pos="26" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ConlDStsChng" pos="28" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DisconnInt" pos="29" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SessReqInt" pos="30" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="WkUpInt" pos="31" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        
    </reg>
    <reg name="GINTMSK" protect="rw">
        <bits name="ModeMis" pos="1" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OTGInt" pos="2" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Sof" pos="3" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="RxFLvl" pos="4" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NPTxFEmp" pos="5" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="GINNakEff" pos="6" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="GOUTNakEff" pos="7" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ULPICKINT" pos="8" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="I2CINT" pos="9" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ErlySusP" pos="10" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="USBSusp" pos="11" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="USBRst" pos="12" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EnumDone" pos="13" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ISOOutDrop" pos="14" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EOPF" pos="15" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPMis" pos="17" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="IEPInt" pos="18" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OEPInt" pos="19" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="incomplSOIN" pos="20" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="incompIP" pos="21" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="FetSusp" pos="22" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PrtInt" pos="24" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="HChInt" pos="25" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PTxFEmp" pos="26" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ConlDStsChng" pos="28" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DisconnInt" pos="29" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SessReqInt" pos="30" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="WkUpInt" pos="31" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GRXSTSR" protect="r">
        <bits name="EPNum"  pos="3:0" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="BCnt"  pos="14:4" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DPID"  pos="16:15" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PktSts"  pos="20:17" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="FN"  pos="24:21" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GRXSTSP" protect="">
        <bits name="EPNum"  pos="3:0" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="BCnt"  pos="14:4" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DPID"  pos="16:15" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PktSts"  pos="20:17" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="FN"  pos="24:21" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GRXFSIZ" protect="rw">
        <bits name="RxFDep"  pos="15:0" access="rw">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GNPTXFSIZ" protect="rw">
        <bits name="NPTxFStAddr"  pos="15:0" access="rw">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NPTxFDeps"  pos="31:16" access="rw">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GNPTXSTS" protect="r">
        <bits name="NPTxFSpcAvail"  pos="15:0" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NPTxQSpcAvail"  pos="23:16" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NPTxQTop"  pos="30:24" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GI2CCTL" protect="">
    </reg>
    <reg name="GPVNDCTL" protect="">
    </reg>
    <reg name="GGPIO" protect="">
    </reg>
    <reg name="GUID" protect="rw">
        <bits name="UserID"  pos="31:0" access="rw" rst="0xc0010000" display="hex">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GSNPSID" protect="r">
        <bits name="SynopsysID"  pos="31:0" access="r" rst="0x4f54" display="hex">
            <comment>Enable the template module
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GHWCFG1" protect="r">
        <bits name="epdir" pos="31:0" access="r">
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GHWCFG2" protect="r">
        <bits name="OtgMode" pos="2:0" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OtgArch" pos="4:3" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SingPnt" pos="5" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="HSPhyType" pos="7:6" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="FSPhyType" pos="9:8" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NumDevEps" pos="13:10" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NumHstChnl" pos="17:14" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PerioSupport" pos="18" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DynFifoSizing" pos="19" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>        
        <bits name="NPTxQDepth" pos="23:22" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PTxQDepth" pos="25:24" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TknQDepth" pos="30:26" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GHWCFG3" protect="r">
        <bits name="XferSizeWidth" pos="3:0" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PktSizeWidth" pos="6:4" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OtgEn" pos="7" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="I2CIntSel" pos="8" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="VndctlSupt" pos="9" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OptFeature" pos="10" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="RstType" pos="11" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DfifoDepth" pos="31:16" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="GHWCFG4" protect="r">
        <bits name="NumDevPerioEps" pos="3:0" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EnablePwrOpt" pos="4" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="AhbFreq" pos="5" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PhyDataWidth" pos="15:14" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NumCtlEps" pos="19:16" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="iddigFltr"  pos="20" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="VBusValidFltr"  pos="21" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="AValidFltr"  pos="22" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="BValidFltr"  pos="23" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SessEndFltr"  pos="24" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DeFifoMode"  pos="25" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INEps"  pos="29:26" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <hole size="1376" align = "0x100"/>
    <reg name="HPTXFSIZ" protect="">
    </reg>
    <struct count="DIEP_NUM" name="DIEPTXF">
    <reg name="DIEnPTXF" protect="rw">
        <bits name="IENPnTxFStAddr"  pos="15:0" access="rw">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INEPnTxFDep"  pos="31:16" access="rw">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    </struct>
    <hole size="14208" align = "0x800"/>
    <reg name="DCFG" protect="rw">
        <bits name="DevSpd"  pos="1:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NZStsOUTHShk"  pos="2" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DevAddr"  pos="10:4" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PerFrInt"  pos="12:11" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPMisCnt"  pos="22:18" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="DCTL" protect="rw">
        <bits name="RmtWkUpSig" pos="0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SftDiscon" pos="1" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="GNPINNakSts" pos="2" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="GOUTNakSts" pos="3" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TstCtl" pos="6:4" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SGNPInNak" pos="7" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="CGNPInNak" pos="8" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SGOUTNak" pos="9" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="CGOUTNak" pos="10" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PWROnPrgDone" pos="11" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        
    </reg>
    <reg name="DSTS" protect="r">
        <bits name="SuspSts"  pos="0" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EnumSpd"  pos="2:1" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ErrticErr"  pos="3" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SOFFN"  pos="21:8" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <hole size="32"/>
    <reg name="DIEPMSK" protect="rw">
        <bits name="XferComplMsk" pos="0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPDisbldMsk" pos="1" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="AHBErrMsk" pos="2" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TimeOUTMsk" pos="3" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INTknTXFEmpMsk" pos="4" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INTknEPMisMsk" pos="5" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INEPNakEffMsk" pos="6" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TxfifoUndrnMsk" pos="8" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="DOEPMSK" protect="rw">
        <bits name="XferComplMsk" pos="0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPDisbldMsk" pos="1" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="AHBErrMsk" pos="2" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SetUPMk" pos="3" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OUTTknEPdisMsk" pos="4" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Back2BackSETup" pos="6" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OutPktErrMsk" pos="8" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>        
    </reg>
    <reg name="DAINT" protect="r">
        <bits name="InEpInt"  pos="15:0" access="r" rst="0">
            <comment>Enable the template module
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OutEpInt"  pos="31:16" access="r" rst="0">
            <comment>Enable the template module
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="DAINTMSK" protect="rw">
        <bits name="InEpMsk"  pos="15:0" access="rw" rst="0">
            <comment>Enable the template module
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OutEpMsk"  pos="31:16" access="rw" rst="0">
            <comment>Enable the template module
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="DTKNQR1" protect="">
    </reg>
    <reg name="DTKNQR2" protect="">
    </reg>
    <reg name="DVBUSDIS" protect="rw">
        <bits name="DVBUSDis"  pos="15:0" access="rw">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="DVBUSPULSE" protect="rw">
        <bits name="DVBUSPulse"  pos="11:0" access="rw">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="DTHRCTL" protect="rw">
        <bits name="NonISOThrEn" pos="0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ISOThrEn" pos="1" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TxThrLen" pos="10:2" access="rw" rst="8">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="RxThrEn" pos="16" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="RxThrLen" pos="25:17" access="rw" rst="8">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="ArbPrkEn" pos="27" access="rw" rst="1">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="DIEPEMPMSK" protect="rw">
        <bits name="InEpTxfEmpMsk"  pos="15:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>    
   
    <hole size="1600" align = "0x900"/>
    <reg name="DIEPCTL0" protect="rw">
        <bits name="EP0_MPS" pos="1:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NextEp" pos="14:11" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="USBActEP" pos="15" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NAKSts" pos="17" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPType" pos="19:18" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Stall" pos="21" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPTxFNum" pos="25:22" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="CNAK" pos="26" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SNAK" pos="27" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPDis" pos="30" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPEna" pos="31" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <hole size="32" />
    <reg name="DIEPINT0" protect="rw">
        <bits name="XferCompl"  pos="0" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPDisbld"  pos="1" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="AHBErr"  pos="2" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TimeOut"  pos="3" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INTknTXFEmp"  pos="4" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INTknEPMis"  pos="5" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INEPNakEff"  pos="6" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TxFEmp"  pos="7" access="r" rst="1">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TxfifoUndrn"  pos="8" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <hole size="32" />
    <reg name="DIEPTSIZ0" protect="rw">
        <bits name="IEPXferSize0"  pos="6:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="IEPPktCnt0"  pos="20:19" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="DIEPDMA0" protect="rw">
        <bits name="DMAAddr"  pos="31:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="DIEPFSTS0" protect="rw">
        <bits name="INEPTxFSpcAvail"  pos="15:0" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    
    <hole size="32" />
    <struct count="DIEP_NUM" name="DIEPnCONFIG">
    <reg name="DIEPCTL" protect="rw">
        <bits name="EPn_MPS" pos="10:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NextEp" pos="14:11" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="USBActEP" pos="15" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DPID" pos="16" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NAKSts" pos="17" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPType" pos="19:18" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Snp" pos="20" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Stall" pos="21" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPTxFNum" pos="25:22" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="CNAK" pos="26" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SNAK" pos="27" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SetD0PID" pos="28" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SetD1PID" pos="29" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPDis" pos="30" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPEna" pos="31" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <hole size="32" />
    <reg name="DIEPINT" protect="rw">
        <bits name="XferCompl"  pos="0" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPDisbld"  pos="1" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="AHBErr"  pos="2" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TimeOut"  pos="3" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INTknTXFEmp"  pos="4" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INTknEPMis"  pos="5" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INEPNakEff"  pos="6" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TxFEmp"  pos="7" access="r" rst="1">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TxfifoUndrn"  pos="8" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <hole size="32" />
    <reg name="DIEPTSIZ" protect="rw">
        <bits name="IEPXferSize"  pos="18:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="IEPPktCnt"  pos="28:19" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="MC"  pos="30:29" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>

    </reg>
    <reg name="DIEPDMA" protect="rw">
        <bits name="DMAAddr"  pos="31:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="DIEPFSTS" protect="rw">
        <bits name="INEPTxFSpcAvail"  pos="15:0" access="r">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <hole size="32" />
    </struct>

    <hole size="3072" align = "0xb00"/>
    <reg name="DOEPCTL0" protect="rw">
        <bits name="EP0_MPS" pos="1:0" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="USBActEP" pos="15" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NAKSts" pos="17" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPType" pos="19:18" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Snp" pos="20" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Stall" pos="21" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="CNAK" pos="26" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SNAK" pos="27" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPDis" pos="30" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPEna" pos="31" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>        
    </reg>
    <hole size="32" />
    <reg name="DOEPINT0" protect="rw">
        <bits name="XferCompl"  pos="0" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPDisbld"  pos="1" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="AHBErr"  pos="2" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Setup"  pos="3" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INTknTXFEmp"  pos="4" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INTknEPMis"  pos="5" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INEPNakEff"  pos="6" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TxFEmp"  pos="7" access="r" rst="1">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TxfifoUndrn"  pos="8" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <hole size="32" />
    <reg name="DOEPTSIZ0" protect="rw">
        <bits name="OEPXferSize0"  pos="6:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OEPPktCnt0"  pos="19" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SUPCnt"  pos="30:29" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="DOEPDMA0" protect="rw">
        <bits name="DMAAddr"  pos="31:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    
    <hole size="64" />
    <struct count="DOEP_NUM" name="DOEPnCONFIG">
    <reg name="DOEPCTL" protect="rw">
        <bits name="EPn_MPS" pos="10:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NextEp" pos="14:11" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="USBActEP" pos="15" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="DPID" pos="16" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="NAKSts" pos="17" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPType" pos="19:18" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Snp" pos="20" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Stall" pos="21" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPTxFNum" pos="25:22" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="CNAK" pos="26" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SNAK" pos="27" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SetD0PID" pos="28" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="SetD1PID" pos="29" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPDis" pos="30" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPEna" pos="31" access="rs" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <hole size="32" />
    <reg name="DOEPINT" protect="rw">
        <bits name="XferCompl"  pos="0" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="EPDisbld"  pos="1" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="AHBErr"  pos="2" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="Setup"  pos="3" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INTknTXFEmp"  pos="4" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INTknEPMis"  pos="5" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="INEPNakEff"  pos="6" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TxFEmp"  pos="7" access="r" rst="1">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="TxfifoUndrn"  pos="8" access="rc" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <hole size="32" />
    <reg name="DOEPTSIZ" protect="rw">
        <bits name="OEPXferSize"  pos="18:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="OEPPktCnt"  pos="28:19" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="MC"  pos="30:29" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <reg name="DOEPDMA" protect="rw">
        <bits name="DMAAddr"  pos="31:0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <hole size="64" />
    </struct>
    
    <hole size="5376" align="0xe00" />
    <reg name="PCGCCTL" protect="rw">
        <bits name="StopPclk"  pos="0" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="GateHclk"  pos="1" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PwrClmp"  pos="2" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="RstPdwnModule"  pos="3" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="PhySuspended"  pos="4" access="rw" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    
    <hole size="4064" align="0x1000"/>
    <struct count="DIEP_NUM+1" name="EPnFIFO">
    <reg name="TxRxData" protect="wr">
        <bits name="TxData" pos="31:0" access="w" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name="RxData" pos="31:0" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    <hole size="32736" />
    </struct>

    <hole size="884736" align="0x20000"/>
    <struct count="SPFIFORAM_SIZE" name="SPFIFORAM">
    <reg name="RAMData" protect="r">
        <bits name="Data" pos="31:0" access="r" rst="0">
            <comment>
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
    </struct>
    
    
</module>


</archive>
<archive relative='voc_ram.xml' >

<module name="voc_ram" category="Voc">

    <var name="VOC_RAM_X_SIZE" value="0x2000"/>
    <var name="VOC_RAM_Y_SIZE" value="0x1000"/>
    <var name="VOC_ROM_Z_SIZE" value="0xb000"/>
    <var name="VOC_RAM_I_SIZE" value="0x4800"/>

    <var name="VOC_RAM_X_SPACE" value="0x8000"/>
    <var name="VOC_RAM_Y_SPACE" value="0x8000"/>
    <var name="VOC_ROM_Z_SPACE" value="0x10000"/>
    <var name="VOC_RAM_I_SPACE" value="0x20000"/>
    
    <memory name="voc_ram_x_base" size="VOC_RAM_X_SIZE">
        <comment>VoC RAM X space. 
        </comment>
    </memory>
    <memory name="voc_ram_x_hole" size="VOC_RAM_X_SPACE - VOC_RAM_X_SIZE">
        <comment>VoC RAM X whole. 
        </comment>
    </memory>
    <memory name="voc_ram_y_base" size="VOC_RAM_Y_SIZE">
        <comment>VoC RAM Y space. 
        </comment>
    </memory>
    <memory name="voc_ram_y_hole" size="VOC_RAM_Y_SPACE - VOC_RAM_Y_SIZE">
        <comment>VoC RAM Y whole. 
        </comment>
    </memory>
    <memory name="voc_rom_z_base" size="VOC_ROM_Z_SIZE">
        <comment>VoC ROM Z space. 
        </comment>
    </memory>
    <memory name="voc_rom_z_hole" size="VOC_ROM_Z_SPACE - VOC_ROM_Z_SIZE">
        <comment>VoC ROM Y whole. 
        </comment>
    </memory>
    <memory name="voc_ram_i_base" size="VOC_RAM_I_SIZE">
        <comment>VoC RAM I space. 
        </comment>
    </memory>
    <memory name="voc_ram_i_hole" size="VOC_RAM_I_SPACE - VOC_RAM_I_SIZE">
        <comment>VoC RAM I whole. 
        </comment>
    </memory>

</module>

</archive>
<archive relative='voc_global.xml' >

  
  <var name="AHB_NB_BITS_ADDR" value="25" ><comment>AHB Address bus size</comment></var>
</archive>

<archive relative='voc_ahb.xml' >


<include file="voc_global.xml"/>

<module name="voc_ahb" category="Voc">
    <reg name="Irq_Status" protect="rw">
        <bits name="XCpu_Voc_Irq_Cause" pos="0" access="r" rst="0">
            <comment>1 when Voc triggered an Irq to the XCpu.
            </comment>
        </bits>
        <bits name="XCpu_Dma_Irq_Cause" pos="1" access="r" rst="0">
            <comment>1 when the DMA triggered an Irq to the XCpu.
            </comment>
        </bits>
        <bits name="XCpu_DmaVoc_Irq_Cause" pos="2" access="r" rst="0">
            <comment>1 when the DMA programmed from Voc triggered an Irq to the XCpu.
            </comment>
        </bits>
        <bits name="XCpu_Debug_Irq_Cause" pos="3" access="r" rst="0">
            <comment>1 when a VoC stall state is reached during debugging.
            </comment>
        </bits>
        <bitgroup name="XCpu_Irq_Cause">
            <entry ref="XCpu_Voc_Irq_Cause"/>
            <entry ref="XCpu_Dma_Irq_Cause"/>
            <entry ref="XCpu_DmaVoc_Irq_Cause"/>
            <entry ref="XCpu_Debug_Irq_Cause"/>
        </bitgroup>
        <bits name="BCpu_Voc_Irq_Cause" pos="8" access="r" rst="0">
            <comment>1 when Voc triggered an Irq to the BCpu.
            </comment>
        </bits>
        <bits name="BCpu_Dma_Irq_Cause" pos="9" access="r" rst="0">
            <comment>1 when the DMA triggered an Irq to the BCpu.
            </comment>
        </bits>
        <bits name="BCpu_DmaVoc_Irq_Cause" pos="10" access="r" rst="0">
            <comment>1 when the DMA programmed from Voc triggered an Irq to the BCpu.
            </comment>
        </bits>
        <bits name="BCpu_Debug_Irq_Cause" pos="11" access="r" rst="0">
            <comment>1 when a VoC stall state is reached during debugging.
            </comment>
        </bits>
        <bitgroup name="BCpu_Irq_Cause">
            <entry ref="BCpu_Voc_Irq_Cause"/>
            <entry ref="BCpu_Dma_Irq_Cause"/>
            <entry ref="BCpu_DmaVoc_Irq_Cause"/>
            <entry ref="BCpu_Debug_Irq_Cause"/>
        </bitgroup>
        <bits name="XCpu_Voc_Irq_Status" pos="16" access="r" rst="0">
            <comment>1 when Voc triggered an Irq to the XCpu. (not masked, status only)
            </comment>
        </bits>
        <bits name="XCpu_Dma_Irq_Status" pos="17" access="r" rst="0">
            <comment>1 when the DMA triggered an Irq to the XCpu. (not masked, status only)
            </comment>
        </bits>
        <bits name="XCpu_DmaVoc_Irq_Status" pos="18" access="r" rst="0">
            <comment>1 when the DMA programmed from Voc triggered an Irq to the XCpu. (not masked, status only)
            </comment>
        </bits>
        <bits name="XCpu_Debug_Irq_Status" pos="19" access="r" rst="0">
            <comment>1 when a VoC stall state is reached during debugging. (not masked, status only)
            </comment>
        </bits>
        <bitgroup name="XCpu_Irq_Status">
            <entry ref="XCpu_Voc_Irq_Status"/>
            <entry ref="XCpu_Dma_Irq_Status"/>
            <entry ref="XCpu_DmaVoc_Irq_Status"/>
            <entry ref="XCpu_Debug_Irq_Status"/>
        </bitgroup>
        <bits name="BCpu_Voc_Irq_Status" pos="24" access="r" rst="0">
            <comment>1 when Voc triggered an Irq to the BCpu (not masked, status only).
            </comment>
        </bits>
        <bits name="BCpu_Dma_Irq_Status" pos="25" access="r" rst="0">
            <comment>1 when the DMA triggered an Irq to the BCpu. (not masked, status only)
            </comment>
        </bits>
        <bits name="BCpu_DmaVoc_Irq_Status" pos="26" access="r" rst="0">
            <comment>1 when the DMA programmed from Voc triggered an Irq to the BCpu. (not masked, status only)
            </comment>
        </bits>
        <bits name="BCpu_Debug_Irq_Status" pos="27" access="r" rst="0">
            <comment>1 when a VoC stall state is reached during debugging. (not masked, status only)
            </comment>
        </bits>
        <bitgroup name="BCpu_Irq_Status">
            <entry ref="BCpu_Voc_Irq_Status"/>
            <entry ref="BCpu_Dma_Irq_Status"/>
            <entry ref="BCpu_DmaVoc_Irq_Status"/>
            <entry ref="BCpu_Debug_Irq_Status"/>
        </bitgroup>
    </reg>
    <reg name="Irq_Mask_Set" protect="rw">
        <bits name="XCpu_Voc_Irq_Mask" pos="0" access="rs" rst="0">
            <comment>Write 1 to set the mask for Voc Irq to the XCpu.
            </comment>
        </bits>
        <bits name="XCpu_Dma_Irq_Mask" pos="1" access="rs" rst="0">
            <comment>Write 1 to set the mask for DMA Irq to the XCpu.
            </comment>
        </bits>
        <bits name="XCpu_DmaVoc_Irq_Mask" pos="2" access="rs" rst="0">
            <comment>Write 1 to set the mask for DMA Irq to the XCpu when the DMA is programmed from Voc.
            </comment>
        </bits>
        <bits name="XCpu_Debug_Irq_Mask" pos="3" access="rs" rst="0">
            <comment>Write 1 to set the mask for Debug Irq to the XCpu.
            </comment>
        </bits>
        <bitgroup name="XCpu_Irq_Mask">
            <entry ref="XCpu_Voc_Irq_Mask"/>
            <entry ref="XCpu_Dma_Irq_Mask"/>
            <entry ref="XCpu_DmaVoc_Irq_Mask"/>
            <entry ref="XCpu_Debug_Irq_Mask"/>
        </bitgroup>
        <bits name="BCpu_Voc_Irq_Mask" pos="8" access="rs" rst="0">
            <comment>Write 1 to set the mask for Voc Irq to the BCpu.
            </comment>
        </bits>
        <bits name="BCpu_Dma_Irq_Mask" pos="9" access="rs" rst="0">
            <comment>Write 1 to set the mask for DMA Irq to the BCpu.
            </comment>
        </bits>
        <bits name="BCpu_DmaVoc_Irq_Mask" pos="10" access="rs" rst="0">
            <comment>Write 1 to set the mask for DMA Irq to the BCpu when the DMA is programmed from Voc.
            </comment>
        </bits>
        <bits name="BCpu_Debug_Irq_Mask" pos="11" access="rs" rst="0">
            <comment>Write 1 to set the mask for Debug Irq to the BCpu.
            </comment>
        </bits>
        <bitgroup name="BCpu_Irq_Mask">
            <entry ref="BCpu_Voc_Irq_Mask"/>
            <entry ref="BCpu_Dma_Irq_Mask"/>
            <entry ref="BCpu_DmaVoc_Irq_Mask"/>
            <entry ref="BCpu_Debug_Irq_Mask"/>
        </bitgroup>
    </reg>
    <reg name="Irq_Mask_Clr" protect="rw">
        <bits name="XCpu_Voc_Irq_Mask" pos="0" access="rc" rst="0">
            <comment>Write 1 to clear the mask for Voc Irq to the XCpu.
            </comment>
        </bits>
        <bits name="XCpu_Dma_Irq_Mask" pos="1" access="rc" rst="0">
            <comment>Write 1 to clear the mask for DMA Irq to the XCpu.
            </comment>
        </bits>
        <bits name="XCpu_DmaVoc_Irq_Mask" pos="2" access="rc" rst="0">
            <comment>Write 1 to clear the mask for DMA Irq to the XCpu when the DMA is programmed from Voc.
            </comment>
        </bits>
        <bits name="XCpu_Debug_Irq_Mask" pos="3" access="rc" rst="0">
            <comment>Write 1 to clear the mask for Debug Irq to the XCpu.
            </comment>
        </bits>
        <bitgroup name="XCpu_Irq_Mask">
            <entry ref="XCpu_Voc_Irq_Mask"/>
            <entry ref="XCpu_Dma_Irq_Mask"/>
            <entry ref="XCpu_DmaVoc_Irq_Mask"/>
            <entry ref="XCpu_Debug_Irq_Mask"/>
        </bitgroup>
        <bits name="BCpu_Voc_Irq_Mask" pos="8" access="rc" rst="0">
            <comment>Write 1 to clear the mask for Voc Irq to the BCpu.
            </comment>
        </bits>
        <bits name="BCpu_Dma_Irq_Mask" pos="9" access="rc" rst="0">
            <comment>Write 1 to clear the mask for DMA Irq to the BCpu.
            </comment>
        </bits>
        <bits name="BCpu_DmaVoc_Irq_Mask" pos="10" access="rc" rst="0">
            <comment>Write 1 to clear the mask for DMA Irq to the BCpu when the DMA is programmed from Voc.
            </comment>
        </bits>
        <bits name="BCpu_Debug_Irq_Mask" pos="11" access="rc" rst="0">
            <comment>Write 1 to clear the mask for Debug Irq to the BCpu.
            </comment>
        </bits>
        <bitgroup name="BCpu_Irq_Mask">
            <entry ref="BCpu_Voc_Irq_Mask"/>
            <entry ref="BCpu_Dma_Irq_Mask"/>
            <entry ref="BCpu_DmaVoc_Irq_Mask"/>
            <entry ref="BCpu_Debug_Irq_Mask"/>
        </bitgroup>
    </reg>
    <reg name="DMA_Cfg" protect="rw">
        <bits name="DMA_SizeLow" pos="1:0" access="r" rst="0">
            <comment>Ignored on write, read as 0, so DMA_Size can be programmed in 15:0 as a byte size as long as the size in a multiple of 4.
            </comment>
        </bits>
        <bits name="DMA_WSize" pos="15:2" access="rw" rst="all1">
            <comment>Number of 32bits Words to transfer.
            </comment>
        </bits>
        <bitgroup name="DMA_Size">
            <entry ref="DMA_SizeLow"/>
            <entry ref="DMA_WSize"/>
        </bitgroup>
        <bits name="DMA_Run" pos="16" access="rw" rst="0">
            <comment>Start the DMA transfer
            </comment>
        </bits>
        <bits name="DMA_Dir" pos="20" access="rw" rst="1">
            <comment>Set the DMA transfer direction
            </comment>
            <options>
                <option name="Read" value="0"><comment>Read from main memory to Voc Memory</comment></option>
                <option name="Write" value="1"><comment>Write to main memory from Voc Memory</comment></option>
            </options>
        </bits>
        <bits name="DMA_Wrap" pos="27:24" access="rw" rst="1">
            <comment>Set the DMA wrap mode, refer to Voc documentation for a description of Wrap transfers.
            </comment>
        </bits>
    </reg>
    <reg name="DMA_LAddr" protect="rw">
        <bits name="DMA_LAddr" pos="16:1" access="rw" rst="0">
            <comment>DMA Local Address: Address in the Voc memory space.
            </comment>
            <options> 
                <mask/>
            </options>
        </bits>
    </reg>
    <reg name="DMA_EAddr" protect="rw">
        <bits name="DMA_EAddr" pos="AHB_NB_BITS_ADDR-1:2" access="rw" rst="0">
            <comment>DMA External Address: Address in the main memory space.
            </comment>
            <options> 
                <mask/>
            </options>
        </bits>
        <bits name="DMA_Write" pos="30" access="rw" rst="0">
            <comment>Set the DMA transfer direction
            </comment>
            <options>
                <option name="Read" value="0"><comment>Read from main memory to Voc Memory</comment></option>
                <option name="Write" value="1"><comment>Write to main memory from Voc Memory</comment></option>
            </options>
        </bits>
        <bits name="DMA_Single" pos="31" access="rw" rst="0">
            <comment>When 1 start a DMA transfer in Single mode, the data is tranfered to/from the DMA_Data_Single register.
                <br/>When 0 start a regular DMA transfer using LAddr and Size.
            </comment>
        </bits>
    </reg>
    <reg name="DMA_Status" protect="rw">
        <bits name="DMA_On" pos="0" access="r" rst="0">
            <comment>1 when DMA is running.
            </comment>
        </bits>
        <bits name="DMA_Sema_Status" pos="31" access="r" rst="1">
            <comment>Read the value of the DMA Semaphore without affecting it.
            </comment>
        </bits>
    </reg>
    <reg name="DMA_Sema" protect="w">
        <bits name="DMA_Sema" pos="1" access="w" rst="1">
            <comment>Read the value of the DMA Semaphore:
                <br/>If 1 is returned the DMA was available and is know taken.
                <br/>If 0 is returned the DMA is not available, you need to try again to get it. The software can wait on any DMA Irq before retrying if Sema is never free manually.
                <br/>Write 1 to free manually (got the semaphore and want to discard it without prgrammin a transfer.)
                <br/>The end of the DMA will also free the Semaphone.
            </comment>
        </bits>
    </reg>
</module>

</archive>
<archive relative='voc_cfg.xml' >


<include file="voc_global.xml"/>

<module name="voc_cfg" category="Voc">
    <reg16 name="Ctrl" protect="rw">
        <bits name="Run" pos="2:0" access="w">
            <options>
                <option name="Pause" value="0"><comment>Pause VoC (no pipe flush). When paused, all events that wake up VoC (start, soft wake up, or wake up on extern event) will resume the execution from where it was paused.</comment></option>
                <option name="SoftWakeUp0" value="1"><comment>CPU generated event with id=0 that can wake VoC if the coresponding bit in the Wakeup_Mask register is set to '1'.</comment></option>
                <option name="SoftWakeUp1" value="3"><comment>CPU generated event with id=1 that can wake VoC if the coresponding bit in the Wakeup_Mask register is set to '1'</comment></option>
                <option name="Stop" value="4"><comment>Stop VoC and flush pipe. Used when the current task is finished (because the next task will have a different PC start). The PC start change should mandatorily be preceeded by a Stop. This ensures that no previously executed code that is still in the pipe will modify the registry during the first two instructions of the new task execution.</comment></option>
                <option name="Start" value="5"><comment>Wake up VoC regardless of the Wakeup_Mask setting (force wake up)</comment></option>
            </options>
        </bits>
        <bits name="BCPU_irq" pos="4" access="w">
            <comment>Writing '1' will generate an internal pulse recorded in the Irq_Status register of the voc_ahb interface (see voc_ahb registers). If the corresponding bit of the Irq_Mask vector is set to '1', a level interrupt will be generated to the BCPU. Should be configured by VoC_core only (not by a CPU)!
            </comment>
        </bits>
        <bits name="XCPU_irq" pos="5" access="w">
            <comment>Writing '1' will generate an internal pulse recorded in the Irq_Status register of the voc_ahb interface (see voc_ahb registers). If the corresponding bit of the Irq_Mask vector is set to '1', a level interrupt will be generated to the XCPU. Should be configured by VoC_core only (not by a CPU)!
            </comment>
        </bits>
        <bits name="Running" pos="0" access="r" rst="0">
            <options>
                <option name="Yes" value="1"><comment>VoC is running</comment></option>
                <option name="No" value="0"><comment>VoC is paused or stopped</comment></option>
                <default/>
            </options>
        </bits>
        <bits name="Sema_Status" pos="1" access="r" rst="1">
            <comment>Status of the VoC semaphore (reading this bit will not modify the semaphore).
            </comment>
        </bits>
    </reg16>
    <reg16 name="DMA_Wrap" protect="r">
        <comment>Should be configured by VoC_core only (not by a CPU)! If VoC DMA is used by the CPU the equivalent voc_ahb registers should be configured.
        </comment>
        <bits name="DMA_Wrap" pos="3:0" access="r" rst="all0">
            <comment>Wrap register. 0 : no wrap, wrap_val (other than 0): the wrap_val LSB bits of the Word wrap address are at '0'.
            </comment>
        </bits>
    </reg16>
    <reg16 name="DMA_Size" protect="r">
        <comment>Should be configured by VoC_core only (not by a CPU)! If VoC DMA is used by the CPU the equivalent voc_ahb registers should be configured.
        </comment>
        <bits name="DMA_Size" pos="13:0" access="r" rst="all0">
            <comment>Word Size of the DMA Transfer (number of INT32 to transfer) 
            </comment>
        </bits>
    </reg16>
    <reg16 name="DMA_Laddr" protect="r">        
        <comment>Should be configured by VoC_core only (not by a CPU)! If VoC DMA is used by the CPU the equivalent voc_ahb registers should be configured.
        </comment>
        <bits name="DMA_LAddr" pos="15:0" access="r" rst="all0">
            <comment>DMA Local Word Address: Address in the Voc memory space.
            </comment>
        </bits>
    </reg16>
    <reg name="DMA_EAddr" protect="r">
        <comment>Should be configured by VoC_core only (not by a CPU)! If VoC DMA is used by the CPU the equivalent voc_ahb registers should be configured.
        </comment>
        <bits name="DMA_EAddr" pos="AHB_NB_BITS_ADDR-1:2" access="r" rst="0">
            <comment>DMA External Byte Address (aligned to Word address, the 2 lsb are always '0'): Address in the main memory space.
            </comment>
            <options> 
                <mask/>
            </options>
        </bits>
        <bits name="DMA_Write" pos="30" access="r" rst="0">
            <comment>Set the DMA transfer direction
            </comment>
            <options>
                <option name="Read" value="0"><comment>Read from main memory to Voc Memory</comment></option>
                <option name="Write" value="1"><comment>Write to main memory from Voc Memory</comment></option>
            </options>
        </bits>
        <bits name="DMA_Single" pos="31" access="r" rst="0">
            <comment>When 1 start a DMA transfer in Single mode, the data is tranfered to/from the DMA_Data_Single register.
                <br/>When 0 start a regular DMA transfer using LAddr and Size.
            </comment>
        </bits>
    </reg>
    <reg name="DMA_Data_Single" protect="r">
        <bits name="DMA_Data_Single" pos="31:0" access="r" rst="0">
            <comment>DMA Data for Single Access (source or destination depending on direction)
            </comment>
        </bits>
    </reg>
    <hole size="64"/>
    <reg16 name="DAI_Data_In">
        <bits name="DAI_Data_In" pos="12:0" access="r" rst="0">
            <comment>Data from DAI Simple interface.
            </comment>
        </bits>
        <bits name="DAI_Data_Ready" pos="15" access="r" rst="0">
            <comment>Data ready.
            </comment>
        </bits>       
    </reg16>
    <reg16 name="DAI_Data_Out" protect="w">
        <bits name="DAI_Data_Out" pos="12:0" access="w">
            <comment>Data for DAI Simple.
            </comment>
        </bits>
    </reg16>
    <reg16 name="ROM_Page" rst="0">
        <bits name="ROM_Page" pos="15:0" access="rw">
           <comment>Number of the ROM page when a ROM bigger than 1 page is defined in voc_cfg_pkg.vhd. Otherwise this register does not exist.
           </comment>
        </bits>
    </reg16>
    <reg16 name="Debug" rst="0">
        <bits name="stall_on_bkp" pos="0" access="rw" rst="0">
           <comment>Enable or disable stall on hardware breakpoint.
           </comment>
        </bits>
        <bits name="stall_on_branch_taken" pos="1" access="rw" rst="0">
           <comment>Enable or disable stall when a branch is taken in the program.
           </comment>
        </bits>
        <bits name="step" pos="2" access="rw" rst="0">
           <comment>Enable or disable step mode (execute 1 instruction and stall).
           </comment>
        </bits>
    </reg16>
    <reg name="BIST_Ctrl"  protect="rw">
       <bits name="BIST_Run" pos="0" access="w">
            <comment>'1' : start.
            </comment>
       </bits>
       <bits name="BIST_Running" pos="0" access="r" rst="0">
            <comment>'0' : done.
            </comment>
       </bits>
       <bits name="BIST_Status" pos="1" access="r" rst="0">
            <comment>'1' : fail. '0' : succeed. Valid when BIST_Running is at '0'.
            </comment>
       </bits>        
       <bits name="BIST_CRC" pos="31:16" access="r" rst="0">
            <comment>16-bit CRC result of the ROM. Valid when BIST_Running is at '0'.
            </comment>
       </bits>        
    </reg>
    <reg16 name="Wakeup_Mask" protect="rw">
       <bits name="IFC0_Event_Mask" pos="0" access="rw" rst="0">
            <comment>Mask enabling the IFC0 half or whole buffer event.
            </comment>
       </bits>        
       <bits name="IFC1_Event_Mask" pos="1" access="rw" rst="0">
            <comment>Mask enabling the IFC1 half or whole buffer event.
            </comment>
       </bits>
       <bits name="DMAE_Event_Mask" pos="2" access="rw" rst="0">
            <comment>Mask enabling the DMAE event (DMA configured by extern master done).
            </comment>
       </bits>
       <bits name="DMAI_Event_Mask" pos="3" access="rw" rst="0">
            <comment>Mask enabling the DMAI event (DMA configured by VoC core done).
            </comment>
       </bits>
       <bits name="SOF0_Event_Mask" pos="4" access="rw" rst="0">
            <comment>Mask enabling the SOF0 event (Soft Wake Up with Id=0 generated by writing the corresponding value in the control register).
            </comment>
       </bits>
       <bits name="SOF1_Event_Mask" pos="5" access="rw" rst="0">
            <comment>Mask enabling the SOF1 event (Soft Wake Up with Id=1 generated by writing the corresponding value in the control register).
            </comment>
       </bits>
       <bitgroup name="Wakeup_Mask">
            <entry ref="IFC0_Event_Mask"/>
            <entry ref="IFC1_Event_Mask"/>
            <entry ref="DMAE_Event_Mask"/>
            <entry ref="DMAI_Event_Mask"/>
            <entry ref="SOF0_Event_Mask"/>
            <entry ref="SOF1_Event_Mask"/>
        </bitgroup>
    </reg16>
    <hole size="16"/>
    <reg16 name="Wakeup_Status" protect="rc">
       <bits name="IFC0_Event_Status" pos="0" access="rc" rst="0">
            <comment>'1': Triggered IFC0 event. Write '1' to clear.
            </comment>
       </bits>        
       <bits name="IFC1_Event_Status" pos="1" access="rc" rst="0">
            <comment>'1': Triggered IFC1 event. Write '1' to clear.
            </comment>
       </bits>
       <bits name="DMAE_Event_Status" pos="2" access="rc" rst="0">
            <comment>'1': Triggered DMAE event. Write '1' to clear.
            </comment>
       </bits>
       <bits name="DMAI_Event_Status" pos="3" access="rc" rst="0">
            <comment>'1': Triggered DMAI event. Write '1' to clear.
            </comment>
       </bits>
       <bits name="SOF0_Event_Status" pos="4" access="rc" rst="0">
            <comment>'1': Triggered SOF0 event. Write '1' to clear.
            </comment>
       </bits>
       <bits name="SOF1_Event_Status" pos="5" access="rc" rst="0">
            <comment>'1': Triggered SOF1 event. Write '1' to clear.
            </comment>
       </bits>
       <bitgroup name="Wakeup_Status">
            <entry ref="IFC0_Event_Status"/>
            <entry ref="IFC1_Event_Status"/>
            <entry ref="DMAE_Event_Status"/>
            <entry ref="DMAI_Event_Status"/>
            <entry ref="SOF0_Event_Status"/>
            <entry ref="SOF1_Event_Status"/>
        </bitgroup>
    </reg16>
    <reg16 name="Wakeup_Cause" access="r" rst="0">
       <comment>Logical AND of Wakeup_Status and Wakeup_Mask (show only the enabled events).
       </comment>
       <bits name="IFC0_Event_Cause" pos="0" access="r" rst="0">
       </bits>        
       <bits name="IFC1_Event_Cause" pos="1" access="r" rst="0">
       </bits>
       <bits name="DMAE_Event_Cause" pos="2" access="r" rst="0">
       </bits>
       <bits name="DMAI_Event_Cause" pos="3" access="r" rst="0">
       </bits>
       <bits name="SOF0_Event_Cause" pos="4" access="r" rst="0">
       </bits>
       <bits name="SOF1_Event_Cause" pos="5" access="r" rst="0">
       </bits>
    </reg16>  
    <reg16 name="Sema" protect="w">
       <bits name="Sema" pos="0" access="w" rst="1">
            <comment>VoC semaphore. If the register is read when the field = '1', the field = '0' on the next VoC clock cycle. Can write '0' or '1' in this field.
            </comment>
       </bits>
    </reg16>
    <hole size="144"/>
    <reg name="REG01" protect="rw">
        <bits name="REG0" pos="15:0" access="rw" rst="0">
            <comment>Voc General Register REG0
            </comment>
        </bits>
        <bits name="REG1" pos="31:16" access="rw" rst="0">
            <comment>Voc General Register REG1
            </comment>
        </bits>
        <l name="REG0"/>
        <h name="REG1"/>
    </reg>
    <reg name="REG23" protect="rw">
        <bits name="REG2" pos="15:0" access="rw" rst="0">
            <comment>Voc General Register REG2
            </comment>
        </bits>
        <bits name="REG3" pos="31:16" access="rw" rst="0">
            <comment>Voc General Register REG3
            </comment>
        </bits>
        <l name="REG2"/>
        <h name="REG3"/>
    </reg>
    <reg name="REG45" protect="rw">
        <bits name="REG4" pos="15:0" access="rw" rst="0">
            <comment>Voc General Register REG4
            </comment>
        </bits>
        <bits name="REG5" pos="31:16" access="rw" rst="0">
            <comment>Voc General Register REG5
            </comment>
        </bits>
        <l name="REG4"/>
        <h name="REG5"/>
    </reg>
    <reg name="REG67" protect="rw">
        <bits name="REG6" pos="15:0" access="rw" rst="0">
            <comment>Voc General Register REG6
            </comment>
        </bits>
        <bits name="REG7" pos="31:16" access="rw" rst="0">
            <comment>Voc General Register REG7
            </comment>
        </bits>
        <l name="REG6"/>
        <h name="REG7"/>
    </reg>
    <reg name="ACC0" protect="rw">
        <bits name="ACC0_LO" pos="15:0" access="rw" rst="0">
            <comment>Voc Accumulator Register ACC0 (lo)
            </comment>
        </bits>
        <bits name="ACC0_HI" pos="31:16" access="rw" rst="0">
            <comment>Voc Accumulator Register ACC0 (hi)
            </comment>
        </bits>
        <l name="ACC0_lo"/>
        <h name="ACC0_hi"/>
    </reg>
    <reg name="ACC1" protect="rw">
        <bits name="ACC1_LO" pos="15:0" access="rw" rst="0">
            <comment>Voc Accumulator Register ACC1 (lo)
            </comment>
        </bits>
        <bits name="ACC1_HI" pos="31:16" access="rw" rst="0">
            <comment>Voc Accumulator Register ACC1 (hi)
            </comment>
        </bits>
        <l name="ACC1_lo"/>
        <h name="ACC1_hi"/>
    </reg>
    <reg name="RL6" protect="rw">
        <bits name="RL6_LO" pos="15:0" access="rw" rst="0">
            <comment>Voc General Register RL6 (lo)
            </comment>
        </bits>
        <bits name="RL6_HI" pos="31:16" access="rw" rst="0">
            <comment>Voc General Register RL6 (hi)
            </comment>
        </bits>
        <l name="RL6_lo"/>
        <h name="RL6_hi"/>
    </reg>
    <reg name="RL7" protect="rw">
        <bits name="RL7_LO" pos="15:0" access="rw" rst="0">
            <comment>Voc General Register RL7 (lo)
            </comment>
        </bits>
        <bits name="RL7_HI" pos="31:16" access="rw" rst="0">
            <comment>Voc General Register RL7 (hi)
            </comment>
        </bits>
        <l name="RL7_lo"/>
        <h name="RL7_hi"/>
    </reg>
    <reg16 name="PC" protect="rw">
        <bits name="PC" pos="15:0" access="rw" rst="0">
            <comment>Voc Program Counter Register PC
            </comment>
        </bits>
    </reg16>
    <reg16 name="RA" protect="rw">
        <bits name="RA" pos="15:0" access="rw" rst="0">
            <comment>Voc Return Address Register RA
            </comment>
        </bits>
    </reg16>
    <reg16 name="SP16" protect="rw">
        <bits name="SP16" pos="15:0" access="rw" rst="0">
            <comment>Voc Stack Register SP16
            </comment>
        </bits>
    </reg16>
    <reg16 name="SP32" protect="rw">
        <bits name="SP32" pos="15:0" access="rw" rst="0">
            <comment>Voc Stack Register SP32
            </comment>
        </bits>
    </reg16>
    <hole size="64"/>
    <reg16 name="BKP" protect="rw">
        <bits name="BKP" pos="15:0" access="rw" rst="0">
            <comment>Voc Program Breakpoint Register. Valid when the Dbg_On mode in the Ctrl register is set to '1'
            </comment>
        </bits>
    </reg16>
    <hole size="16"/>
    <reg16 name="PC_PREV" protect="r">
        <bits name="PC_PREV" pos="15:0" access="r" rst="0">
            <comment>Previous PC value. Used to track the source PC of a branch when the stall_on_branch_taken bit in the Debug register is enabled
            </comment>
        </bits>
    </reg16>
    <reg16 name="LOOP" protect="r">
        <bits name="LOOP0" pos="7:0" access="r" rst="0">
            <comment>Loop 0 counter value
            </comment>
        </bits>
        <bits name="LOOP1" pos="15:8" access="r" rst="0">
            <comment>Loop 1 counter value
            </comment>
        </bits>
    </reg16>
    
</module>

</archive>

<archive relative='lcdc.xml' >


<module name="lcdc">



     <reg name="apbi_ctrl_lcd" protect="rw">
       <bits name="L_Endian"  pos="1:0" access="rw" rst="00">
          <comment>Controls the big endian or little endian of the FIFO data.
              <br/>Take 32 bit data 0X0A0B0C0D for Example,bit[31:24]=Byte3,bit[23:16]=Byte2,bit[15:8]=Byte1,bit[7:0]=Byte0.
              <br/>"00": the order is not changed.
                <br/>Byte3="0A",Byte2="0B",Byte1="0C",Byte0="0D".
              <br/>"01": reversed on byte.
                <br/>Byte3="0D",Byte2="0C,Byte1="0B",Byte0="0A".
              <br/>"10": reversed on half word.
                <br/>Byte3="0C",Byte2="0D,Byte1="0A",Byte0="0B".
              <br/>"10": reversed on bit.
                <br/>Byte3="B0",Byte2="30,Byte1="D0",Byte0="50".
          </comment>
       </bits> 
        <bits name="Soft_rst_L" pos="2" access="rw" rst="1">
          <comment>For the software to clear FIFO in case there is an error in communication with LCD controller and some data are left behind.
              <br/>Active Low.
          </comment>
        </bits>
    </reg>  
     
<hole size="32" />

    <reg name="APBI_FIFO"  protect="w">   
         <bits name="DATA_IN" pos="31:0" access="w">
           <comment>Write to the transmit FIFO
           </comment>
         </bits>
    </reg>

<hole size="8096" />
    <reg protect="rw" name="LCD_CTRL">
    <bits access="rw" name="LCD_ENABLE" pos="0" rst="0">		  
      <comment>1: Enable LCDC Transfer
      </comment>
    </bits>

    <bits access="rw" name="LCD_CTRL_RW" pos="4" rst="1">		  
      <comment>0: Read from LCD. 
	      <br />1: write to LCD.
      </comment>
    </bits>
     <bits access="rw" name="LCD_CTRL_RS" pos="5" rst="0">		  
      <comment>Register select.
	      <br />0: command(Index or Status)
	      <br />1: data
      </comment>
    </bits>   
    <bits access="rw" name="LCD_CTRL_AF" pos="8" rst="0">		  
      <comment>0: Transfer data or command through APB.
	      <br />   1 Data in every word. (little endian)
              <br />
	      <br />1: Transfer data through FIFO. 
	      <br />   multi-data in every word. (little endian)
	      <br />When LCD_CFG_REG (LCD_CFG_DBS)= 000
	      <br />   1 Data = 1 Byte
	      <br />When LCD_CFG_REG (LCD_CFG_DBS)= 001 or 010
	      <br />   1 Data = 1 Halfword
	      <br />When LCD_CFG_REG (LCD_CFG_DBS)= 011
	      <br />   1 Data = 1 word
      </comment>
    </bits>  
    <bits access="rw" name="LCD_CTRL_CNT" pos="31:12" rst="0x00000" display="hex">		  
       <comment>Size of DMA Transfer when LCD_CTRL_AF is '1'.
              <br />When LCD_CFG_REG (LCD_CFG_DBS)= 000
              <br />   LCD_CTRL_CNT is the number of Byte
	      <br />When LCD_CFG_REG (LCD_CFG_DBS)= 001 or 010
	      <br />   LCD_CTRL_CNT is the number of Halfword
	      <br />When LCD_CFG_REG (LCD_CFG_DBS)= 011
	      <br />   LCD_CTRL_CNT is the number of word
       </comment>
    </bits> 
  </reg>

  <reg protect="r" name="LCD_STATUS">	  
    <bits access="r" name="LCD_RDY" pos="0" rst="1">		  
      <comment>Read only. 
	      <br />1: LCDC is ready
	      <br />0: LCDC is busy
      </comment>
    </bits>
    <bits access="r" name="LCD_INT_STATUS" pos="16" rst="0">		  
      <comment>Read only. 
	      <br />The status for the interupt source
      </comment>
    </bits>
    <bits access="r" name="LCD_INT_CAUSE" pos="20" rst="0">		  
      <comment>Read only. 
	      <br />The cause for the interupt source
      </comment>
    </bits>
  </reg>

  <reg protect="rw" name="LCD_DATA">
	<bits access="rw" name="LCD_DATA" pos="31:0" rst="0x0000" display="hex"> 
		<comment>LCD controller data out/in.
           </comment>
	</bits> 
  </reg>

   <reg protect="rw" name="LCD_CLEAR">
	<bits access="rw" name="LCD_INT_CLR" pos="16" rst='0' display="hex"> 
           <comment>Write '1' clear 'LCD_INT_CAUSE' and 'LCD_INT_STATUS' to '0'
           </comment>
        </bits>
   </reg>


  <reg protect="rw" name="LCD_CFG">
    <bits access="rw" name="LCD_CFG_DBS" pos="2:0" rst="0x0" display="hex">		  
      <comment>LCD controller data bus select. 
	      <br />000: 8bit
	      <br />001: 9bit
	      <br />010: 16bit
	      <br />011: 18bit
      </comment>
    </bits>
    <bits access="rw" name="LCD_CFG_CS" pos="6:4" rst="0x0" display="hex">		  
      <comment>1: Enable LCD controller chip select output. 
      </comment>
    </bits>
       <bits access="rw" name="LCD_CFG_PIS" pos="8" rst="0">		  
      <comment>LCD controller data bus select.
	      <br />0: 80-system bus interface
	      <br />1: 68-system bus interface
      </comment>
    </bits> 
    <bits access="rw" name="LCD_CS_POL" pos="14:12" rst="0x0" display="hex">		  
      <comment>LCD controller chip select Polarity. 
	      <br />0: Active Low
	      <br />1: Active High
      </comment>
    </bits>
    <bits access="rw" name="LCD_INT_MASK" pos="16" rst="0x1" display="hex">		  
      <comment>1: Enable LCDC interrupt.
	      <br />0: Disable LCDC interrupt.
      </comment>
    </bits>

  </reg>
  <reg protect="rw" name="LCD_TIMING">
    <bits access="rw" name="LCD_TIMING_TAS" pos="1:0" rst="0x3" display="hex">		  
	    <comment>LCD controller parallel interface timing parameter.
	      <br />RS, RW setup time. 
	      <br />01: 1 clock
	      <br />10: 2 clock
	      <br />11: 3 clock
      </comment>
    </bits>
    <bits access="rw" name="LCD_TIMING_TCH" pos="13:8" rst="0x3f" display="hex">		  
      <comment>LCD controller parallel interface timing parameter.
	      <br />Control (E, WR/RD) pulse width high.
	      <br />000010 to 111111 Indicates 2 to 63 clocks. 
      </comment>
    </bits> 
     <bits access="rw" name="LCD_TIMING_TCL" pos="21:16" rst="0x3f" display="hex">		  
      <comment>LCD controller parallel interface timing parameter.
	      <br /> Control (E, WR/RD) pulse width low
	      <br /> 000010 to 111111 Indicates 2 to 63 clocks. 
      </comment>
    </bits>        
  </reg>


<hole size="8000" />

    <reg protect="rw" name="SLCD_CTRL">
	<bits access="rw" name="ENABLE" pos="0" rst='0' display="hex"> 
           <comment>1: Enable SLCDC Transfer
           </comment>
        </bits>

	<bits access="rw" name="SCL_ENABLE" pos="4" rst='0' display="hex"> 
		<comment>1: Enable SCL.
			<br />0: Disable SCL.
                </comment>
	</bits>
	<bits access="rw" name="APB_FF" pos="8" rst='0' display="hex"> 
		<comment>0: Single Transfer
			<br />1: DMA Write Data
                </comment>
	</bits>
	<bits access="rw" name="CD" pos="12" rst='0' display="hex"> 
		<comment>0: Transmit Command.
			<br />1: Transmit Data.
                </comment>
	</bits>

	<bits access="rw" name="DMA_CNT" pos="31:16" rst='0x0000' display="hex"> 
		<comment>Size of DMA Transmit in Bytes
                </comment>
        </bits>
   </reg>


  <reg protect="r" name="SLCD_STATUS">	  
    <bits access="r" name="READY" pos="0" rst="1">		  
      <comment>Read only. 
	      <br />1: SLCDC is ready
	      <br />0: SLCDC is busy
      </comment>
    </bits>
    <bits access="r" name="SLCD_INT_STATUS" pos="8" rst="0">		  
      <comment>Read only. 
	      <br />The status for the interupt source
      </comment>
    </bits>
    <bits access="r" name="SLCD_INT_CAUSE" pos="12" rst="0">		  
      <comment>Read only. 
	      <br />The cause for the interupt source
      </comment>
    </bits>
  </reg>

  <reg protect="rw" name="SLCD_CFG">
    <bits access="rw" name="LINE" pos="0" rst="0x0" display="hex">		  
      <comment>0: 4-line interface
	      <br />1: 3-line interface
      </comment>
    </bits>
    <bits access="rw" name="CE" pos="4" rst="0x0" display="hex">		  
	    <comment>0: Chip Enable active low 
	      <br />1: Chip Enable active high
            </comment>
    </bits>
       <bits access="rw" name="SLCD_INT_MASK" pos="8" rst="1">		  
      <comment>1: Enable SLCDC interrupt.
	      <br />0: Disable SLCDC interrupt.
      </comment>
    </bits> 
  </reg>

   <reg protect="rw" name="SLCD_INT">
	<bits access="rw" name="INT_CLEAR" pos="8" rst='0' display="hex"> 
           <comment>Write '1' clear 'SLCD_INT_CAUSE' and 'SLCD_INT_STATUS' to '0'
           </comment>
        </bits>
   </reg>

   <reg protect="rw" name="SLCD_RW">
	<bits access="rw" name="RW" pos="0" rst='0' display="hex"> 
		<comment>0: Transmit Write Command or Data.
			<br />1: Transmit Read Command.
                </comment>
	</bits>
	<bits access="rw" name="READ_BYTE" pos="6:4" rst='1' display="hex"> 
		<comment>SLCDC Read Byte Number select
			<br />When RW = 1
			<br />001: 1 Byte Read
			<br />011: 3 Byte Read
			<br />100: 4 Byte Read
                </comment>
        </bits>
   </reg>

  <reg protect="rw" name="SLCD_CDOUT">
	<bits access="rw" name="CMD_DATA" pos="31:0" rst="0x0000" display="hex"> 
           <comment>Command or Data To Be Output
           </comment>
	</bits> 
  </reg>
  <reg protect="r" name="SLCD_DIN">
	<bits access="r" name="DIN" pos="31:0" rst="0x00000000" display="hex"> 
           <comment>Data Read In 
           </comment>
	</bits> 
</reg>
  <reg protect="rw" name="SLCD_DIVCLK">
	<bits access="rw" name="DIV_CLK" pos="15:0" rst="0x0000" display="hex"> 
		<comment>SCL Timing Control
			<br />SCL = PCLK/(2(DIV_CLK + 1))
           </comment>
	</bits> 
</reg>

</module>  
</archive>
<archive relative='sdmmc.xml' >


<module name="sdmmc">


    <reg name="apbi_ctrl_sdmmc" protect="rw">
       <bits name="L_Endian"  pos="1:0" access="rw" rst="00">
          <comment>Controls the big endian or little endian of the FIFO data.
              <br/>Take 32 bit data 0X0A0B0C0D for Example,bit[31:24]=Byte3,bit[23:16]=Byte2,bit[15:8]=Byte1,bit[7:0]=Byte0.
              <br/>"00": the order is not changed.
                <br/>Byte3="0A",Byte2="0B",Byte1="0C",Byte0="0D".
              <br/>"01": reversed on byte.
                <br/>Byte3="0D",Byte2="0C,Byte1="0B",Byte0="0A".
              <br/>"10": reversed on half word.
                <br/>Byte3="0C",Byte2="0D,Byte1="0A",Byte0="0B".
              <br/>"10": reversed on bit.
                <br/>Byte3="B0",Byte2="30,Byte1="D0",Byte0="50".
          </comment>
       </bits> 
       <bits name="Soft_rst_L" pos="2" access="rw" rst="1">
          <comment>For the software to clear FIFO in case there is an error in communication with SD controller and some data are left behind.
              <br/>Active Low.
          </comment>
       </bits>
     </reg>

     <hole size="32"/>

     <reg name="APBI_FIFO_TxRx"  protect="--">   
         <bits name="DATA_IN" pos="31:0" access="w">
           <comment>Write to the transmit FIFO
           </comment>
         </bits>
         <bits name="DATA_OUT" pos="31:0" access="r">
           <comment>Read in the receive FIFO
           </comment>
         </bits>
     </reg>



<hole size="16288"/>

<reg protect="rw" name="SDMMC_CONFIG">

	<bits access="rw" name="SDMMC_SENDCMD" pos="0" rst="0">
		<comment>SD/MMC operation begin register, active high.<br /> 
		When '1', the controller finishes the last command and goes into suspend status. At suspend status, the controller will not execute the next command until the bit is set '0'.
		</comment>
	</bits>
	
	<bits access="rw" name="SDMMC_SUSPEND" pos="1" rst="1">
		<comment>SD/MMC operation suspend register, active high.
		</comment>
	</bits>
	
	<bits access="rw" name="RSP_EN" pos="4" rst="0">
		<comment>'1'indicates having a response,'0'indicates no response.
		</comment>
	</bits>
	
	<bits access="rw" name="RSP_SEL" pos="6:5" rst="0">
		<comment>Response select register,"10" means R2 response, "01" means R3 response, "00" means others response, "11" is reserved.
		</comment> 
	</bits>
	
	<bits access="rw" name="RD_WT_EN" pos="8" rst="0">
		<comment>'1' indicates data operation, which includes read and write.
		</comment>
	</bits>
	
	<bits access="rw" name="RD_WT_SEL" pos="9" rst="0">
		<comment>'1' means write operation,'0' means read operation.
		</comment>
	</bits>
	
	<bits access="rw" name="S_M_SEL" pos="10" rst="0">
		<comment>'1'means multiple block data operation.
		</comment>
	</bits>
	
</reg>
	
<reg protect="r" name="SDMMC_STATUS">

	<bits access="r" name="Not_SDMMC_OVER" pos="0" rst="0">
		<comment>'1' means the SD/MMC operation is not over.
		</comment>
	</bits>
		
	<bits access="r" name="BUSY" pos="1" rst="0">
		<comment>'1' means SD/MMC is busy.
		</comment>
	</bits>	

	<bits access="r" name="DL_BUSY" pos="2" rst="0">
		<comment>'1' means the data line is busy.
		</comment>
	</bits>
	
	<bits access="r" name="SUSPEND" pos="3" rst="1">
		<comment>'1' means the controller will not perform the new command when SDMMC_SENDCMD= '1'.
		</comment>
	</bits>

	
	
		

	<bits access="r" name="RSP_ERROR" pos="8" rst="0">
		<comment>Response CRC checks error register '1' means response CRC check error.
		</comment>
	</bits>
	
	<bits access="r" name="NO_RSP_ERROR" pos="9" rst="0">
		<comment>'1' means the card has no response to command. 
		</comment>
	</bits>
	
	<bits access="r" name="CRC_STATUS" pos="14:12" rst="0">
		<comment>CRC check for SD/MMC write operation <br /> 
		"101" transmission error<br />
		"010" transmission right<br />
		"111" flash programming error
		</comment>
	</bits>
	
	<bits access="r" name="DATA_ERROR" pos="23:16" rst="0">
		<comment>8 bits data CRC check, "00000000" means no data error, "00000001" means DATA0 CRC check error, "10000000" means DATA7 CRC check error, each bit match one data line.
		</comment>
	</bits>
	
</reg>

<reg protect="rw" name="SDMMC_CMD_INDEX">

	<bits access="rw" name="COMMAND" pos="5:0" rst="0">
		<comment>SD/MMC command register.
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_CMD_ARG">

	<bits access="rw" name="ARGUMENT" pos="31:0" rst="0">
		<comment>SD/MMC command argument register, write data to the SD/MMC card.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_INDEX">

	<bits access="r" name="RESPONSE" pos="5:0" rst="0">
		<comment>SD/MMC response index register.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG3">

	<bits access="r" name="ARGUMENT3" pos="31:0" rst="0">
		<comment>Response argument of R1, R3 and R6, or 127 to 96 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG2">

	<bits access="r" name="ARGUMENT2" pos="31:0" rst="0">
		<comment>95 to 64 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG1">

	<bits access="r" name="ARGUMENT1" pos="31:0" rst="0">
		<comment>63 to 32 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_RESP_ARG0">

	<bits access="r" name="ARGUMENT0" pos="31:0" rst="0">
		<comment>31 to 0 bit response argument of R2.
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_DATA_WIDTH">

	<bits access="rw" name="SDMMC_DATA_WIDTH" pos="3:0" rst="0">
		<comment>SD/MMC data width:<br />
		0x1: 1 data line<br />
		0x2: 2 reserved<br />
		0x4: 4 data lines<br />
		0x8: 8 data lines
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_BLOCK_SIZE">

	<bits access="rw" name="SDMMC_BLOCK_SIZE" pos="3:0" rst="0">
		<comment>SD/MMC size of one block:<br />
		0-1:reserved<br />
		2: 1 word<br />
		3: 2 words<br />
		4: 4 words<br />
		5: 8 words<br />
		6: 16 words<br />
 		       <br />
		11: 512 words<br />
		12-15 reserved
		</comment>
	</bits>

</reg>

<reg protect="rw" name="SDMMC_BLOCK_CNT">

	<bits access="rw" name="SDMMC_BLOCK_CNT" pos="15:0" rst="0">
		<comment>Block number that wants to transfer.
		</comment>
	</bits>

</reg>

<reg protect="r" name="SDMMC_INT_STATUS">

	<bits access="r" name="NO_RSP_INT" pos="0" rst="0">
		<comment>'1' means no response.
		</comment>
	</bits>

	<bits access="r" name="RSP_ERR_INT" pos="1" rst="0">
		<comment>'1' means CRC error of response.
		</comment>
	</bits>
	
	<bits access="r" name="RD_ERR_INT" pos="2" rst="0">
		<comment>'1' means CRC error of reading data.
		</comment>
	</bits>

	<bits access="r" name="WR_ERR_INT" pos="3" rst="0">
		<comment>'1' means CRC error of writing data.
		</comment>
	</bits>

	<bits access="r" name="DAT_OVER_INT" pos="4" rst="0">
		<comment>'1' means data transmission is over.
		</comment>
	</bits>
	
	<bits access="r" name="NO_RSP_SC" pos="8" rst="0">
		<comment>'1' means no response is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="RSP_ERR_SC" pos="9" rst="0">
		<comment>'1' means CRC error of response is the source of interrupt.
		</comment>
	</bits>
	
	<bits access="r" name="RD_ERR_SC" pos="10" rst="0">
		<comment>'1' means CRC error of reading data is the source of interrupt.
		</comment>
	</bits>

	<bits access="r" name="WR_ERR_SC" pos="11" rst="0">
		<comment>'1' means CRC error of writing data is the source of interrupt.
		</comment>
	</bits>
	 
	<bits access="r" name="DAT_OVER_SC" pos="12" rst="0">
		<comment>'1' means the end of data transmission is the source of interrupt.
		</comment>
	</bits>
	
</reg>



<reg protect="rw" name="SDMMC_INT_MASK">

	<bits access="rw" name="NO_RSP_MK" pos="0" rst="0">
		<comment>When no response, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="RSP_ERR_MK" pos="1" rst="0">
		<comment>When CRC error of response, '1' means INT is disable.
		</comment>
	</bits>
	
	<bits access="rw" name="RD_ERR_MK" pos="2" rst="0">
		<comment>When CRC error of reading data, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="WR_ERR_MK" pos="3" rst="0">
		<comment>When CRC error of writing data, '1' means INT is disable.
		</comment>
	</bits>

	<bits access="rw" name="DAT_OVER_MK" pos="4" rst="0">
		<comment>When data transmission is over, '1' means INT is disable.
		</comment>
	</bits>
</reg>


<reg protect="w" name="SDMMC_INT_CLEAR">

	<bits access="w" name="NO_RSP_CL" pos="0" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in NO_RSP_SC.
		</comment>
	</bits>

	<bits access="w" name="RSP_ERR_CL" pos="1" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in RSP_ERR_SC.
		</comment>
	</bits>
	
	<bits access="w" name="RD_ERR_CL" pos="2" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in RD_ERR_SC.
		</comment>
	</bits>

	<bits access="w" name="WR_ERR_CL" pos="3" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in WR_ERR_SC.
		</comment>
	</bits>

	<bits access="w" name="DAT_OVER_CL" pos="4" rst="0">
		<comment>Write a '1' to this bit to clear the source of interrupt in DAT_OVER_SC.
		</comment>
	</bits>
</reg>

<reg protect="rw" name="SDMMC_TRANS_SPEED">

	<bits access="rw" name="SDMMC_TRANS_SPEED" pos="7:0" rst="0">
		<comment>Mclk = Pclk/(2*(SDMMC_TRANS_SPEED +1)).
		</comment>
	</bits>
</reg>

<reg protect="rw" name="SDMMC_MCLK_ADJUST">

	<bits access="rw" name="SDMMC_MCLK_ADJUST" pos="3:0" rst="0">
		<comment>This register may delay the mclk output. 
			 When MCLK_ADJUSTER = n, Mclk is outputted with  n Pclk.	
		</comment>
	</bits>

	<bits access="rw" name="CLK_INV" pos="4" rst="0">
		<comment>Invert Mclk.	
		</comment>
	</bits>

</reg>

</module>
</archive>

<archive relative='camera.xml' >

<module name="camera" category="Periph">


    <reg name="apbi_ctrl_camera" protect="rw">
       <bits name="L_Endian"  pos="1:0" access="rw" rst="00">
          <comment>Controls the big endian or little endian of the FIFO data.
              <br/>Take 32 bit data 0X0A0B0C0D for Example,bit[31:24]=Byte3,bit[23:16]=Byte2,bit[15:8]=Byte1,bit[7:0]=Byte0.
              <br/>"00": the order is not changed.
                <br/>Byte3="0A",Byte2="0B",Byte1="0C",Byte0="0D".
              <br/>"01": reversed on byte.
                <br/>Byte3="0D",Byte2="0C,Byte1="0B",Byte0="0A".
              <br/>"10": reversed on half word.
                <br/>Byte3="0C",Byte2="0D,Byte1="0A",Byte0="0B".
              <br/>"10": reversed on bit.
                <br/>Byte3="B0",Byte2="30,Byte1="D0",Byte0="50".
          </comment>
       </bits>
       <bits name="Soft_rst_L" pos="2" access="rw" rst="1">
          <comment>For the software to clear FIFO in case there is an error in communication with SD controller and some data are left behind.
              <br/>Active Low.
          </comment>
       </bits>
     </reg>

     <hole size="32"/>

     <reg name="APBI_FIFO_Rx"  protect="--">
         <bits name="DATA_OUT" pos="31:0" access="r">
           <comment>Read in the receive FIFO
           </comment>
         </bits>
     </reg>


<hole size="16288"/>

	<reg protect="rw" name="Interrupt CLEAR register">
		<bits access="wo" name="OVFL" pos="0" rst="0">
			<comment> Write '1' to clear FIFO over-write interrupt
			</comment>
		</bits>
		<bits access="wo" name="FSTART" pos="1" rst="0">
			<comment> Write '1' to clear Frame start interrupt
			</comment>
		</bits>
		<bits access="wo" name="FEND" pos="2" rst="0">
			<comment> Write '1' to clear Frame end interrupt
			</comment>
		</bits>
		<bits access="wo" name="VSYNC" pos="3" rst="0">
			<comment> Write '1' to clear VSYNC interrupt
			</comment>
		</bits>
	</reg>
	
	<reg protect="ro" name="Interrupt STATUS register">
		<bits access="ro" name="OVFL" pos="0" rst="0">
			<comment> '1' = FIFO over-write status 
			</comment>
		</bits>
		<bits access="ro" name="FSTART" pos="1" rst="0">
			<comment> '1' = Frame start status 
			</comment>
		</bits>
		<bits access="ro" name="FEND" pos="2" rst="0">
			<comment> '1' = Frame end status 
			</comment>
		</bits>
		<bits access="ro" name="VSYNC" pos="3" rst="0">
			<comment> '1' = VSYNC status 
			</comment>
		</bits>
	</reg>
	
	<reg protect="ro" name="Interrupt CAUSE register">
		<bits access="ro" name="OVFL" pos="0" rst="0">
			<comment> '1' = FIFO over-write cause 
			</comment>
		</bits>
		<bits access="ro" name="FSTART" pos="1" rst="0">
			<comment> '1' = Frame start cause 
			</comment>
		</bits>
		<bits access="ro" name="FEND" pos="2" rst="0">
			<comment> '1' = Frame end cause 
			</comment>
		</bits>
		<bits access="ro" name="VSYNC" pos="3" rst="0">
			<comment> '1' = VSYNC cause 
			</comment>
		</bits>
	</reg>

	<reg protect="wr" name="Interrupt MASK register">
		<bits access="wr" name="OVFL" pos="0" rst="0">
			<comment> '1' = FIFO over-write enable 
			</comment>
		</bits>
		<bits access="wr" name="FSTART" pos="1" rst="0">
			<comment> '1' = Frame start enable
			</comment>
		</bits>
		<bits access="wr" name="FEND" pos="2" rst="0">
			<comment> '1' = Frame end enable 
			</comment>
		</bits>
		<bits access="wr" name="VSYNC" pos="3" rst="0">
			<comment> '1' = VSYNC enable 
			</comment>
		</bits>
	</reg>

	<reg protect="rw" name="Camera CONTROL register">
		<bits access="rw" name="Mode" pos="0" rst="0">
			<comment> '1'= All frame data will be sent continues.
				'0'= only odd frame data will be sent continues.
			</comment>
		</bits>
		<bits access="rw" name="PWDON" pos="1" rst="1">
			<comment> Power down pin of CMOS sensor . 
			</comment>
		</bits>
		<bits access="rw" name="RESET" pos="2" rst="0">
			<comment> Reset pin of CMOS sensor. . 
			</comment>
		</bits>
		<bits access="rw" name="EnCamera" pos="3" rst="0">
			<comment> Enable camera controller,high active. 
			</comment>
		</bits>
		<bits access="rw" name="test" pos="4" rst="0">
			<comment> 
				Debug only
			</comment>
		</bits>
	</reg>
</module>
</archive>


<archive relative='****phantomglobalvars****'>

</archive>
<archive relative='globals.xml' vhdlpkg='chip_cfg_pkg'>


  
  <var name='NB_BITS_ADDR' value='25'><comment>AHB Address bus size</comment></var>

  <var name='NB_BITS_MAXSPACE' value='24'><comment>Bigest Address space: 16 MB max</comment></var>

  

  <var name='SYS_SRAM_ADDR_WIDTH' value='13'><comment>The System SRam size</comment></var>
  <var name='SYS_SRAM_SIZE' value='exp2(SYS_SRAM_ADDR_WIDTH+2)'/>

  <var name='SYS_NB_BITS_MASTER' value='3'><comment>System Ahb Bus Configuration</comment></var>
  
  <enum name='Sys_Master_Id'>
    <entry name='SYS_MID_DUMMY'/>
    <entry name='SYS_MID_BIST'/>
    <bound name='SYS_MID_RR_Start'><comment>After this starts the Round Robib Pool</comment></bound>
    <entry name='SYS_MID_DMA'/>
    <entry name='SYS_MID_XCPU'/>
    <entry name='SYS_MID_AHB2AHB'/>
    <entry name='SYS_MID_IFC'/>
    <entry name='SYS_MID_USB'/>
    <bound name='SYS_MID_RR_End'/>
  </enum>
  <var name='SYS_NB_STATIC_MASTER' value='SYS_MID_RR_Start-1'/>
  <var name='SYS_NB_MASTERS' value='SYS_MID_RR_End-1'/>

  <var name='SYS_NB_BITS_SLAVE' value='3'/>
  
  <enum name='Sys_slave_Id'>
    <entry name='SYS_SID_DUMMY'/>
    <entry name='SYS_SID_MEM_BRIDGE'/>
    <entry name='SYS_SID_AHB2AHB'/>
    <entry name='SYS_SID_IFC'/>
    <entry name='SYS_SID_USB'/>
    <bound name='SYS_SID_End'/>
  </enum>
  <var name='SYS_NB_SLAVES' value='SYS_SID_End-1'/>

  <var name='SYS_NB_BITS_PSEL' value='6'><comment>System Apb Bus Configuration</comment></var>
  <var name='SYS_NB_BITS_PADDR' value='12'/>

  <var name='SYS_APB_STEP' value='exp2(SYS_NB_BITS_PADDR)'/>

  
  <enum name='Sys_Module_Id'>
    <entry name='SYS_ID_SYS_CTRL'/>
    <entry name='SYS_ID_IRQ'/>
    <entry name='SYS_ID_TIMER'/>
    <entry name='SYS_ID_GPIO'/>
    <entry name='SYS_ID_EBC'/>
    <entry name='SYS_ID_KEYPAD'/>
    <entry name='SYS_ID_PWM'/>
    <entry name='SYS_ID_I2C'/>
    <entry name='SYS_ID_DMA'/>
    <entry name='SYS_ID_IFC'/>
    <entry name='SYS_ID_CALENDAR'/>
    <entry name='SYS_ID_COMREGS'/>
    <entry name='SYS_ID_PAGE_SPY'/>
    <entry name='SYS_ID_DEBUG_PORT'/>
    <bound name='FIRST_SYS_ID_DATA'/> 
    <entry name='SYS_ID_RF_SPI'/>
    <entry name='SYS_ID_TCU'/>
    
    <entry name='SYS_ID_SCI'><comment>The following modules are linked to ifc dma req with 2 requests per module</comment></entry>
    <entry name='SYS_ID_SPI'/>
    <entry name='SYS_ID_SPI2'/>
    <entry name='SYS_ID_DEBUG_UART'/>
    <entry name='SYS_ID_UART'/>
    <entry name='SYS_ID_UART2'/>
    <entry name='SYS_ID_SDMMC'/>
    <entry name='SYS_ID_EXT_APB'/>
    <entry name='SYS_ID_LCDC'/>
    <entry name='SYS_ID_CAMERA'/>
    <bound name='LAST_SYS_ID_DATA'/>
    <entry name='SYS_ID_XCPU_REG'/>
    <entry name='SYS_ID_XCPU_TAG'/>
    <entry name='SYS_ID_XCPU_IDATA'/>
    <entry name='SYS_ID_XCPU_DDATA'/>
    <entry name='SYS_ID_SYS_AHBC_MON'/>
    <entry name='SYS_ID_BB_AHBC_MON'/>
    <entry name='SYS_ID_BIST'/>
    <entry name='SYS_ID_GPADC'/>
    <entry name='SYS_ID_PA_AFC'/>
    <entry name='SYS_ID_ANA_FE'/>

    <bound name='SYS_NB_PSEL'><comment>The maximum number of slaves is currently 33 (excluding the HOST).</comment></bound>
  </enum>
    <var name='SYS_ID_DEBUG_HOST' value='exp2(SYS_NB_BITS_PSEL)-1'><comment>The debug host is placed at last PSEL63 in the IFC</comment></var>
  
  
  <enum name='Sys_Ifc_Request_IDs'>
    <entry name='SYS_ID_TX_SCI'/>       
    <entry name='SYS_ID_RX_SCI'/>       
    <entry name='SYS_ID_TX_SPI'/>       
    <entry name='SYS_ID_RX_SPI'/>       
    <entry name='SYS_ID_TX_SPI2'/>      
    <entry name='SYS_ID_RX_SPI2'/>      
    <entry name='SYS_ID_TX_DEBUG_UART'/>
    <entry name='SYS_ID_RX_DEBUG_UART'/>
    <entry name='SYS_ID_TX_UART'/>      
    <entry name='SYS_ID_RX_UART'/>      
    <entry name='SYS_ID_TX_UART2'/>     
    <entry name='SYS_ID_RX_UART2'/>     
    <entry name='SYS_ID_TX_SDMMC'/>     
    <entry name='SYS_ID_RX_SDMMC'/>     
    <entry name='SYS_ID_TX_EXT_APB'/>   
    <entry name='SYS_ID_RX_EXT_APB'/>   
    <entry name='SYS_ID_TX_LCDC'/>      
                                        
                                        
    <entry name='SYS_ID_RX_CAMERA' value='SYS_ID_TX_LCDC+3'/>    
  </enum>
  
  <var name='SYS_NB_DMA_REQ' value='18'/>

    
    <enum name='Sys_Irq_Id'>
        <entry name='SYS_IRQ_TCU0'><comment>System IRQ IDs<br/>Pulse IRQ</comment></entry>
        <entry name='SYS_IRQ_TCU1'/>
        <entry name='SYS_IRQ_FRAME'/>
        <entry name='SYS_IRQ_DMA_TX_SDMMC'/>
        <entry name='SYS_IRQ_DMA_RX_SDMMC'/>
        <entry name='SYS_IRQ_DMA_TX_LCDC'/>
        <entry name='SYS_IRQ_DMA_RX_CAMERA'/>
        <bound name='SYS_NB_IRQ_PULSE'><comment>Number of Pulse IRQ</comment></bound>
        <entry name='SYS_IRQ_COM0'><comment>Level IRQ</comment></entry>
        <entry name='SYS_IRQ_COM1'/>
        <entry name='SYS_IRQ_VOC'/>
        <entry name='SYS_IRQ_DMA'/>
        <entry name='SYS_IRQ_GPIO'/>
        <entry name='SYS_IRQ_KEYPAD'/>
        <entry name='SYS_IRQ_TIMERS'/>
        <entry name='SYS_IRQ_OS_TIMER'/>
        <entry name='SYS_IRQ_CALENDAR'/>
        <entry name='SYS_IRQ_SPI'/>
        <entry name='SYS_IRQ_SPI2'/>
        <entry name='SYS_IRQ_DEBUG_UART'/>
        <entry name='SYS_IRQ_UART'/>
        <entry name='SYS_IRQ_UART2'/>
        <entry name='SYS_IRQ_I2C'/>
        <entry name='SYS_IRQ_SCI'/>
        <entry name='SYS_IRQ_RF_SPI'/>
        <entry name='SYS_IRQ_LPS'/>
        <entry name='SYS_IRQ_BBIFC0'/>
        <entry name='SYS_IRQ_BBIFC1'/>
        <entry name='SYS_IRQ_USBC'/>
        <entry name='SYS_IRQ_LCDC'/>
        <entry name='SYS_IRQ_SDMMC'/>
        <entry name='SYS_IRQ_CAMERA'/>
        <entry name='SYS_IRQ_EXTAPB'/>
        <bound name='SYS_IRQ_QTY'><comment>Number of IRQ handled by the production driver</comment></bound>
        <bound name='SYS_NB_IRQ'><comment>Number of IRQ</comment></bound>
    </enum>
    <var name='SYS_NB_IRQ_LEVEL' value='SYS_NB_IRQ - SYS_NB_IRQ_PULSE'><comment>Number of Level IRQ</comment></var>
    
    <range name='SYS_IRQ_TCU' left='SYS_IRQ_TCU1' right='SYS_IRQ_TCU0'/>
    <range name='SYS_IRQ_COMREG' left='SYS_IRQ_COM1' right='SYS_IRQ_COM0'/>
    
  

  <var name='BB_SRAM_ADDR_WIDTH' value='12'><comment>The Baseband SRam size</comment></var>
  <var name='BB_SRAM_SIZE' value='13*1024'/>

  <var name='BB_NB_BITS_MASTER' value='3'><comment>Baseband Ahb Bus Configuration</comment></var>
  
  <enum name='BB_Master_Id'>
    <entry name='BB_MID_DUMMY'/>
    <entry name='BB_MID_BIST'/>
    <bound name='BB_MID_RR_Start'><comment>After this starts the Round Robib Pool</comment></bound>
    <entry name='BB_MID_VOC'/>
    <entry name='BB_MID_BCPU'/>
    <entry name='BB_MID_AHB2AHB'/>
    <entry name='BB_MID_IFC'/>
    <bound name='BB_MID_RR_End'/>
  </enum>
  <var name='BB_NB_STATIC_MASTER' value='BB_MID_RR_Start-1'/>
  <var name='BB_NB_MASTERS' value='BB_MID_RR_End-1'/>
  <var name='BB_MAX_BURST_SIZE' value='4'/>
  <var name='BB_MAX_BURST_BITS' value='2'/>
  <var name='BB_NB_BITS_SLAVE' value='3'/>
  
  <enum name='BB_slave_Id'>
    <entry name='BB_SID_DUMMY'/>
    <entry name='BB_SID_MEM_BRIDGE'/>
    <entry name='BB_SID_AHB2AHB'/>
    <entry name='BB_SID_IFC'/>
    <entry name='BB_SID_VOC'/>
    <entry name='BB_SID_SRAM'/>
    <bound name='BB_SID_End'/>
  </enum>
  <var name='BB_NB_SLAVES' value='BB_SID_End-1'/>  

  <var name='BB_NB_BITS_PSEL' value='4'><comment>BaseBand Apb Bus Configuration</comment></var>
  <var name='BB_NB_BITS_PADDR' value='12'/>

  <var name='BB_APB_STEP' value='exp2(BB_NB_BITS_PADDR)'/>

  
  <enum name='BB_Module_Id'>
    <entry name='BB_ID_XCOR'/>
    <entry name='BB_ID_IFC'/>
    <entry name='BB_ID_IRQ'/>
    <entry name='BB_ID_ITLV'/>
    <entry name='BB_ID_VITERBI'/>
    <entry name='BB_ID_A5'/>
    <entry name='BB_ID_RF'/>
    <entry name='BB_ID_AIF'/>
    <entry name='BB_ID_CP2'/>
    <entry name='BB_ID_BIST'/>
    <entry name='BB_ID_BCPU_REG'/>
    <entry name='BB_ID_BCPU_TAG'/>
    <entry name='BB_ID_BCPU_IDATA'/>
    <entry name='BB_ID_BCPU_DDATA'/>
    <entry name='BB_ID_COMREGS'/>
    <bound name='BB_NB_PSEL'><comment>The maximum number of slaves is currently 32.</comment></bound>
  </enum>

    
    <enum name='BB_Irq_Id'>
        <entry name='BB_IRQ_TCU0'><comment>Baseband IRQ IDs<br/>Pulse IRQ</comment></entry>
        <entry name='BB_IRQ_TCU1'/>
        <entry name='BB_IRQ_FRAME'/>
        <bound name='BB_NB_IRQ_PULSE'><comment>Number of Pulse IRQ</comment></bound>
        <entry name='BB_IRQ_COM0'><comment>Level IRQ</comment></entry>
        <entry name='BB_IRQ_COM1'/>
        <entry name='BB_IRQ_VOC'/>
        <entry name='BB_IRQ_IFC0'/>
        <entry name='BB_IRQ_IFC1'/>
        <entry name='BB_IRQ_IFC2'/>
        <entry name='BB_IRQ_RF_IF'/>
        <entry name='BB_IRQ_ITLV'/>
        <entry name='BB_IRQ_VITAC'/>
        <entry name='BB_IRQ_XCOR'/>
        <bound name='BB_NB_IRQ'><comment>Number of IRQ</comment></bound>
    </enum>
    <var name='BB_NB_IRQ_LEVEL' value='BB_NB_IRQ - BB_NB_IRQ_PULSE'><comment>Number of Level IRQ</comment></var>

    
    <range name='BB_IRQ_TCU' left='BB_IRQ_TCU1' right='BB_IRQ_TCU0'/>
    <range name='BB_IRQ_COMREG' left='BB_IRQ_COM1' right='BB_IRQ_COM0'/>
    <range name='BB_IRQ_IFC' left='BB_IRQ_IFC2' right='BB_IRQ_IFC0'/>
    


  
  <var name='BB_SYMBOL_SIZE' value='13'><comment>RF Input samples size (signed)</comment></var>
  <var name='VITAC_MULT_SIZE' value='14'><comment>Vitac Multipliers size</comment></var>


</archive>
<archive relative='global_macros.xml' asm='no'>


<cjoker>

#define KSEG0(addr)     ( (addr) | 0x80000000 )
#define KSEG1(addr)     ( (addr) | 0xa0000000 )


/* Define access cached or uncached */
#define MEM_ACCESS_CACHED(addr)     ((UINT32*)((UINT32)(addr)&amp;0xdfffffff))
#define MEM_ACCESS_UNCACHED(addr)   ((UINT32*)((UINT32)(addr)|0x20000000))

/* Register access for assembly */
#define BASE_HI(val) (((0xa0000000 | val) &amp; 0xffff8000) + (val &amp; 0x8000))
#define BASE_LO(val) (((val) &amp; 0x7fff) - (val &amp; 0x8000))


/* to extract bitfield from register value */
#define GET_BITFIELD(dword, bitfield) (((dword) &amp; (bitfield ## _MASK)) &gt;&gt; (bitfield ## _SHIFT))

#define EXP2(n) (1&lt;&lt;(n))

</cjoker>

</archive>
<archive relative='bb_ahb_monitor.xml'>

<module name='bb_ahb_monitor' category='Debug'>
    <reg name='Control' protect='rw'>
        <bits name='Enable' access='rw' rst='0' pos='0'>
            <comment>Enable (start) the Monitor.
            </comment>
        </bits>
        <bits name='Record' access='rw' rst='1' pos='4'>
            <options>
                <option name='Single_Shot' value='0'><comment>Monitor disable itself after the time window expires.</comment></option>
                <option name='Multi_Shot' value='1'/>
            </options>
        </bits>
        <bits name='Accumulation_Mode' access='rw' rst='1' pos='5'>
            <options>
                <option name='Mean' value='0'><comment>get use counter value in the read register, sum the latency and count the number of access</comment></option>
                <option name='Max' value='1'><comment>get maximum of use counter and read register per time window, get maximum of latency per access.</comment></option>
            </options>
        </bits>
        <bits name='Target' access='rw' rst='0' pos='11:8'>
            <comment>Define the element to monitor, it can be the BUS, a master, a slave or a special signal from Debug_Port: Signal_Select1.</comment>
            <options>
                <option name='BB_BUS' value='0'/>
                <option name='BB_IFC' value='1'><comment>Masters</comment></option>
                <option name='VOC' value='2'/>
                <option name='BCPU' value='3'/>
                <option name='BB_AHB2AHB' value='4'/>
                <option name='BB_Mem_Ext' value='5'><comment>Slaves</comment></option>
                <option name='BB_Mem_Int' value='6'/>
                <option name='BB_AHB2AHB_Slave' value='7'/>
                <option name='BB_IFC' value='8'/>
                <option name='BB_VOC_Slave' value='9'/>
                <option name='BB_SRam' value='10'/>
                <option name='Signal_Select1' value='11'><comment>Signal (counted as Slaves, the signal is used as a select signal)</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name='Time_Window' access='rw' rst='1' pos='18:16'>
            <comment>Define the duration af a Time Window</comment>
            <options>
                <option name='TW_1kC' value='0'><comment>1024 System clock cycle</comment></option>
                <option name='TW_32kC' value='1'><comment>32768 System clock cycle</comment></option>
                <option name='TW_1MC' value='2'><comment>1048576 System clock cycle</comment></option>
                <option name='TW_16MC' value='3'><comment>16777216 System clock cycle</comment></option>
                <option name='TW_1F' value='4'><comment>1 Frame (TCU must be running)</comment></option>
                <option name='TW_26F' value='5'><comment>26 Frames (TCU must be running)</comment></option>
                <option name='TW_52F' value='6'><comment>52 Frames (TCU must be running)</comment></option>
                <option name='TW_104F' value='7'><comment>104 Frames (TCU must be running)</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
    </reg>
    <reg name='Access_Count' protect='rw'>
        <bits name='Access_Count' access='r' rst='0' pos='23:0'>
            <comment>Access counter reader (full 24bits view, 8 lower bit are also readable in latency register).
                <br/>
                <br/>For masters: count the number of access
                <br/>For slaves: count the number of access by checking the falling edge of select signal.
            </comment>
        </bits>
    </reg>
    <reg name='Use' protect='rw'>
        <bits name='Use' access='r' rst='0' pos='23:0'>
            <comment>Bus usage counter reader.
                <br/>
                <br/>For the bus: Count the cycles when the bus is used (by any master)
                <br/>For masters: Count cycles when selected master is granted
                <br/>For slaves: Count cycles when select signal is high.
            </comment>
        </bits>
    </reg>
    <reg name='Latency' protect='rw'>
        <bits name='Latency' access='r' rst='0' pos='23:0'>
            <comment>Latency counter reader (0xffffff means overflow)
                <br/>In Max mode, it's updated after each access, else it's adding the latency from all access in the time window
                <br/>For slaves it counts the duration of each access (in mean mode, it will give the same value as Use)
                <br/>
                <br/>For masters: count cycles between rise of request and first access.
                <br/>For slaves: count the duration of access by counting the high cycles. In that case it is equivalent to the use counter except in max mode where it counts the max by access not by time window.
            </comment>
        </bits>
        <bits name='Access_Cnt' access='r' rst='0' pos='31:24'>
            <comment>Number of access (0xff means overflow)
                <br/>In max mode: 0 if no access, 1 if at least 1 access.
                <br/>In mean mode: it counts the number of access during the time window.
                <br/>
                <br/>For masters: count the number of access
                <br/>For slaves: count the number of access by checking the falling edge of select signal.
                <br/>
                <br/>It is the same as the Access_Count register except that the value is saturated on 8 bits. It's repeated here to garanty coherence with Latency to enable calculs of Mean Latency by doing the following operation:
                <br/> Mean_Latency = Latency/Access_Cnt .
            </comment>
        </bits>
    </reg>
</module>
</archive>
<archive relative='bb_cp2.xml'>

<module name='bb_cp2' category='Baseband'>
    <reg name='ctrl' protect='rw'>
        <bits name='First Poly' display='hex' access='rw' rst='111' pos='2:0'>
            <comment>This field is used for setting the first polynomial to encode 
                     or the CRC computation
                    <br/>First polynomial to encode :
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No polynomial code used (input connected to output)
                    <br/>Cyclic code :
                    <br/>000 = D8 + D4 + D3 + D2 + 1
                    <br/>001 = D3 + D + 1
                    <br/>010 = D14 + D13 + D5 + D3 + D2 +1
                    <br/>011 = D6 + D5 + D3 + D2 + D1 + 1
                    <br/>100 = D10 + D8 + D6 + D5 + D4 + D2 + 1
                    <br/>101 = D16 + D12 + D5 + 1
                    <br/>110 = (D23 + 1)*(D17 + D3 + 1)
                    <br/>111 = reserved
            </comment>
        </bits>
        <bits name='Second Poly' display='hex' access='rw' rst='111' pos='5:3'>
            <comment>Second polynomial to encode :
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No polynomial code used (input connected to output)
            </comment>
        </bits>
        <bits name='Third Poly' display='hex' access='rw' rst='111' pos='8:6'>
            <comment>Third polynomial to encode:
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No polynomial code used (input connected to output)
            </comment>
        </bits>
        <bits name='Fourth Poly' display='hex' access='rw' rst='111' pos='11:9'>
            <comment>Fourth polynomial to encode:
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No polynomial code used (input connected to output)
            </comment>
        </bits>
        <bits name='Fith Poly' display='hex' access='rw' rst='111' pos='14:12'>
            <comment>Fith polynomial to encode:
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No polynomial code used (input connected to output)
            </comment>
        </bits>
        <bits name='Sixth Poly' display='hex' access='rw' rst='111' pos='17:15'>
            <comment>Sixth polynomial to encode:
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No polynomial code used (input connected to output)
            </comment>
        </bits>
        <bits name='RSC Poly' display='hex' access='rw' rst='111' pos='20:18'>
            <comment>RSC (Recursive Systematic Convolutional) polynomial code:
                    <br/>000 = G0
                    <br/>001 = G1
                    <br/>010 = G2
                    <br/>011 = G3
                    <br/>100 = G4
                    <br/>101 = G5
                    <br/>110 = G6
                    <br/>111 = No RSC
            </comment>
        </bits>
        <bits name='NB Poly' display='hex' access='rw' rst='111' pos='23:21'>
            <comment>Number of polynomial code to process:
                    <br/>0x0 = 0
                    <br/>0x1 = 1 (First Poly)
                    <br/>0x2 = 2 (First poly and second Poly)
                    <br/>0x3 = 3 (First poly, second poly, third Poly)
                    <br/>0x6 = 6 (first Poly to sixth Poly)
                    <br/>0x7 = reserved
            </comment>
        </bits>
        <bits name='Enable Puncturing' access='rw' rst='1' pos='24'>
            <comment>Enable Puncturing
                    <br/>0 = No puncturing (puncturing disabled)
                    <br/>1 = Enable puncturing
            </comment>
        </bits>
    </reg>
    
    <reg name='bit number' protect='rw'>
        <bits name='Bit number' display='hex' access='rw' rst='0x1FF' pos='8:0'>
            <comment>Number of inputs bits to process
                <br/>0x01 = 1
                <br/>0x02 = 2
                <br/>0x03 = 3
                <br/>...
                <br/>0xFD = 253
                <br/>0xFE = 254
                <br/>0xFF = 255
                <br/>0x100 = 256
                <br/>...
                <br/>0x1BF = 447
                <br/>0x1C0 = 448
            </comment>
        </bits>
    </reg>
    
    <reg name='Status' protect='r'>
        <bits name='Enable' access='r' rst='0' pos='0:0'>
            <comment>When 1 the bb_cp2 is running
            </comment>
        </bits>
    </reg>
    
    <reg name='lram_addr' protect='rw'>
        <bits name='LRAM Address' display='hex' access='rw' rst='0x1F' pos='4:0'>
            <comment>LRAM address for the next access
                <br/>Automatically incremented after each access
            </comment>
        </bits>
        <bits name='LRAM Select' access='rw' rst='0x1' pos='5'>
            <comment>Select LRAM for the next access
                <br/>0 = Puncturing LRAM
                <br/>1 = Data LRAM
            </comment>
        </bits>
    </reg>

    <reg name='CRC code LSB' protect='r'>
        <bits name='CRC code' display='hex' access='r' rst='0xFFFFFFFF' pos='31:0'>
            <comment>CRC code LSB bits
            </comment>
        </bits>
    </reg>

    <reg name='CRC code MSB' protect='r'>
        <bits name='CRC code' display='hex' access='r' rst='0xFF' pos='7:0'>
            <comment>CRC code MSB bits
            </comment>
        </bits>
    </reg>
    
    <hole size='800'/>
    
    <reg name='CP2 Select' protect='rw'>
        <bits name='CP2 Select' access='rw' rst='1' pos='0'>
            <comment>CP2 register access selection bit
                <br/>0= All registers are only accessible through the APB bus
                <br/>1= All registers are only accessible by the BCPU through the CP2 bus
            </comment>
        </bits>
    </reg>

    <reg name='LRAM Data' protect='rw'>
        <bits name='LRAM Data' display='hex' access='rw' rst='no' pos='31:0'>
            <comment>LRAM Data. This register is used for access to the 
                     puncturing LRAM or to the Data LRAM.
                <br/>All access into this register, increment the LRAM_ADDR register.
            </comment>
        </bits>
    </reg>

</module>

<cjoker>
// changing xml generated defines
#undef BB_CP2_ENABLE_PUNCTURING
#undef BB_CP2_LRAM_DATA
#undef BB_CP2_BIT_NUMBER

#define BB_CP2_ENABLE_PUNCTURING(n) (((n)&amp;1)&lt;&lt;24)

/// BB_CP2 address mapping
#define BB_CP2_CTRL                              0
#define BB_CP2_BIT_NUMBER                        1
#define BB_CP2_STATUS                            2
#define BB_CP2_LRAM_ADDR                         3
#define BB_CP2_CRC_CODE_LSB                      4
#define BB_CP2_CRC_CODE_MSB                      5
#define BB_CP2_LRAM_DATA                         0
#define BB_CP2_LRAM_PUNC                         (0&lt;&lt;5)
#define BB_CP2_DATA_LRAM                         (1&lt;&lt;5)

/* BB_CP2 ACCESSES */
// macro for converting a constant to a string
#define CT_CONVERT_TO_STRING(x) #x
// control register -> GPR
#define CT_BB_CP2_RD_CTRL_REG(regaddr, n)       asm volatile("cfc2 %0, $" CT_CONVERT_TO_STRING(regaddr) :"=r"((n)))
//              GPR -> control register
#define CT_BB_CP2_WR_CTRL_REG(regaddr, n)       asm volatile("ctc2 %0, $" CT_CONVERT_TO_STRING(regaddr) ::"r"((n)))
// general register -> GPR
#define CT_BB_CP2_RD_GNRL_REG_GPR(regaddr, n)   asm volatile("mfc2 %0, $" CT_CONVERT_TO_STRING(regaddr) :"=r"((n)))
//              GPR -> general register
#define CT_BB_CP2_WR_GNRL_REG_GPR(regaddr, n)   asm volatile("mtc2 %0, $" CT_CONVERT_TO_STRING(regaddr) ::"r"((n)))
// general register -> memory
#define CT_BB_CP2_RD_GNRL_REG_MEM(regaddr, out)	asm volatile("swc2 $" CT_CONVERT_TO_STRING(regaddr) ", 0(%0)"::"r"((out)))
//           memory -> general register
#define CT_BB_CP2_WR_GNRL_REG_MEM(regaddr, in) 	asm volatile("lwc2 $" CT_CONVERT_TO_STRING(regaddr) ", 0(%0)"::"r"((in)))


</cjoker>

</archive>

<archive relative='bb_ifc.xml'>


<include file='globals.xml'/>

<module name='bb_ifc' category='Baseband'>
  <var name='BB_IFC_ADDR_LEN' value='15'/>

  <var name='BB_IFC_ADDR_ALIGN' value='2'/>

  <var name='BB_IFC_TC_LEN' value='8'/>

  

  <struct name='ch' count='2'>
    <comment>
        The Channel 0 conveys data from the AIF to the memory.<br/>
        The Channel 1 conveys data from the memory to the AIF.
        <br/>These Channels only exist with Voice Option.
    </comment>
    <reg name='control' protect='w'>
      <bits name='enable' access='w' rst='no' pos='0'>
        <comment>Channel Enable, write one in this bit enable the channel.
        <br/>When the channel is enabled, for a peripheral to memory transfer
        the DMA wait request from peripheral to start transfer. </comment>
      </bits>

      <bits name='disable' access='w' rst='no' pos='1'>
        <comment>Channel Disable, write one in this bit disable the channel.
        <br/>When writing one in this bit, the current AHB transfer and
        current APB transfer (if one in progress) is completed and the channel
        is then disabled. </comment>
      </bits>

      <bits name='auto_disable' access='rw' rst='0' pos='4'>
        <comment>Automatic channel Disable. When this bit is set, the channel is automatically disabled at the next interrupt. 
        </comment>
      </bits>
    </reg>

    <reg name='status' protect='r'>
      <bits name='enable' access='r' rst='0' pos='0'>
        <comment>When 1 the channel is enabled</comment>
      </bits>

      <bits name='fifo_empty' access='r' rst='1' pos='4'>
        <comment>When 1 the fifo is empty </comment>
      </bits>

      <bits name='cause_ief' access='r' rst='0' pos='8'>
        <comment>Cause interrupt End of FIFO. </comment>
      </bits>

      <bits name='cause_ihf' access='r' rst='0' pos='9'>
        <comment>Cause interrupt Half of FIFO. </comment>
      </bits>

      <bits name='cause_i4f' access='r' rst='0' pos='10'>
        <comment>Cause interrupt Quarter of FIFO. </comment>
      </bits>
      
      <bits name='cause_i3_4f' access='r' rst='0' pos='11'>
        <comment>Cause interrupt Three Quarter of FIFO. </comment>
      </bits>

      <bits name='ief' access='r' rst='0' pos='16'>
        <comment>End of FIFO interrupt status bit. </comment>
      </bits>

      <bits name='ihf' access='r' rst='0' pos='17'>
        <comment>Half of FIFO interrupt status bit. </comment>
      </bits>

      <bits name='i4f' access='r' rst='0' pos='18'>
        <comment>Quarter of FIFO interrupt status bit. </comment>
      </bits>

      <bits name='i3_4f' access='r' rst='0' pos='19'>
        <comment>Three Quarter of FIFO interrupt status bit.</comment>
      </bits>
    </reg>

    <reg name='start_addr' protect='rw'>
      <bits name='start_addr' display='hex' access='rw' rst='0xFFFFFFFF' pos='NB_BITS_ADDR-1:BB_IFC_ADDR_ALIGN'>
        <comment>AHB Start Address. This field represent the start address of the FIFO located in RAM.
        </comment>
      </bits>
     </reg>

    <reg name='Fifo_Size' protect='rw'>
      <bits name='Fifo_Size' display='hex' access='rw' rst='0xFFF' pos='14:4'>
        <comment>Fifo size in bytes, max 32kBytes.
            <br/>The size of the fifo must be a multiple of 16 (The four LSB are always zero). 
        </comment>
      </bits>
    </reg>

    <hole size='32'/>

    <reg name='int_mask' protect='rw'>
      <bits name='end_fifo' access='rw' rst='0' pos='8'>
        <comment>END FIFO Mask interrupt. When one this interrupt is enabled.
        </comment>
      </bits>

      <bits name='half_fifo' access='rw' rst='0' pos='9'>
        <comment>HALF FIFO Mask interrupt. When one this interrupt is enabled.
        </comment>
      </bits>

      <bits name='quarter_fifo' access='rw' rst='0' pos='10'>
        <comment>QUARTER FIFO Mask interrupt. When one this interrupt is
        enabled. </comment>
      </bits>
      
      <bits name='three_quarter_fifo' access='rw' rst='0' pos='11'>
        <comment>THREE QUARTER FIFO Mask interrupt. When one this interrupt is
        enabled. </comment>
      </bits>
    </reg>

    <reg name='int_clear' protect='rw'>
      <bits name='end_fifo' access='c' rst='0' pos='8'>
        <comment>Write one to clear end of fifo interrupt. </comment>
      </bits>

      <bits name='half_fifo' access='c' rst='0' pos='9'>
        <comment>Write one to clear half of fifo interrupt. </comment>
      </bits>

      <bits name='quarter_fifo' access='c' rst='0' pos='10'>
        <comment>Write one to clear Quarter fifo interrupt. </comment>
      </bits>

      <bits name='three_quarter_fifo' access='c' rst='0' pos='11'>
        <comment>Write one to clear Three Quarter fifo interrupt. </comment>
      </bits>
    </reg>

    <reg name='cur_ahb_addr' protect='r'>
      <bits name='cur_ahb_addr' display='hex' access='r' rst='0' pos='NB_BITS_ADDR-1:0'>
        <comment>Current AHB address value. The nine MSB bit is constant and
        equal to the PAGE_ADDR field in the IFC_CH_AHB_START_ADDR register.
        </comment>
      </bits>
    </reg>
  </struct>

  

  <reg name='ch2_control' protect='w'>
    <bits name='enable' access='w' rst='no' pos='0'>
      <comment>Channel Enable, write one in this bit enable the channel.
      <br/>When the channel is enabled, for a peripheral to memory transfer
      the DMA wait request from peripheral to start transfer. </comment>
    </bits>

    <bits name='disable' access='w' rst='no' pos='1'>
      <comment>Channel Disable, write one in this bit disable the channel.
      <br/>When writing one in this bit, the current AHB transfer and current
      APB transfer (if one in progress) is completed and the channel is then
      disabled.</comment>
    </bits>

    <bits name='burst_size' access='rw' rst='1' pos='16'>
      <comment>Burst size on AHB bus 
        <br/>0 = Single access 
        <br/>1 = burst Access (4 words). 
      </comment>
    </bits>

    <bits name='fifo_mode' access='rw' rst='1' pos='17'>
      <comment>Set FIFO mode . <br/>0 = no fifo mode, transfer stop when the
      current transfer counter reaches zero. Channel must be re-enabled for
      future transfer. <br/>1 = Fifo mode, when the current AHB address
      counter reaches the end address of the FIFO. AHB address counter is
      reloaded with the initial value. In FIFO mode channel is not disabled at
      the end of the transfer.</comment>
    </bits>
  </reg>

  <reg name='ch2_status' protect='r'>
    <bits name='enable' access='r' rst='0' pos='0'>
      <options>
        <option name='DISABLE' value='0'/>

        <option name='ENABLE' value='1'/>

        <default/>
      </options>

      <comment>In no fifo mode the channel is automatically disabled at the
      end of the transfer. In fifo mode the channel is disabled only when
      disabled write is performed in the control register. </comment>
    </bits>

    <bits name='fifo_empty' access='r' rst='1' pos='4'>
      <comment>When 1 the fifo is empty </comment>
    </bits>

    <bits name='cause_itc' access='r' rst='0' pos='8'>
      <comment>Cause interrupt End of TC.</comment>
    </bits>

    <bits name='cause_ief' access='r' rst='0' pos='9'>
      <comment>Cause interrupt End of FIFO. </comment>
    </bits>

    <bits name='cause_ihtc' access='r' rst='0' pos='10'>
      <comment>Cause interrupt Half Transfer Count (This interruption is
      generated when the IFC has transferred 96 word).</comment>
    </bits>

    <bits name='itc' access='r' rst='0' pos='12'>
      <comment>End of TC interrupt status bit. </comment>
    </bits>

    <bits name='ief' access='r' rst='0' pos='13'>
      <comment>End of FIFO interrupt status bit. </comment>
    </bits>

    <bits name='ihtc' access='r' rst='0' pos='14'>
      <comment>Half TC interrupt status bit.</comment>
    </bits>

    <bits name='cur_tc' access='r' rst='0' pos='BB_IFC_TC_LEN-1+16:16'>
      <comment>Current value of transfer counter.</comment>
    </bits>
  </reg>

  <reg name='ch2_start_addr' protect='rw'>
    <bits name='start_addr' display='hex' access='rw' rst='0xFFFFFFFF' pos='BB_IFC_ADDR_LEN-1:BB_IFC_ADDR_ALIGN'>
      <comment>AHB Start Address. This field represent the start address in
      the page. The AHB FIFO start address is the concatenation of of
      Page_ADDR and Start_Addr field. </comment>
    </bits>

    <bits name='page_addr' display='hex' access='rw' rst='0xFFFFFFFF' pos='NB_BITS_ADDR-1:BB_IFC_ADDR_LEN'>
      <comment>AHB PAGE Address. These nine bits is the MSB bit of the start
      AHB FIFO address. These bits are not incremented during the transfer.
      </comment>
    </bits>
  </reg>

  <reg name='ch2_end_addr' protect='rw'>
    <bits name='end_addr' display='hex' access='rw' rst='0xFFFFFFFF' pos='BB_IFC_ADDR_LEN-1:BB_IFC_ADDR_ALIGN'>
      <comment>The last page address of the FIFO, it is the first address not
      used for the FIFO. The start address of the FIFO is specified by the
      register AHB_ADDR and the last page address of the FIFO is specified by
      this field. The size of the fifo (END_ADDR - START_ADDR) must be a
      multiple of burst of 4x32-bits. </comment>
    </bits>
    <bits name='page_addr' display='hex' access='r' rst='0xFFFFFFFF' pos='NB_BITS_ADDR-1:BB_IFC_ADDR_LEN'>
      <comment>AHB PAGE Address read only field. These nine bits is the MSB bit of the start
      AHB FIFO address (copy of the page_addr field of ch2_start_addr register).
      </comment>
    </bits>

  </reg>

  <reg name='ch2_tc' protect='rw'>
    <bits name='tc' display='hex' access='rw' rst='0xFFFFFFFF' pos='BB_IFC_TC_LEN-1:0'>
      <comment>Transfer Count <br/>In no FIFO mode, this bit indicated
      the transfer size in 32-bits word to perform. Up to 255 32-bits word per
      transfer. <br/>In FIFO mode this field define, after how many
      transfer an interrupt in generated.</comment>
    </bits>
  </reg>

  <reg name='ch2_int_mask' protect='rw'>
    <bits name='end_tc' access='rw' rst='0' pos='0'>
      <comment>End TC Mask interrupt. When one this interrupt is
      enabled.</comment>
    </bits>

    <bits name='end_fifo' access='rw' rst='0' pos='1'>
      <comment>END FIFO Mask interrupt. When one this interrupt is enabled.
      </comment>
    </bits>

    <bits name='half_tc' access='rw' rst='0' pos='2'>
      <comment>Half TC Mask interrupt. When one this interrupt is
      enabled</comment>
    </bits>
  </reg>

  <reg name='ch2_int_clear' protect='rw'>
    <bits name='end_tc' access='c' rst='0' pos='0'>
      <comment>Write one for clear end of TC interrupt.</comment>
    </bits>

    <bits name='end_fifo' access='c' rst='0' pos='1'>
      <comment>Write one for clear end of FIFO interrupt.</comment>
    </bits>

    <bits name='half_fifo' access='c' rst='0' pos='2'>
      <comment>Write one for clear end of Half TC interrupt.</comment>
    </bits>
  </reg>

  <reg name='ch2_cur_ahb_addr' protect='r'>
    <bits name='cur_ahb_addr' access='r' rst='0' pos='NB_BITS_ADDR-1:0'>
      <comment>Current AHB address value. The nine MSB bit is constant and
      equal to the PAGE_ADDR field in the IFC_CH_AHB_START_ADDR register.
      </comment>
    </bits>
  </reg>
</module>

</archive>
<archive relative='bb_irq.xml'>


<include file='globals.xml'/>

<module name='bb_irq' category='Baseband'>
    
    
    <enum name='BCPU_Irq_Lines'>
        <entry name='BCpu_Main_Irq_Line'><comment>BCPU Irq Lines</comment></entry>
        
        <entry name='BCpu_Debug_Irq_Line' value='4'/>
        <entry name='BCpu_Host_Irq_Line'/>
    </enum>


    <reg name='Cause' protect='rw'>
        <comment>If cause is not null and interrupt are enabled then the interrupt line 0 is driven on the system CPU.
            <br/>The cause for the Irq sources, one bit for each module's irq source.
            <br/>The cause is the actual Irq source masked by the mask register.
        </comment>
        <bits name='Cause' cut='1' cutprefix='' cutenum='BB_Irq_Id' cutstart='0' access='r' rst='0' pos='BB_NB_IRQ-1:0'/>
    </reg>
    <reg name='Status' protect='rw'>
        <comment>The status for the level Irq sources, one bit for each module's irq source.
            <br/>The status reflect the actual Irq source.
        </comment>
        <bits name='Status' cut='1' cutprefix='' cutenum='BB_Irq_Id' cutstart='0' access='r' rst='0' pos='BB_NB_IRQ-1:0'/>
    </reg>
    <reg name='Mask_Set' protect='rw'>
        <comment>Writing '1' sets the corresponding bit in the mask register to '1'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name='Mask_Set' cut='1' cutprefix='' cutenum='BB_Irq_Id' cutstart='0' access='rs' rst='0' pos='BB_NB_IRQ-1:0'/>
    </reg>
    <reg name='Mask_Clear' protect='rw'>
        <comment>Writing '1' clears the corresponding bit in the mask register to '0'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name='Mask_Clr' cut='1' cutprefix='' cutenum='BB_Irq_Id' cutstart='0' access='rc' rst='0' pos='BB_NB_IRQ-1:0'/>
    </reg>
    <reg name='NonMaskable' protect='rw'>
        <bits name='Main_IRQ' access='r' rst='0' pos='10'>
            <comment>This is the Main Irq source it drive the system CPU interrupt line 0.
                <br/>This bit comes from the modules irq and is masked by the Mask and SC registers.
            </comment>
        </bits>
        
        <bits name='Debug_IRQ' access='rw' rst='0' pos='14'>
            <comment>This is the debug Irq source, the value written here drives the system CPU interrupt line 4.
            </comment>
        </bits>
        <bits name='Host_IRQ' access='r' rst='0' pos='15'>
            <comment>This is the Host Irq source it drive the system CPU interrupt line 5.
                <br/>This bit is controlled by the host internal register.
            </comment>
        </bits>
        <bits name='IntEnable_Status' access='r' rst='1' pos='31'>
            <comment>Status of the Interrupt enable semaphore bit.
            </comment>
        </bits>
   </reg>
    <reg name='SC' protect=''>
        <bits name='IntEnable' access='rw' rst='1' pos='0'>
            <comment>Interrupt enable semaphore, used for critical section.
                <br/>Read returns its value and then clears it to '0' disabling interrupts.
                <br/>Write the read value to restore the previous state, this will exit the critical section.
            </comment>
        </bits>
    </reg>
    <reg name='WakeUp_Mask' protect='rw'>
        <comment>Each bit to '1' in that registers allows the correcponding interrupt to wake up the System CPU (i.e.: Reenable it's clock, see CLOCK_BB_ENABLE and CLOCK_BB_DISABLE registers in general registers section)
        </comment>
        <bits name='WakeUp_Mask' cut='1' cutprefix='' cutenum='BB_Irq_Id' cutstart='0' access='rw' rst='0' pos='BB_NB_IRQ-1:0'/>
    </reg>
    <reg name='Cpu_Sleep' protect='rw'>
        <bits name='Sleep' access='w' rst='0' pos='0'>
            <comment>Writing '1' to this bit will put the BCPU to sleep (i.e.: Disable it's clock, see CLOCK_BB_ENABLE and CLOCK_BB_DISABLE registers in general registers section)
            </comment>
        </bits>
    </reg>
    <reg name='Pulse_Mask_Set' protect='rw'>
        <comment>Writing '1' sets the corresponding bit in the mask register to '1'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name='Pulse_Mask_Set' cut='1' cutprefix='' cutenum='BB_Irq_Id' cutstart='0' access='rs' rst='0' pos='BB_NB_IRQ_PULSE-1:0'/>
    </reg>
    <reg name='Pulse_Mask_Clr' protect='rw'>
        <comment>Writing '1' clears the corresponding bit in the mask register to '0'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name='Pulse_Mask_Clr' cut='1' cutprefix='' cutenum='BB_Irq_Id' cutstart='0' access='rc' rst='0' pos='BB_NB_IRQ_PULSE-1:0'/>
    </reg>
    <reg name='Pulse_Clear' protect='rw'>
        <comment>Writing '1' clears the corresponding Pulse IRQ.
            <br/>Pulse IRQ are set by the modules and cleared here.
        </comment>
        <bits name='Pulse_Clr' cut='1' cutprefix='' cutenum='BB_Irq_Id' cutstart='0' access='c' rst='0' pos='BB_NB_IRQ_PULSE-1:0'/>
    </reg>

</module>

</archive>
<archive relative='bb_sram.xml'>


<include file='globals.xml'/>

<module name='bb_sram' category='Baseband'>

    <memory name='ram_array' size='BB_SRAM_SIZE'>
        <comment>Baseband side internal memory, also used by accelerators.
        </comment>
    </memory>
</module>


</archive>

<archive relative='comregs.xml'>

<module name='comregs' category='Modem'>
    <reg name='Snapshot' protect='r'>
        <bits name='Snapshot' access='r' rst='0' pos='1:0'>
            <comment>Value of snapshots, snapshot value is automatically incremented at frame interrupt. This snapshot counter wrap at the value given by Snapshot_Cfg.
            </comment>
        </bits>
    </reg>
    <reg name='Snapshot_Cfg' protect='rw'>
        <bits name='Snapshot_Cfg' access='rw' rst='2' pos='1:0'>
            <comment>Number of snapshot.
            </comment>
            <options>
                <option name='Wrap_2' value='2'><comment>The snapshot counter as Two values : 0,1.</comment></option>
                <option name='Wrap_3' value='3'><comment>The snapshot counter as Three values : 0,1,2.</comment></option>
            </options>
        </bits>
    </reg>
    <reg name='Cause' protect='rw'>
        <bits name='X_Irq0_Cause' access='r' rst='0' pos='3:0'>
            <comment>When read from the Xcpu, this return the cause of interruption, basically the set/clear register X_Irq0 part masked with X_Irq0_Mask.
                <br/>When read from the Bcpu, returns 0.
            </comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name='X_Irq1_Cause' access='r' rst='0' pos='7:4'>
            <comment>When read from the Xcpu, this return the cause of interruption, basically the set/clear register X_Irq1 part masked with X_Irq1_Mask.
                <br/>When read from the Bcpu, returns 0.
            </comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name='B_Irq0_Cause' access='r' rst='0' pos='11:8'>
            <comment>When read from the Bcpu, this return the cause of interruption, basically the set/clear register B_Irq0 part masked with B_Irq0_Mask.
                <br/>When read from the Xcpu, returns 0.
            </comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name='B_Irq1_Cause' access='r' rst='0' pos='15:12'>
            <comment>When read from the Bcpu, this return the cause of interruption, basically the set/clear register B_Irq1 part masked with B_Irq1_Mask.
                <br/>When read from the Xcpu, returns 0.
            </comment>
            <options><mask/><shift/></options>
        </bits>        
    </reg>
    <reg name='Mask_Set' protect='rw'>
        <bits name='X_Irq0_Mask_Set' access='rs' rst='0' pos='3:0'>
            <comment>When read: returns the value of the X_Irq0_Mask register.
                <br/>When written: value is used as a bit field, each bit at '1' sets the corresponding bit in the X_Irq0_Mask register, bits at '0' leave the corresponding bit unchanged.
                <br/>The X_Irq0_Mask masks the set/clear register to trigger interrupts on the XCPU using line 0.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name='X_Irq1_Mask_Set' access='rs' rst='0' pos='7:4'>
            <comment>When read: returns the value of the X_Irq1_Mask register.
                <br/>When written: value is used as a bit field, each bit at '1' sets the corresponding bit in the X_Irq1_Mask register, bits at '0' leave the corresponding bit unchanged.
                <br/>The X_Irq1_Mask masks the set/clear register to trigger interrupts on the XCPU using line 1.
            </comment>
           <options><mask/><shift/><default/></options>
        </bits>
        <bits name='B_Irq0_Mask_Set' access='rs' rst='0' pos='11:8'>
            <comment>When read: returns the value of the B_Irq0_Mask register.
                <br/>When written: value is used as a bit field, each bit at '1' sets the corresponding bit in the B_Irq0_Mask register, bits at '0' leave the corresponding bit unchanged.
                <br/>The B_Irq0_Mask masks the set/clear register to trigger interrupts on the BCPU using line 0.
            </comment>
        </bits>
        <bits name='B_Irq1_Mask_Set' access='rs' rst='0' pos='15:12'>
            <comment>When read: returns the value of the B_Irq1_Mask register.
                <br/>When written: value is used as a bit field, each bit at '1' sets the corresponding bit in the B_Irq1_Mask register, bits at '0' leave the corresponding bit unchanged.
                <br/>The B_Irq1_Mask masks the set/clear register to trigger interrupts on the BCPU using line 1.
            </comment>
        </bits>
    </reg>
    <reg name='Mask_Clr' protect='rw'>
        <bits name='X_Irq0_Mask_Clr' access='rc' rst='0' pos='3:0'>
            <comment>When read: returns the value of the X_Irq0_Mask register.
                <br/>When written: value is used as a bit field, each bit at '1' clears the corresponding bit in the X_Irq0_Mask register, bits at '0' leave the corresponding bit unchanged.
                <br/>The X_Irq0_Mask masks the set/clear register to trigger interrupts on the XCPU using line 0.
             </comment>
            <options><mask/><shift/><default/></options>
         </bits>
        <bits name='X_Irq1_Mask_Clr' access='rc' rst='0' pos='7:4'>
            <comment>When read: returns the value of the X_Irq1_Mask register.
                <br/>When written: value is used as a bit field, each bit at '1' clears the corresponding bit in the X_Irq1_Mask register, bits at '0' leave the corresponding bit unchanged.
                <br/>The X_Irq1_Mask masks the set/clear register to trigger interrupts on the XCPU using line 1.
             </comment>
             <options><mask/><shift/><default/></options>
        </bits>
        <bits name='B_Irq0_Mask_Clr' access='rc' rst='0' pos='11:8'>
            <comment>When read: returns the value of the B_Irq0_Mask register.
                <br/>When written: value is used as a bit field, each bit at '1' clears the corresponding bit in the B_Irq0_Mask register, bits at '0' leave the corresponding bit unchanged.
                <br/>The B_Irq0_Mask masks the set/clear register to trigger interrupts on the BCPU using line 0.
            </comment>
        </bits>
        <bits name='B_Irq1_Mask_Clr' access='rc' rst='0' pos='15:12'>
            <comment>When read: returns the value of the B_Irq1_Mask register.
                <br/>When written: value is used as a bit field, each bit at '1' clears the corresponding bit in the B_Irq1_Mask register, bits at '0' leave the corresponding bit unchanged.
                <br/>The B_Irq1_Mask masks the set/clear register to trigger interrupts on the BCPU using line 1.
            </comment>
        </bits>
    </reg>
    <reg name='ItReg_Set' protect='rw'>
        <comment>If accesses to ItReg_Set and ItReg_Clr registers are done simultaneously from both CPUs and affecting the same bits, the priority is given to set a bit.</comment>
        <bits name='X_Irq0_Set' access='rs' rst='all1' pos='3:0'>
            <comment>When read, returns the value of the set/clear register.
                <br/>When written, value is used as a bit field, each bit at '1' sets the corresponding bit in the set/clear register, bits at '0' leave the corresponding bit unchanged.
                <br/>These bits can also trigger interrupts on the XCPU if enabled.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name='X_Irq1_Set' access='rs' rst='all1' pos='7:4'>
            <comment>When read, returns the value of the set/clear register.
                <br/>When written, value is used as a bit field, each bit at '1' sets the corresponding bit in the set/clear register, bits at '0' leave the corresponding bit unchanged.
                <br/>These bits can also trigger interrupts on the XCPU if enabled.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name='B_Irq0_Set' access='rs' rst='all1' pos='11:8'>
            <comment>When read, returns the value of the set/clear register.
                <br/>When written, value is used as a bit field, each bit at '1' sets the corresponding bit in the set/clear register, bits at '0' leave the corresponding bit unchanged.
                <br/>These bits can also trigger interrupts on the XCPU if enabled.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name='B_Irq1_Set' access='rs' rst='all1' pos='15:12'>
            <comment>When read, returns the value of the set/clear register.
                <br/>When written, value is used as a bit field, each bit at '1' sets the corresponding bit in the set/clear register, bits at '0' leave the corresponding bit unchanged.
                <br/>These bits can also trigger interrupts on the BCPU if enabled.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bitgroup name='X_Irq'>
            <entry ref='X_Irq0_Set'/>
            <entry ref='X_Irq1_Set'/>
        </bitgroup>
        <bitgroup name='B_Irq'>
            <entry ref='B_Irq0_Set'/>
            <entry ref='B_Irq1_Set'/>
        </bitgroup>
    </reg>
    
    <reg name='ItReg_Clr' protect='rw'>
        <comment>If accesses to ItReg_Set and ItReg_Clr registers are done simultaneously from both CPUs and affecting the same bits, the priority is given to set a bit.</comment>
        <bits name='X_Irq0_Clr' access='rc' rst='all1' pos='3:0'>
            <comment>When read, returns the value of the set/clear register.
                <br/>When written, value is used as a bit field, each bit at '1' clears the corresponding bit in the set/clear register, bits at '0' leave the corresponding bit unchanged.
                <br/>These bits can also trigger interrupts on the XCPU if enabled.
            </comment>
        </bits>
        <bits name='X_Irq1_Clr' access='rc' rst='all1' pos='7:4'>
            <comment>When read, returns the value of the set/clear register.
                <br/>When written, value is used as a bit field, each bit at '1' clears the corresponding bit in the set/clear register, bits at '0' leave the corresponding bit unchanged.
                <br/>These bits can also trigger interrupts on the XCPU if enabled.
            </comment>
        </bits>
        <bits name='B_Irq0_Clr' access='rc' rst='all1' pos='11:8'>
            <comment>When read, returns the value of the set/clear register.
                <br/>When written, value is used as a bit field, each bit at '1' clears the corresponding bit in the set/clear register, bits at '0' leave the corresponding bit unchanged.
                <br/>These bits can also trigger interrupts on the BCPU if enabled.
            </comment>
        </bits>
        <bits name='B_Irq1_Clr' access='rc' rst='all1' pos='15:12'>
            <comment>When read, returns the value of the set/clear register.
                <br/>When written, value is used as a bit field, each bit at '1' clears the corresponding bit in the set/clear register, bits at '0' leave the corresponding bit unchanged.
                <br/>These bits can also trigger interrupts on the BCPU if enabled.
            </comment>
        </bits>

    </reg>
    <reg name='ReqReg_Set' protect='rw'>
        <comment>If accesses to ReqReg_Set and ReqReg_Clr registers are done simultaneously from both CPUs and affecting the same bits, the priority is given to set a bit.</comment>
        <bits name='Request_Set' access='rs' rst='all0' pos='31:0'>
            <comment>When read, returns the value of the set/clear register.
                <br/>When written, value is used as a bit field, each bit at '1' clears the corresponding bit in the set/clear register, bits at '0' leave the corresponding bit unchanged.
            </comment>
        </bits>
    </reg>
    <reg name='ReqReg_Clr' protect='rw'>
        <comment>If accesses to ReqReg_Set and ReqReg_Clr registers are done simultaneously from both CPUs and affecting the same bits, the priority is given to set a bit.</comment>
        <bits name='Request_Clr' access='rc' rst='all1' pos='31:0'>
            <comment>When read, returns the value of the set/clear register.
                <br/>When written, value is used as a bit field, each bit at '1' clears the corresponding bit in the set/clear register, bits at '0' leave the corresponding bit unchanged.
            </comment>
        </bits>
    </reg>
    <reg name='AckReg_Set' protect='rw'>
        <comment>If accesses to AckReg_Set and AckReg_Clr registers are done simultaneously from both CPUs and affecting the same bits, the priority is given to set a bit.</comment>
        <bits name='Acknowledge_Set' access='rs' rst='all0' pos='31:0'>
            <comment>When read, returns the value of the set/clear register.
                <br/>When written, value is used as a bit field, each bit at '1' clears the corresponding bit in the set/clear register, bits at '0' leave the corresponding bit unchanged.
            </comment>
        </bits>
    </reg>
    <reg name='AckReg_Clr' protect='rw'>
        <comment>If accesses to AckReg_Set and AckReg_Clr registers are done simultaneously from both CPUs and affecting the same bits, the priority is given to set a bit.</comment>
        <bits name='Acknowledge_Clr' access='rc' rst='all1' pos='31:0'>
            <comment>When read, returns the value of the set/clear register.
                <br/>When written, value is used as a bit field, each bit at '1' clears the corresponding bit in the set/clear register, bits at '0' leave the corresponding bit unchanged.
            </comment>
        </bits>
    </reg>

</module>
</archive>
<archive relative='bcpu_cache.xml'>

<module name='bcpu_cache' category='Debug'>

    <struct name='Line' count='exp2(6)'>
        <reg name='Data' protect='rw' count='4'>
        <comment>The BCpu cache is accessible only when it is disabled or the cpu is stalled.
            <br/>The bits "9:4" of the address select the line.
            <br/>If the Tag at the corresponding line is valid, the bits "24:10" of the tag are the corresponding address bits.
            <br/>The bits "3:0" of the address select the Data in the line.
        </comment>
            <bits name='data' access='rw' pos='31:0'>
            </bits>
        </reg>
    </struct>
</module>
</archive>
<archive relative='bcpu_tag.xml'>

<module name='bcpu_tag' category='Debug'>

    <reg name='Line' protect='rw' count='exp2(6)'>
        <comment>The BCpu tags are accessible only when the corresponding cache is disabled or the cpu is stalled.
            <br/>The bits "9:4" of the address select the line
        </comment>
        <bits name='Tag' access='rw' pos='24:10'>
            <comment>The Tag represents the bits "24:10" of the address present in the corresponding cache Line.
            </comment>
            <options><default/><shift/><mask/></options>
        </bits>
        <bits name='Valid' access='rw' pos='29'>
            <comment>When 1 the Tag is valid
            </comment>
            <options><default/><shift/><mask/></options>
        </bits>
    </reg>
</module>
</archive>
<archive relative='bist.xml'>

<module name='bist' category='System'>
	<reg name='control' protect='w'>
		<bits name='start' access='w' rst='0x0' pos='0'>
			<comment>Control the Bist: Write 1 to start Bist test.
			</comment>
		</bits>
	</reg>

	<reg name='status' protect='w'>
		<bits name='enable' access='r' rst='0x0' pos='0'>
			<comment>Status of the Bist: 1 if bist module enabled, 0 if disabled.
			</comment>
		</bits>
		<bits name='fail' access='r' rst='0x0' pos='4'>
			<comment>Status of the Bist: 1 if bist module failed, 0 if bist success.
			</comment>
		</bits>		
	</reg>

	<reg name='mem_addr' protect='r/w'>
		<bits name='mem_addr' display='hex' access='r/w' rst='0xFFFFFFFF' pos='24:0'>
			<comment>Memory base address to test.
			</comment>
		</bits>
	</reg>

	<reg name='mem_size' protect='r/w'>
		<bits name='mem_size' display='hex' access='r/w' rst='0xFFFFFFFF' pos='15:0'>
			<comment> Memory size to test.
			</comment>
		</bits>
	</reg>
	<reg name='data_mask' protect='r/w'>
		<bits name='data_mask' display='hex' access='r/w' rst='0xFFFFFFFF' pos='31:0'>
			<comment>Mask memory data for bist comparison.
			</comment>
		</bits>
	</reg>
</module>
</archive>
<archive relative='cipher.xml'>

<module name='cipher' category='Baseband'>
  <reg name='ctrl' protect='rw'>
    <bits name='Enable' access='w' rst='no' pos='0'>
        <comment>
            Writing a '1' in this register triggers an A5 process. Ignored if the module is
            already processing. Auto-reset bit
        </comment>
    </bits>
    <bits name='Algorithm' access='rw' rst='1' pos='4'>
        <comment>Selects the appropriate algorithm
        </comment>
        <options>
            <option name='A5_1' value='0'/>
            <option name='A5_2' value='1'/>
        </options>
    </bits>
  </reg>

  <reg name='status' protect='r'>
    <bits name='Running' access='r' rst='0' pos='0'>
      <comment>1 when running, 0 in other case. </comment>
    </bits>
    <bits name='Data_Blk_Rdy' access='r' rst='0' pos='4'>
        <comment>1 when data block ready (Ciphering processed), reseted when the data register is read.
        </comment>
    </bits>
  </reg>

  <reg name='Kc low' protect='rw'>
    <bits name='Kc_Lsb' display='hex' access='rw' rst='0xFFFFFFFF' pos='31:0'>
      <comment>Cipher key Kc, LSB bit [31:0].</comment>
    </bits>
  </reg>
  
  <reg name='Kc high' protect='rw'>
    <bits name='Kc_Msb' display='hex' access='rw' rst='0xFFFFFFFF' pos='31:0'>
      <comment>Cipher key Kc, MSB bit [31:0].</comment>
    </bits>
  </reg>
  
  <reg name='Count' protect='rw'>
    <bits name='Count' display='hex' access='rw' rst='0x3FFFFFF' pos='21:0'>
      <comment>Count register, this field represent the TDMA frame number.</comment>
    </bits>
  </reg>

  <reg name='Data0_block2' protect='r'>
    <bits name='Data_blk2' access='r' rst='no' pos='31:0'>
      <comment>Data block2 bit[31:0]</comment>
    </bits>
  </reg>

  <reg name='Data1_block2' protect='r'>
      <bits name='Data_blk2' access='r' rst='no' pos='31:0'>
      <comment>Data block2 bit[63:32]</comment>
    </bits>
  </reg>

  <reg name='Data2_block2' protect='r'>
    <bits name='Data_blk2' access='r' rst='no' pos='31:0'>
      <comment>Data block2 bit[95:64]</comment>
    </bits>
  </reg>

  <reg name='Data3_block2' protect='r'>
    <bits name='Data_blk2' access='r' rst='no' pos='17:0'>
      <comment>Data block2 bit[113:96]</comment>
    </bits>
  </reg>

 <struct name='Data_block1' count='29'>
    <reg name='Data block1' protect='r'>
      <bits name='Bit0' access='r' rst='no' pos='7'>
        <comment> </comment>
      </bits>
      <bits name='Bit1' access='r' rst='no' pos='15'>
        <comment> </comment>
      </bits>
      <bits name='Bit2' access='r' rst='no' pos='23'>
        <comment> </comment>
      </bits>
      <bits name='Bit3' access='r' rst='no' pos='31'>
        <comment> </comment>
      </bits>
    </reg>
  </struct>

</module>
</archive>

<archive relative='debug_host.xml'>



<module name='debug_host' category='Debug'>
  <reg name='cmd' protect='r'>
    <bits name='Addr' access='r' rst='-' pos='28:0'>
      <comment>Address of data to be read or written. </comment>
    </bits>

    <bits name='Size' access='r' rst='-' pos='30:29'>
      <comment>These two bits indicates element data size. <br/>
            when "00" = "byte". <br/>
            when "01" = "half word". <br/>
            when "10" = "word". 
        </comment>
    </bits>

    <bits name='Write_H' access='r' rst='-' pos='31'>
      <comment>This bit indicates command is read or write. <br/>
        when "0" = "Read". <br/>
        when "1" = "Write".  
      </comment>
    </bits>

  </reg>

  <reg name='data' protect='rw'>
    <bits name='data' access='rw' rst='-' pos='31:0'>
      <comment>Those bits are data to be read or written by IFC. </comment>
    </bits>
    
  </reg>

  <reg name='event' protect='w'>
    <bits name='event0_sema' access='rw' rst='0' pos='0'>
      <comment>When read, this bit is used for event semaphore. <br/>
            '0' = no new event should be programed. <br/>
            '1' = no pending event, new event is authorised. <br/>
            If host is not enabled, this bit is always '1'. However in this case, 
            any event written will be ignored. <br/>
            When Write, this bit is the least significant bit for a 32-bit event.
      </comment>
    </bits>

    <bits name='event31_1' access='w' rst='-' pos='31:1'>
      <comment> These bits combined with bit0 consists a 32-bit event number. If a
            new event is written before the previous event has been sent, it will 
            be ignored. 
      </comment>
    </bits>
  </reg>

  <reg name='mode' protect='rw'>
    <bits name='force_on' access='rw' rst='0' pos='0'>
      <comment>When '1', force the debug host on, use clock UART if clock host is not
            detected. </comment>
    </bits>

    <bits name='Clk_Host_On' access='r' rst='0' pos='1'>
      <comment>This bit indicates if clock host is detected to be on or not. <br/>
            '0' = no clock host. <br/>
            '1' = clock host detected. </comment>
    </bits>
  </reg>

  <reg name='h2p_status' protect='rw'>
    <bits name='h2p_status' access='r' rst='0' pos='7:0'>
      <comment>Status which can be written through debug uart interface into a debug host
            internal register and read by APB. </comment>
      <options>
        <mask/>
        <shift/>
      </options>
    </bits>
    <bits name='h2p_status_rst' access='w' rst='0' pos='16'>
      <comment>write in this bit will reset h2p status register. </comment>
    </bits>
  </reg>
  
  <reg name='p2h_status' protect='rw'>
    <bits name='p2h_status' access='rw' rst='0' pos='7:0'>
      <comment>Status which can be written by APB and read through debug uart interface 
            as a debug host internal register.
      </comment>
    </bits>
  </reg>
  
  <reg name='irq' protect='wr'>
    <bits name='xcpu_irq' access='rw' rst='0' pos='0'>
      <comment>when write '1', clear the xcpu irq level which is programmed in a debug host
          internal register, this bit is automatic cleared. <br/> when read, get the xcpu
          irq status. </comment>
    </bits>
    
    <bits name='bcpu_irq' access='rw' rst='0' pos='1'>
      <comment>when write '1', clear the bcpu irq level which is programmed in a debug host
            internal register, this bit is automatic cleared.<br/> when read, get the bcpu
            irq status.</comment>
    </bits>
    
  </reg>
</module>



</archive>

<archive relative='debug_host_internals.xml'>




	<module name='debug_host_internal_registers' category='Debug'>
		<ireg name='CTRL_SET' protect='rw'>
			<comment>General control signals set.</comment>
			<bits name='Debug_Reset' rst='0' access='rs' pos='0'>
				<comment>Debug host generated reset. Signal to system control. Active high.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name='XCPU_Force_Reset' rst='0' access='rs' pos='1'>
				<comment>Force XCPU Reset signal. Active high. Hold XCPU in reset state until this bit is cleared.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
			<bits name='Force_Wakeup' rst='0' access='rs' pos='2'>
				<comment>Force wakeup. Active high.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
			<bits name='Force_BP_XCPU' rst='0' access='rs' pos='3'>
				<comment>Force XCPU breakpoint. Active high. Hold its value until this bit is cleared. When Read, Get the status of Force breakpoint sent back by XCPU.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name='Force_BP_BCPU' rst='0' access='rs' pos='4'>
				<comment>Force BCPU breakpoint. Active high. Hold its value until this bit is cleared. When Read, Get the status of Force breakpoint sent back by BCPU.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name='IT_XCPU' rst='0' access='rs' pos='5'>
				<comment>When write '1, generate a level IRQ to XCPU. Write '0 is ignored. This IRQ can be cleared by written APB register. When Read, Get the IRQ status.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name='IT_BCPU' rst='0' access='rs' pos='6'>
				<comment>When write '1', generate a level IRQ to BCPU. Write '0' is ignored. This IRQ can be cleared by written APB register. When Read, Get the IRQ status.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name='Debug_Port_Lock' rst='0' access='rs' pos='7'>
				<comment>Lock Debug port set.<br/>Write '1' to this bit will set it to '1'.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
		</ireg>
		
		<ireg name='CTRL_CLR' protect='rw'>
			<comment>General control signals clear.</comment>		
			<bits name='XCPU_Force_Reset' rst='0' access='rc' pos='1'>
				<comment>Force XCPU Reset signal. Active high. Hold XCPU in reset state until this bit is cleared.<br/>Write '1' to this bit will clear it to '0'.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
			<bits name='Force_Wakeup' rst='0' access='rc' pos='2'>
				<comment>Force wakeup. Active high.<br/>Write '1' to this bit will clear it to '0'.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
			<bits name='Force_BP_XCPU' rst='0' access='rc' pos='3'>
				<comment>Force XCPU breakpoint. Active high. Hold its value until this bit is cleared. When Read, Get the status of Force breakpoint sent back by XCPU.<br/>Write '1' to this bit will clear it to '0'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>	
			<bits name='Force_BP_BCPU' rst='0' access='rc' pos='4'>
				<comment>Force BCPU breakpoint. Active high. Hold its value until this bit is cleared. When Read, Get the status of Force breakpoint sent back by BCPU.<br/>Write '1' to this bit will clear it to '0'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name='Debug_Port_Lock' rst='0' access='rc' pos='7'>
				<comment>Lock Debug port clear.<br/>Write '1' to this bit will clear it to '0'.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>            
		</ireg>

		<ireg name='CLKDIV' protect='rw'>
			<comment>Configure Debug UART Clock divider.</comment>
			<bits name='CFG_CLK' rst='2' access='rw' pos='5:0'>
				<comment>Debug host clock divider. The serial clock is generated by dividing  14,7456MHz Host Clock by (CFG_CLK+2). So By default, the serial clock is 14,7456MHz / (2+2) = 3,6864 MHz which corresponds to the 921,6K Baud-rate.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>
        </ireg>

		<ireg name='CFG' protect='rw'>
			<comment>Configure Debug UART.</comment>
			<bits name='Disable_Uart_H' rst='0' access='rw' pos='0'>
                <comment>When '1', Disable Normal Uart functional group.
                    <br/>This bit is set to '1' when break.
                    <br/>Reseted by signal rst_host_reg.
                </comment>
			</bits>
			<bits name='Disable_IFC_H' rst='0' access='rw' pos='1'>
                <comment>When '1', Ignore IFC write and read access so only debug host internal is accessible.
                    <br/>This bit is set to '1' when break.
                    <br/>Reseted by signal rst_host_reg.
                </comment>
			</bits>
			<bits name='Debug_Port_Sel' rst='0' access='rw' pos='2'>
                <comment>Select the usage of the Debug Port pins
                    <br/>'0' : select Granite Ip Debug port
                    <br/>'1' : select MultiMedia Chip Debug Port
                </comment>
			</bits>
			<bits name='Force_Prio_H' rst='1' access='rw' pos='7'>
				<comment>When '1', force the Debug Uart to have priority on TX.<br/>Reseted by signal rst_host_reg.</comment>
			</bits>	
        </ireg>
        

		<ireg name='CRC' protect='rw'>
			<comment>Status of CRC.</comment>
			<bits name='CRC' rst='0' access='rc' pos='0'>
				<comment>This bit represents that an CRC error has occured in commands received by Debug Host. Once set to '1', it will keep the value until this register is clearred by write '1'.<br/>'0' = no CRC error.<br/>'1' = CRC error.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
			<bits name='FC_Fifo_Ovf' rst='0' access='r' pos='1'>
				<comment>This bit represents if the 16-byte Flow Control FIFO has an overflow error. This status will be kept until a RX break is received.<br/>'0' = no Flow Control Overflow Error.<br/>'1' = Flow Control Overflow Error.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
		</ireg>
			
		<ireg name='H2P_STATUS' protect='rw'>
			<comment>Host write, APB readable register.</comment>
			<bits name='STATUS' rst='0' access='rw' pos='7:0'>
				<comment>These bits can be read by APB and write by host. Corresponds to APB register STATUS. They can also be reseted to zeros by APB command. (see details in debug host APB register mapping) <br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
		</ireg>

		<ireg name='P2H_STATUS' protect='rw'>
			<comment>APB write, Host readable register.</comment>
			<bits name='STATUS' rst='0' access='rw' pos='7:0'>
				<comment>These bits can be written by APB and read by host. Corresponds to APB register STATUS.<br/>Write to Bit 0 can reset the P2H status.<br/>Reseted by signal sys_rst_others (host).</comment>
			</bits>
		</ireg>

		<ireg name='AHB_SYS_MASTER' protect='r'>
			<comment>Debug information of system side AHB bus status.</comment>
			<bits name='SYS_IFC_HMBURSREQ' rst='-' access='r' pos='0'>
				<comment>The bit represent Sys Ifc HMBURSREQ.</comment>
			</bits>
			<bits name='SYS_DMA_HMBURSREQ' rst='-' access='r' pos='1'>
				<comment>The bit represent Dma HMBURSREQ.</comment>
			</bits>
			<bits name='SYS_AHB2AHB_HMBURSREQ' rst='-' access='r' pos='2'>
				<comment>The bit represent Sys Ahb2ahb HMBURSREQ.</comment>
			</bits>
			<bits name='XCPU_HMBRSREQ' rst='-' access='r' pos='3'>
				<comment>The bit represent Xcpu HMBURSREQ.</comment>
			</bits>
			<bits name='SYS_IFC_HMGRANT' rst='-' access='r' pos='4'>
				<comment>The bit represent Sys Ifc HMGRANT.</comment>
			</bits>
			<bits name='SYS_DMA_HMGRANT' rst='-' access='r' pos='5'>
				<comment>The bit represent Dma HMGRANT.</comment>
			</bits>
			<bits name='SYS_AHB2AHB_HMGRANT' rst='-' access='r' pos='6'>
				<comment>The bit represent Sys Ahb2ahb HMGRANT.</comment>
			</bits>
			<bits name='XCPU_HMGRANT' rst='-' access='r' pos='7'>
				<comment>The bit represent Xcpu HMGRANT.</comment>
			</bits>
		</ireg>
	
		<ireg name='AHB_SYS_SLAVE' protect='r'>
			<comment>Debug information of AHB bus status HSEL.</comment>
			<bits name='SYS_MEM_EXT_HSEL' rst='-' access='r' pos='0'>
				<comment>The bit represent Sys MEM_EXT HSEL.</comment>
			</bits>
			<bits name='SYS_MEM_INT_HSEL' rst='-' access='r' pos='1'>
				<comment>The bit represent Sys MEM_INT HSEL.</comment>
			</bits>
			<bits name='SYS_IFC_HSEL' rst='-' access='r' pos='2'>
				<comment>The bit represent Sys Ifc HSEL.</comment>
			</bits>
			<bits name='SYS_AHB2AHB_HSEL' rst='-' access='r' pos='3'>
				<comment>The bit represent Sys Ahb2ahb HSEL.</comment>
			</bits>
			<bits name='SYS_IFC_HSREADY' rst='-' access='r' pos='4'>
				<comment>The bit represent Sys Ifc HSREADY.</comment>
			</bits>
			<bits name='SYS_MEM_HSREADY' rst='-' access='r' pos='5'>
				<comment>The bit represent Sys EBC HSREADY.</comment>
			</bits>
			<bits name='SYS_AHB2AHB_HSREADY' rst='-' access='r' pos='6'>
				<comment>The bit represent Sys Ahb2ahb HSREADY.</comment>
			</bits>
			<bits name='SYS_HREADY' rst='-' access='r' pos='7'>
				<comment>The bit represent Sys HSREADY which is sent to all sys AHB slaves.</comment>
			</bits>
		</ireg>

		<ireg name='AHB_BB_MASTER' protect='r'>
			<comment>Debug information of baseband side AHB bus status.</comment>
			<bits name='BB_IFC_HMBURSREQ' rst='-' access='r' pos='0'>
				<comment>The bit represent BB Ifc HMBURSREQ.</comment>
			</bits>
			<bits name='BB_VOC_HMBURSREQ' rst='-' access='r' pos='1'>
				<comment>The bit represent Voc HMBURSREQ.</comment>
			</bits>
			<bits name='BB_AHB2AHB_HMBURSREQ' rst='-' access='r' pos='2'>
				<comment>The bit represent BB Ahb2ahb HMBURSREQ.</comment>
			</bits>
			<bits name='BCPU_HMBRSREQ' rst='-' access='r' pos='3'>
				<comment>The bit represent Bcpu HMBURSREQ.</comment>
			</bits>
			<bits name='BB_IFC_HMGRANT' rst='-' access='r' pos='4'>
				<comment>The bit represent BB Ifc HMGRANT.</comment>
			</bits>
			<bits name='BB_VOC_HMGRANT' rst='-' access='r' pos='5'>
				<comment>The bit represent Voc HMGRANT.</comment>
			</bits>
			<bits name='BB_AHB2AHB_HMGRANT' rst='-' access='r' pos='6'>
				<comment>The bit represent BB Ahb2ahb HMGRANT.</comment>
			</bits>
			<bits name='BCPU_HMGRANT' rst='-' access='r' pos='7'>
				<comment>The bit represent Bcpu HMGRANT.</comment>
			</bits>
		</ireg>

		<ireg name='AHB_BB_HSREADY' protect='r'>
			<comment>Debug information of AHB bus status HSEL.</comment>
			<bits name='BB_MEM_HSREADY' rst='-' access='r' pos='0'>
				<comment>The bit represent BB MEM HSREADY.</comment>
            </bits>
			<bits name='BB_VOC_HSREADY' rst='-' access='r' pos='1'>
				<comment>The bit represent BB VoC HSREADY.</comment>
			</bits>
			<bits name='BB_SRAM_HSREADY' rst='-' access='r' pos='2'>
				<comment>The bit represent BB Sram HSREADY.</comment>
			</bits>
			<bits name='BB_IFC_HSREADY' rst='-' access='r' pos='3'>
				<comment>The bit represent BB Ifc HSREADY.</comment>
			</bits>
			<bits name='BB_AHB2AHB_HSREADY' rst='-' access='r' pos='4'>
				<comment>The bit represent BB Ahb2ahb HSREADY.</comment>
			</bits>
			<bits name='BB_HREADY' rst='-' access='r' pos='7'>
				<comment>The bit represent BB HREADY which is sent to all BB AHB slaves.</comment>
			</bits>
		</ireg>

		<ireg name='AHB_BB_HSEL' protect='r'>
			<comment>Debug information of AHB bus status HSEL.</comment>
			<bits name='BB_MEM_EXT_HSEL' rst='-' access='r' pos='0'>
				<comment>The bit represent BB MEM_EXT HSEL.</comment>
			</bits>
			<bits name='BB_MEM_INT_HSEL' rst='-' access='r' pos='1'>
				<comment>The bit represent BB MEM_INT HSEL.</comment>
			</bits>
			<bits name='BB_VOC_HSEL' rst='-' access='r' pos='2'>
				<comment>The bit represent BB VOC HSEL.</comment>
			</bits>
			<bits name='BB_SRAM_HSEL' rst='-' access='r' pos='3'>
				<comment>The bit represent BB Sram HSEL.</comment>
			</bits>
			<bits name='BB_IFC_HSEL' rst='-' access='r' pos='4'>
				<comment>The bit represent BB Ifc HSEL.</comment>
			</bits>
			<bits name='BB_AHB2AHB_HSEL' rst='-' access='r' pos='5'>
				<comment>The bit represent BB Ahb2ahb HSEL.</comment>
			</bits>
		</ireg>

        
	</module>

</archive>

<archive relative='debug_uart.xml'>

<module name='debug_uart' category='System'>
  <var name='DEBUG_UART_RX_FIFO_SIZE' value='16'/>
  <var name='DEBUG_UART_TX_FIFO_SIZE' value='16'/>
  
  <reg name='ctrl' protect='rw'>
    <bits name='Enable' access='rw' rst='0' pos='0'>
      <options>
        <option name='DISABLE' value='0'/>

        <option name='ENABLE' value='1'/>

        <default/>
      </options>

      <comment>Allows to turn off the UART:<br/>0 = Disable<br/>1 = Enable
      </comment>
    </bits>

    <bits name='Data Bits' access='rw' rst='0' pos='1'>
      <options>
        <option name='7_BITS' value='0'/>

        <option name='8_BITS' value='1'/>

        <default/>
      </options>

      <comment>Number of data bits per character (least significant bit
          first):<br/>0 = 7 bits<br/>1 = 8 bits <br/> This bit will be masked to
          '1' if debug host is enabled. </comment>
    </bits>

    <bits name='Tx Stop Bits' access='rw' rst='0' pos='2'>
      <options>
        <option name='1_BIT' value='0'/>

        <option name='2_BITS' value='1'/>

        <default/>
      </options>

      <comment>Stop bits controls the number of stop bits transmitted. Can
      receive with one stop bit (more inaccuracy can be compensated with two
      stop bits when divisor mode is set to 0).<br/>0 = one stop bit is
      transmitted in the serial data.<br/>1 = two stop bits are generated and
      transmitted in the serial data out. <br/> This bit will be masked to
      '0' if debug host is enabled. </comment>
    </bits>

    <bits name='Parity Enable' access='rw' rst='0' pos='3'>
      <options>
        <option name='NO' value='0'/>

        <option name='YES' value='1'/>

        <default/>
      </options>

      <comment> Parity is enabled when this bit is set. <br/> This bit will be masked to
      '0' if debug host is enabled. </comment>
    </bits>

    <bits name='Parity Select' access='rw' rst='0' pos='5:4'>
      <options>
        <option name='ODD' value='0'/>

        <option name='EVEN' value='1'/>

        <option name='SPACE' value='2'/>

        <option name='MARK' value='3'/>

        <default/>
      </options>

      <comment> Controls the parity format when parity is enabled:<br/>00 =
      an odd number of received 1 bits is checked, or transmitted (the parity
      bit is included).<br/>01 = an even number of received 1 bits is checked
      or transmitted (the parity bit is included).<br/>10 = a space is
      generated and received as parity bit.<br/>11 = a mark is generated and
      received as parity bit. <br/> These bit will be ignored if debug host is
      enabled. </comment>
    </bits>

    <bits name='Tx Break Control' access='rw' rst='0' pos='6'>
      <comment> Sends a break signal by holding the Uart_Tx line low until
          this bit is cleared.<br/> This bit will be masked to '0' if debug host
          is enabled. </comment>
      <options>
        <option name='OFF' value='0'/>
        <option name='ON' value='1'/>
        <default/>
      </options>
    </bits>

    <bits name='Rx Fifo Reset' access='rw' rst='0' pos='7'>
      <comment> Writing a 1 to this bit resets and flushes the Receive Fifo.
      This bit does not need to be cleared. </comment>
    </bits>

    <bits name='Tx Fifo Reset' access='rw' rst='0' pos='8'>
      <comment> Writing a 1 to this bit resets and flushes the Transmit Fifo.
      This bit does not need to be cleared. </comment>
    </bits>

    <bits name='DMA Mode' access='rw' rst='0' pos='9'>
      <options>
        <option name='DISABLE' value='0'/>

        <option name='ENABLE' value='1'/>

        <default/>
      </options>

      <comment>Enables the DMA signaling for the Uart_Dma_Tx_Req_H and
      Uart_Dma_Rx_Req_H to the IFC. </comment>
    </bits>

    <bits name='Tx Finish n Wait' access='rw' rst='0' pos='19'>
      <comment>When this bit is set the Tx engine terminates to send the
      current byte and then it stops to send data.</comment>
    </bits>

    <bits name='Divisor Mode' access='rw' rst='0' pos='20'>
      <comment>Selects the divisor value used to generate the baud rate
      frequency (BCLK) from the SCLK (see UART Operation for details). If IrDA
      is enable, this bit is ignored and the divisor used will be 16.<br/>0 =
      (BCLK = SCLK / 4)<br/>1 = (BCLK = SCLK / 16) <br/> This bit will be
      masked to '0' if debug host is enabled.</comment>
    </bits>

    <bits name='IrDA Enable' access='rw' rst='0' pos='21'>
      <comment>When set, the UART is in IrDA mode and the baud rate divisor
      used is 16 (see UART Operation for details). <br/> This bit will be
      masked to '0' if debug host is enabled. </comment>
    </bits>

    <bits name='Rx RTS' access='rw' rst='0' pos='22'>
      <comment>Controls the Uart_RTS output (not directly in auto flow control
      mode).<br/>0 = the Uart_RTS will be inactive high<br/>1 = the Uart_RTS
      will be active low <br/> This bit will be masked to '1' if debug host is
      enabled. </comment>
      <options>
        <option name='INACTIVE' value='0'/>
        <option name='ACTIVE' value='1'/>
        <default/>
      </options>
    </bits>

    <bits name='Auto Flow Control' access='rw' rst='0' pos='23'>
      <options>       
        <option name='ENABLE' value='1'/>
        
        <option name='DISABLE' value='0'/>
        
        <default/>
      </options>
      <comment>Enables the auto flow control. Uart_RTS is controlled by the Rx
      RTS bit and masked by the UART Auto Control Flow System. If Uart_CTS
      become inactive high, the Tx data flow is stopped. <br/> This bit will be
      masked to '1' if debug host is enabled.</comment>
    </bits>

    <bits name='Loop Back Mode' access='rw' rst='0' pos='24'>
      <comment>When set, data on the Uart_Tx line is held high, while the
      serial output is looped back to the serial input line, internally. In
      this mode all the interrupts are fully functional. This feature is used
      for diagnostic purposes. Also, in loop back mode, the modem control
      input Uart_CTS is disconnected and the modem control output Uart_RTS are
      looped back to the inputs, internally. In IrDA mode, Uart_Tx signal is
      inverted (see IrDA SIR Mode Support). </comment>
    </bits>

    <bits name='Rx Lock Err' access='rw' rst='0' pos='25'>
      <comment>Allow to stop the data receiving when an error is detected
      (framing, parity or break). The data in the fifo are kept. <br/> This bit 
      will be masked to '0' if debug host is enabled. </comment>
      <options>
        <option name='DISABLE' value='0'/>
        <option name='ENABLE' value='1'/>
        <default/>
      </options>
    </bits>

    <bits name='Rx Break Length' access='rw' rst='0xF' pos='31:28'>
      <comment>Length of a break, in number of bits. <br/> This bit will be masked
      to "1011" if debug host is enabled. </comment>
    </bits>
  </reg>

  <reg name='status' protect='r'>
    <bits name='Rx Fifo Level' access='r' rst='0' pos='4:0'>
        <options>
            <mask/>
            <shift/>
        </options>
    <comment>Those bits indicate the number of data available in the Rx
      Fifo. Those data can be read. </comment>
    </bits>

    <bits name='Tx Fifo Level' access='r' rst='0' pos='12:8'>
         <options>
            <mask/>
            <shift/>
        </options>
      <comment>Those bits indicate the number of data available in the Tx
      Fifo. Those data will be sent. </comment>
    </bits>

    <bits name='Tx Active' access='r' rst='0' pos='13'>
      <comment>This bit indicates that the UART is sending data. If no data is
      in the fifo, the UART is currently sending the last one through the
      serial interface. </comment>
    </bits>

    <bits name='Rx Active' access='r' rst='0' pos='14'>
      <comment>This bit indicates that the UART is receiving a byte.
      </comment>
    </bits>

    <bits name='Rx Overflow Err' access='r' rst='0' pos='16'>
      <comment>This bit indicates that the receiver received a new character
      when the fifo was already full. The new character is discarded. This bit
      is cleared when the UART_STATUS register is written with any value.
      </comment>
    </bits>

    <bits name='Tx Overflow Err' access='r' rst='0' pos='17'>
      <comment>This bit indicates that the user tried to write a character when fifo was
          already full. The written data will not be kept. This bit is cleared when 
          the UART_STATUS register is written with any value. </comment>
    </bits>

    <bits name='Rx Parity Err' access='r' rst='0' pos='18'>
      <comment>This bit is set if the parity is enabled and a parity error
      occurred in the received data. This bit is cleared when the UART_STATUS
      register is written with any value. </comment>
    </bits>

    <bits name='Rx Framing Err' access='r' rst='0' pos='19'>
      <comment>This bit is set whenever there is a framing error occured. A
      framing error occurs when the receiver does not detect a valid STOP bit
      in the received data. This bit is cleared when the UART_STATUS register
      is written with any value. </comment>
    </bits>

    <bits name='Rx Break Int' access='r' rst='0' pos='20'>
      <comment>This bit is set whenever the serial input is held in a logic 0
      state for longer than the length of x bits, where x is the value
      programmed Rx Break Length. A null word will be written in the Rx Fifo.
      This bit is cleared when the UART_STATUS register is written with any
      value. </comment>
    </bits>

    <bits name='Tx DCTS' access='r' rst='0' pos='24'>
      <comment>This bit is set when the Uart_CTS line changed since the last
      time this register has been written. This bit is cleared when the
      UART_STATUS register is written with any value. </comment>
    </bits>

    <bits name='Tx CTS' access='r' rst='0' pos='25'>
      <comment>Complement of the current value of the Uart_CTS line.
      </comment>
    </bits>

    <bits name='Tx Fifo Rsted L' access='r' rst='0' pos='28'>
      <comment>This bit is set when Tx Fifo Reset command is received by CTRL
      register and is cleared when Tx fifo reset process has finished.      
      </comment>
    </bits>

    <bits name='Rx Fifo Rsted L' access='r' rst='0' pos='29'>
      <comment>This bit is set when Rx Fifo Reset command is received by CTRL
      register and is cleared when Rx fifo reset process has finished.      
      </comment>
    </bits>
    
    <bits name='Enable n finished' access='r' rst='0' pos='30'>
      <comment>This bit is set when bit enable is changed from '0' to '1' or 
      from '1' to '0', it is cleared when the enable process has finished.      
      </comment>
    </bits>
    
    <bits name='Clk Enabled' access='r' rst='0' pos='31'>
      <comment>This bit is set when Uart Clk has been enabled and received by
      UART after Need Uart Clock becomes active. It serves to avoid enabling
      Rx RTS too early.</comment>
    </bits>
  </reg>

  <reg name='rxtx_buffer' protect='--'>
    <bits name='Rx Data' access='r' rst='no' pos='7:0'>
      <comment>The UART_RECEIVE_BUFFER register is a read-only register that
      contains the data byte received on the serial input port. This register
      accesses the head of the receive FIFO. If the receive FIFO is full and
      this register is not read before the next data character arrives, then
      the data already in the FIFO will be preserved but any incoming data
      will be lost. An overflow error will also occur. </comment>
    </bits>

    <bits name='Tx Data' access='w' rst='no' pos='7:0'>
      <comment>The UART_TRANSMIT_HOLDING register is a write-only register
      that contains data to be transmitted on the serial output port. 16
      characters of data may be written to the UART_TRANSMIT_HOLDING register
      before the FIFO is full. Any attempt to write data when the FIFO is full
      results in the write data being lost. </comment>
    </bits>
  </reg>

  <reg name='irq_mask' protect='rw'>
    <bits name='Tx Modem Status' access='rw' rst='0' pos='0'>
      <comment>Clear to send signal change detected. </comment>
    </bits>

    <bits name='Rx Data Available' access='rw' rst='0' pos='1'>
      <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level). </comment>
    </bits>

    <bits name='Tx Data Needed' access='rw' rst='0' pos='2'>
      <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level). </comment>
    </bits>

    <bits name='Rx Timeout' access='rw' rst='0' pos='3'>
      <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time. </comment>
    </bits>

    <bits name='Rx Line Err' access='rw' rst='0' pos='4'>
      <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt. </comment>
    </bits>

    <bits name='Tx Dma Done' access='rw' rst='0' pos='5'>
      <comment>Pulse detected on Uart_Dma_Tx_Done_H signal. </comment>
    </bits>

    <bits name='Rx Dma Done' access='rw' rst='0' pos='6'>
      <comment>Pulse detected on Uart_Dma_Rx_Done_H signal. </comment>
    </bits>

    <bits name='Rx Dma Timeout' access='rw' rst='0' pos='7'>
      <comment>In DMA mode, there is at least 1 character that has been read 
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters 
            in or out of the Rx Fifo during the last 4 character times.</comment>
    </bits>
  </reg>

  <reg name='irq_cause' protect='rw'>
    <bits name='Tx Modem Status' access='r' rst='0' pos='0'>
      <comment>Clear to send signal detected. Reset control: This bit is
      cleared when the UART_STATUS register is written with any value.
      </comment>
    </bits>

    <bits name='Rx Data Available' access='r' rst='0' pos='1'>
      <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level). Reset control: Reading the UART_RECEIVE_BUFFER
      until the Fifo drops below the trigger level. </comment>
    </bits>

    <bits name='Tx Data Needed' access='r' rst='0' pos='2'>
      <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level). Reset control: Writing into UART_TRANSMIT_HOLDING
      register above threshold level. </comment>
    </bits>

    <bits name='Rx Timeout' access='r' rst='0' pos='3'>
      <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time. Reset control: Reading from the UART_RECEIVE_BUFFER register.
      </comment>
    </bits>

    <bits name='Rx Line Err' access='r' rst='0' pos='4'>
      <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt. Reset control: This bit is cleared when the UART_STATUS
      register is written with any value. </comment>
    </bits>

    <bits name='Tx Dma Done' access='rw' rst='0' pos='5'>
      <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Tx_Done_H signal. Reset control: Write one in this register.
      </comment>
    </bits>

    <bits name='Rx Dma Done' access='rw' rst='0' pos='6'>
      <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Rx_Done_H signal. Reset control: Write one in this register.
      </comment>
    </bits>

    <bits name='Rx Dma Timeout' access='rw' rst='0' pos='7'>
        <comment>In DMA mode, there is at least 1 character that has been read 
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters 
            in or out of the Rx Fifo during the last 4 character times.</comment>
    </bits>

    <bits name='Tx Modem Status U' access='r' rst='0' pos='16'>
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits name='Rx Data Available U' access='r' rst='0' pos='17'>
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits name='Tx Data Needed U' access='r' rst='0' pos='18'>
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits name='Rx Timeout U' access='r' rst='0' pos='19'>
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits name='Rx Line Err U' access='r' rst='0' pos='20'>
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits name='Tx Dma Done U' access='r' rst='0' pos='21'>
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits name='Rx Dma Done U' access='r' rst='0' pos='22'>
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits name='Rx Dma Timeout U' access='r' rst='0' pos='23'>
      <comment>Same as previous, not masked. </comment>
    </bits>
  </reg>

  <reg name='triggers' protect='rw'>
    <bits name='Rx Trigger' access='rw' rst='0' pos='3:0'>
      <comment>Defines the threshold level at which the Data Available
      Interrupt will be generated. <br/>The Data Available interrupt is
      generated when quantity of data in Rx Fifo &gt; Rx Trigger.</comment>
    </bits>

    <bits name='Tx Trigger' access='rw' rst='0' pos='7:4'>
      <comment>Defines the threshold level at which the Data Needed
      Interrupt will be generated.<br/>The Data Needed Interrupt is generated
      when quantity of data in Tx Fifo &lt;= Tx Trigger.</comment>
    </bits>

    <bits name='AFC Level' access='rw' rst='0' pos='11:8'>
      <comment>Controls the Rx Fifo level at which the Uart_RTS Auto Flow
      Control will be set inactive high (see UART Operation for more details
      on AFC).<br/>The Uart_RTS Auto Flow Control will be set inactive high
      when quantity of data in Rx Fifo &gt; AFC Level.</comment>
    </bits>
  </reg>
</module>
</archive>

<archive relative='dma.xml'>

<module name='dma' category='System'>
  <reg name='get_channel' protect='r'>
    <bits name='Get Channel' access='r' rst='0' pos='0'>
      <comment>Returns 1 and locks the DMA channel for a transaction if it is
      available. Else returns 0. <br/>Clear the transfer done interrupt
      status. </comment>
    </bits>
  </reg>

  <reg name='status' protect='r'>
    <bits name='Enable' access='r' rst='0' pos='0'>
      <comment>Status of the DMA: 1 if enabled, 0 if disabled. </comment>
    </bits>

    <bits name='Int Done Cause' access='r' rst='0' pos='1'>
      <comment>Cause of the interrupt. This bit is set when the transfer is
      done and the interrupt mask bit is set. <br/>Write one in the Int Clear
      or write 0 in Enable control bits to clear Int Done Cause bit.
      </comment>
    </bits>

    <bits name='Int Done Status' access='r' rst='0' pos='2'>
      <comment>Status of the interrupt. Status of the transfer: 1 if the
      transfer is finished, 0 if it is not finished. <br/>Write one in the
      Int Clear or write 0 in Enable control bits to clear Int Done Status
      bit. </comment>
    </bits>

    <bits name='Channel Lock' access='r' rst='0' pos='4'>
      <comment>Actual status of channel lock. Channel is unlocked at the end
      of transaction or when the DMA is disabled. </comment>
    </bits>
  </reg>

  <reg name='control' protect='rw'>
    <bits name='Enable' access='rw' rst='0' pos='0'>
      <comment>Controls the DMA. Write 1 to enable the DMA, write 0 to disable
      it. When 0 is written in this register, the Int Done Status and Cause
      bits are reset. </comment>
    </bits>

    <bits name='Int Done Mask' access='rw' rst='0' pos='1'>
      <comment>End of transfer interrupt generation. When 1, the DMA will send
      an interrupt at transaction completion. </comment>
      <options>
        <shift/>
      </options>  
    </bits>

    <bits name='Int Done Clear' access='rw' rst='0' pos='2'>
      <comment>Clear the transfer done interruption (this will clear Int Done
      Status and Int Done Cause). <br/>This bit is auto-clear. You will
      always read 0 here. </comment>
    </bits>

    <bits name='Use Pattern' access='rw' rst='0' pos='4'>
      <comment>If this bit is set, the source address will be ignored and the
      memory will be fill with the value of the pattern register. </comment>
    </bits>

    <bits name='Stop Transfer' access='w' rst='0' pos='8'>
      <comment>The DMA stop the current transfer and flush his FIFO (write
      only bit). When the FIFO is empty and last write performed, the DMA is
      disabled and available for a next transfer. The number of bytes copied
      is readable on DMA_XFER_SIZE register.</comment>
    </bits>

    <bits name='GEA Enable' access='rw' rst='0' pos='12'>
      <options>
        <option name='DMA' value='0'/>

        <option name='GEA' value='1'/>

        <default/>
      </options>

      <comment>Enable Gea process when 1.</comment>
    </bits>

    <bits name='GEA Algorithm' access='rw' rst='1' pos='13'>
      <options>
        <option name='GEA1' value='0'/>

        <option name='GEA2' value='1'/>

        <default/>
      </options>

      <comment>This field sets the type of GEA algorithm to process.</comment>
    </bits>

    <bits name='GEA Direction' access='rw' rst='1' pos='14'>
      <options>
        <shift/>
      </options>
      <comment>This field selects the Direction in the GEA algorithm.
      </comment>
    </bits>

    <bits name='FCS Enable' access='rw' rst='0' pos='16'>
      <options>
        <option name='NORMAL_DMA' value='0'/>

        <option name='FCS_PROCESS' value='1'/>

        <default/>
      </options>

      <comment>Enable FCS process when 1.</comment>
    </bits>

    <bits name='Dst Addr Mgt' access='rw' rst='0' pos='21:20'>
      <options>
        <option name='NORMAL_DMA' value='0'/>

        <option name='CONST_ADDR' value='1'/>

        <option name='ALTERN_ADDR' value='2'/>

        <option name='RESERVED' value='3'/>

        <default/>
      </options>

      <comment>Destination address management.<br/>00 : Normal DMA operation,
      DMA_DST_ADDR register define the destination address.<br/> 01 : DMA
      write address is constant (no incremented) and defined by the
      DMA_DST_ADDR register. All data write are in 16-bit.<br/> 10 : DMA
      write address is alternatively defined by DMA_DST_ADDR and
      DMA_SD_DST_ADDR registers. All data write are in 16-bit. <br/>In this
      configuration, DMA write operation is alternatively: <br/>DMA_DST_ADDR
      &lt;= DMA_PATTERN register <br/>DMA_SD_DST_ADDR &lt;=
      Data[DMA_SRC_ADDR] <br/>11 : reserved </comment>
    </bits>
  </reg>

  <reg name='src_addr' protect='rw'>
    <bits name='Src Address' access='rw' rst='0xFFFFFFFF' pos='31:0'>
      <comment>Source start read byte address. When a transfer is stalled by
      the Stop_Transfer bit, this register give the next current source
      address, which is directly the value to re-program to complete the
      transfer stopped.</comment>
    </bits>
  </reg>

  <reg name='dst_addr' protect='rw'>
    <bits name='Dst Address' access='rw' rst='0xFFFFFFFF' pos='31:0'>
      <comment>Destination start read byte address. When a transfer is stalled
      by the Stop_Transfer bit, this register give the next current
      destination address, which is directly the value to re-program to
      complete the transfer stopped.</comment>
    </bits>
  </reg>

  <reg name='sd_dst_addr' protect='rw'>
    <bits name='Sd Dst Address' access='rw' rst='0xFFFFFFFF' pos='31:0'>
      <comment>Second destination address. This register is only used when
      Dst_Address_Mgt=10.</comment>
    </bits>
  </reg>

  <reg name='xfer_size' protect='rw'>
    <bits name='Transfer Size' access='rw' rst='0xFFFFFFFF' pos='15:0'>
      <comment>Transfer size in bytes. Maximum: 65335 bytes. When a transfer
      is stopped by the Stop_Transfer bit, this register give the number of
      remainder bytes to transfer.</comment>
    </bits>
  </reg>

  <reg name='pattern' protect='rw'>
    <bits name='Pattern' access='rw' rst='0xFFFFFFFF' pos='31:0'>
      <comment>Value taken to fill the memory when the configuration bit Use
      Pattern is set. When the pattern mode is used the destination address
      must be 32-bit aligned and the transfer size multiple of 4. when
      Dst_Address_Mgt=10 Pattern is the data written at the address given by
      the Dst_Address register.</comment>
    </bits>
  </reg>

  <reg name='gea_kc_low' protect='rw'>
    <bits name='KC_LSB' access='rw' rst='0xFFFFFFFF' pos='31:0'>
      <comment>GEA key Kc, LSB bit [31:0]. </comment>
    </bits>
  </reg>

  <reg name='gea_kc_high' protect='rw'>
    <bits name='KC_MSB' access='rw' rst='0xFFFFFFFF' pos='31:0'>
      <comment>GEA key Kc, MSB bit [31:0]. </comment>
    </bits>
  </reg>

  <reg name='gea_messkey' protect='rw'>
    <bits name='MessKey' access='rw' rst='0xFFFFFFFF' pos='31:0'>
      <comment>MessKey (Input) register. </comment>
    </bits>
  </reg>

  <reg name='fcs' protect='r'>
    <bits name='FCS' access='r' rst='0' pos='23:0'>
      <comment>Frame Check Sequence.</comment>
    </bits>

    <bits name='FCS Correct' access='r' rst='0' pos='31'>
      <comment>The FCS is correct in reception when the final remainder is
      equal to C(x)= x^22 + x^21 + x^19 + x^18 + x^16 + x^15 + x^11 + x^8 +
      x^5 + x^4</comment>
    </bits>

    
  </reg>
</module>
</archive>
<archive relative='granite_ip_config.xml'>

    <var name='IP_NAME' strvalue='granite_ip' value='0'>
        <comment>granite_ip</comment>
    </var>

    <var name='TECHNO' strvalue='artisan_sage_x_tsmc0_18' value='0'>
        <comment>artisan_sage_x_tsmc0_18</comment>
    </var>

    <var name='FPGA_OPTION' value='0'>
        <comment>0= chip option; 1= FPGA option
        </comment>
    </var>

    <var name='BB_OPTION' value='1'>
        <comment>0= no baseband; 1= baseband included
        </comment>
    </var>




    
    <var name='MUX_MM_DEBUG_PORT' value='0'>
        <comment>0= no mux as on test chip; 1=mux for MultiMedia debug port part
        </comment>
    </var>

    <var name='ANALOG_OPTION' value='1'>
        <comment>0= No analog; 1= Acco option or FPGA wrappers if FPGA_OPTION=1
        </comment>
    </var>

    <var name='PLL_RATE_OPTION' value='3'>
        <comment>acco or frequency of the provided external clock:
            <br/>0= acco 156M, run up to 78 ; 1= 156M, run up to 78 ; 2=312M, run up to 104M
        </comment>
    </var>

    <var name='FAST_CLOCK_156M' value='156000000'/>
    <var name='FAST_CLOCK_312M' value='312000000'/>
    <var name='FAST_CLOCK_PLL' value='FAST_CLOCK_156M'><comment>Fast clock from the Pll.</comment></var>

                                                 
    <var name='VOC_OPTION' value='1'>
        <comment>0= No VOC ; 1= VOC included
        </comment>
    </var>

    <var name='AIF_OPTION' value='1'>
        <comment>0= No aif channels (0,1) ; 1= All 3 channels
        </comment>
    </var>

    <var name='AUBYPASS_OPTION' value='0'/>

    <var name='MMI_OPTION' value='1'>
        <comment>0= No MMI ; 1= MMI included : keypad, PWL/PWT, calendar
        </comment>
    </var>

    <var name='NB_GPIO' value='32'>
        <comment>GPIO/GPO OPTIONS: numbers
        </comment>
    </var>
    <var name='NB_GPIO_INT' value='8'/>
    <var name='NB_GPO' value='11'/>

    <var name='DMA_OPTION' value='1'>
        <comment>0= No DMA ; 1= DMA included
        </comment>
    </var>



    <var name='USB_OPTION' value='1'>
        <comment>0 = no USB; 1 = USB included 
        </comment>
    </var>

    <var name='SYS_IFC_NB_STD_CHANNEL' value='7'>
        <comment>System Ifc Number of generic channel (range 2 to 7)
        </comment>
    </var>


    <var name='LCD_OPTION' value='1'>
        <comment>0 = no LCDC; 1 = LCDC included 
        </comment>
    </var>

    <var name='UART2_OPTION' value='1'>
        <comment>0 = no UART2; 1 = UART2 included 
        </comment>
    </var>

    <var name='SPI_NB_CS' value='3'>
        <comment>number of SPI CS
        </comment>
    </var>

    <var name='SPI2_OPTION' value='1'>
        <comment>0 = no SPI2; 1 = SPI2 included 
        </comment>
    </var>

    <var name='SPI2_NB_CS' value='2'>
        <comment>number of SPI2 CS
        </comment>
    </var>

    <var name='SDMMC_OPTION' value='1'>
        <comment>0 = no SDMMC; 1 = SDMMC controller included 
        </comment>
    </var>

    <var name='CAMERA_OPTION' value='1'>
        <comment>0 = no Camera; 1 = Camera controller included 
        </comment>
    </var>

    <var name='MEMBRIDGE_OPTION' value='0'>
        <comment>0 = EBC, 1 = AHBM
        </comment>
    </var>
    <var name='MEMBRIDGE_RAM_NB_BLOCK' value='2'>
        <comment>for membridge internal ram: number of 32k blocks
        </comment>
    </var>
    <var name='EBC_NB_BITS_ADDR' value='24'>
        <comment>for EBC option only
        </comment>
    </var>
    <var name='AHBM_NB_BITS_ADDR' value='25'>
        <comment>for AHBM option only: address bus size
        </comment>
    </var>
    <var name='AHBM_INIT_SB_0' value='0'/>
    <var name='AHBM_INIT_SB_1' value='0'/>
    <var name='AHBM_INIT_SB_2' value='0'/>
    <var name='AHBM_INIT_SB_3' value='0'/>
    <var name='AHBM_INIT_SB_4' value='0'/>

</archive>


<archive relative='mem_bridge.xml'>


<include file='globals.xml'/>
<include file='granite_ip_config.xml'/>

    <var name='EBC_NB_BITS_CS' value='3'/>
    <var name='EBC_NB_CS' value='5'/> 
    <var name='FIRST_CS_WITH_POLARITY' value='2'/>

    <var name='NB_BITS_EXTADDR' value='EBC_NB_BITS_ADDR+1'/> 

    <var name='EBC_CS0_SIZE' value='exp2(NB_BITS_MAXSPACE)'/>
    <var name='EBC_CS1_SIZE' value='exp2(NB_BITS_MAXSPACE-1)'/>
    <var name='EBC_CS2_SIZE' value='exp2(20)'/>
    <var name='EBC_CS3_SIZE' value='exp2(20)'/>
    <var name='EBC_CS4_SIZE' value='exp2(19)'/>
    
    <var name='INT_RAM_NB_BITS' value='17'/> 
    <var name='INT_RAM_NB_BLOCK' value='MEMBRIDGE_RAM_NB_BLOCK'/> 
    <var name='INT_RAM_SIZE' value='32768*INT_RAM_NB_BLOCK'/> 

    <var name='INT_ROM_NB_BITS' value='17'/> 
    <var name='INT_ROM_SIZE' value='80*1024'/> 

    <var name='NB_BIT_ROM_PACHT' value='4'/>
    <var name='NB_ROM_PACHT' value='10'/>


<module name='mem_bridge' category='System'>

    
    <reg name='FIFO_Ctrl' protect='rw'>
        <bits name='Lock' access='rw' rst='0' pos='0'>
            <comment>Lock mode: when locked the FIFO only accept requests from the XCPU, other masters receive the Split response until the lock mode is disabled. (If blocked in debug, use host internal reg reset+xcpu hold).

            </comment>
            <options>
                <option name='Enable' value='1'/>
                <option name='Disable' value='0'/>
            </options>
        </bits>
    </reg>
    <reg name='FIFO_Status' protect='rw'>
        <bits name='FIFO_Level' access='r' rst='0' pos='5:4'>
            <comment>Number of requests pending in fifo.
            </comment>
            <options><default/><mask/><shift/></options>
        </bits>
    </reg>
    <reg name='Monitor_Ctrl' protect='rw'>
        <bits name='Monitor_Sel' access='rw' rst='0' pos='0'>
            <comment>Monitor signal selection
            </comment>
            <options>
                <option name='Side_by_Side' value='0'><comment>Select FIFO Data access used by each side</comment></option>
                <option name='Data_vs_External' value='1'><comment>Select FIFO Data used by both side against Cycle used on External interface</comment></option>
            </options>
        </bits>
    </reg>

    
    <reg name='Rom_Bist' protect='rw'>
        <bits name='Ctrl' access='rw' rst='0' pos='0'>
            <comment>Write 1 to start the CRC Computation on the Rom, Read to get the status
            </comment>
            <options>
                <option name='Done' value='0'/>
                <option name='Running' value='1'/>
            </options>
        </bits>
        <bits name='CRC' access='r' rst='0' pos='31:16'>
            <comment>The Computed CRC
            </comment>
        </bits>
    </reg>
    <reg name='SRam_Bist' protect='rw'>
        <bits name='Ctrl' access='w' rst='0' pos='0'>
            <comment>Write 1 to start the BIST on the selected SRam block, Read to get the status
            </comment>
            <options>
                <option name='Done' value='0'/>
                <option name='Running' value='1'/>
            </options>
        </bits>
        <bits name='Block_Sel' access='rw' pos='INT_RAM_NB_BITS-1:15'>
            <comment>The Bock of 32k on which to run the March C- algorithm
            </comment>
        </bits>
        <bits name='Status' access='r' rst='0' pos='31'>
            <comment>The Bist Status (valid when Done)
            </comment>
            <options>
                <option name='Bad' value='1'/>
                <option name='OK' value='0'/>
            </options>
        </bits>
    </reg>

    <hole size='1888'/> 

    
    <reg name='Rom_Patch' protect='rw' count='NB_ROM_PACHT'>
        <bits name='block_addr' pos='INT_RAM_NB_BITS-1:4'>
            <comment>Base address of block in int_Rom patched (corresponding data are read from int_SRam)
            </comment>
        </bits>
        <bits name='Patch' access='rw' rst='0' pos='31'>
            <options>
                <option name='Enable' value='1'/>
                <option name='Disable' value='0'/>
            </options>
        </bits>
    </reg>
    
 
    <hole size='1728'/> 
    
    <hole size='2048'/>
    <hole size='2048'/>

    
    <reg name='EBC_Ctrl' protect='rw'>
        <bits name='Enable' access='rw' rst='1' pos='0'>
            <comment>Enable the ebc
                <br/>1 = Enable
                <br/>0 = Disable (will finish current transfer anyway)
            </comment>
        </bits>
        <bits name='IdleDrive' access='rw' rst='0' pos='12'>
            <comment>This bit select wether (1) or not (0) the EBC drives the data bus lines during idle (ie: between tranfers)
            </comment>
        </bits>
    </reg>
    <reg name='EBC_Status' protect='rw'>
        <bits name='Enable' access='r' rst='1' pos='0'>
            <comment>Enable status of the module (as reading EBC_Ctrl will return the written value)
            </comment>
        </bits>
        <bits name='Update_CS' access='r' rst='0' pos='4'>
            <comment>This bit shows that a CS update is in progress. It reads as 1 when a chip select register has been written but not yet updated in the actual configuration. This is to ensure the configuration does not change during an access.
            </comment>
        </bits>
    </reg>
    <hole size='32'/> 
    <reg name='CS_Time_Write' protect='rw'>
        <comment>This register is used to program the CS_Time register of One CS_Config at the same time as the CS_Mode regiter is set (so the two registers are always synchronized with each other).
            <br/>To update Chip Select n configuration, first write the timing value in this register, then write the CS_Mode configuration in the corresponding CS_Config[n].CS_Mode.
        </comment>
        <bits name='RdLatHalfMode' access='rw' rst='1' pos='0'>
            <comment>Read access Latency Half cycle Mode:
                <br/>when 1 reduce the cycle latency by half a cycle between 2 consecutive half word access.
                <br/>In burst mode, when 1 extend the cycle latency by half a cycle for all half word access.
            </comment>
        </bits>
        <bits name='RdLat' access='rw' rst='all1' pos='5:1'>
            <comment>Read access Latency: Access time for read.
                <br/>Access time in clock cycle is the value of this field +1.
            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name='OEDlyHalfMode' access='rw' rst='1' pos='8'>
            <comment>Chip select to Output enable Setup half mode:
                <br/>1 add one half cycle to the time
            </comment>
        </bits>
        <bits name='OEDly' access='rw' rst='all1' pos='11:9'>
            <comment>Chip select to Output enable Setup time:
                <br/>The time in clock cycle is the value of this field.

            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name='PageLat' access='rw' rst='all1' pos='15:13'>
            <comment>Page mode Latency value: Page mode access time (for read or write page mode)
                <br/>Access time in clock cycle is the value of this field +1.
                <br/>Note: if Half cycle mode is enabled it also applies to the page mode.
            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name='WrLatHalfMode' access='rw' rst='1' pos='16'>
            <comment>Write access Latency Half cycle Mode:
                <br/>when 1 reduce the cycle latency by half a cycle between 2 consecutive half word access.
            </comment>
        </bits>
        <bits name='WrLat' access='rw' rst='all1' pos='21:17'>
            <comment>Write access Latency: Access time for write.
                <br/>Access time in clock cycle is the value of this field +1.
            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name='WEDlyHalfMode' access='rw' rst='1' pos='24'>
            <comment>Chip select to Write enable Setup half mode:
                <br/>1 add one half cycle to the time
            </comment>
        </bits>
        <bits name='WEDly' access='rw' rst='all1' pos='27:25'>
            <comment>Chip select to Write enable Setup time:
                <br/>The time in clock cycle is the value of this field.
            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name='Relax' access='rw' rst='all1' pos='30:28'>
            <comment>Relaxation delay between sequence of access (all read or all write) to the same chip select and any new sequence or idle state.
                <br/>The delay in number of clock cycle is the value of this field.
            </comment>
            <options>
                <default/>
                <shift/>
                <mask/>
            </options>
        </bits>
        <bits name='ForceRelax' access='rw' rst='1' pos='31'>
            <comment>Force Relaxation cycles to be inserted between any access. (same page or same burst consecutive access are considered a single access)
            </comment>
        </bits>
    </reg>
    <struct name='CS_Config' count='EBC_NB_CS'>
        <reg name='CS_Mode' protect='rw'>
            <comment>Writing this register will also copy the content of CS_Time_Write to the CS_Time register.
            </comment>
            <bits name='CSEn' access='rw' rst='0' pos='0'>
                <comment>Enable the chip select.
                </comment>
            </bits>
            <bits name='Polarity' access='rw' rst='0' pos='1'>
                <comment>Chip Select polarity: 1 active High, '0' active Low.
                    <br/>CS0 and CS1 are always active low (0) so this bit is not writable for them.
                </comment>
                <options>
                    <option name='ActiveHigh' value='1'/>
                    <option name='ActiveLow' value='0'/>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
            </bits>
            <bits name='ADMuxMode' access='rw' rst='0' pos='2'>
                <comment>1 use Address/Data Mux for 16 lower address bits.
                </comment>
            </bits>
            <bits name='WriteAllow' access='rw' rst='1' pos='4'>
                <comment>1 to allow write, else a write to the memory of this chip select will be dropped from the controller without notice.
                </comment>
            </bits>
            <bits name='WBEMode' access='rw' rst='1' pos='5'>
                <comment>1 to use BE as WE for each byte (to use two 8bits chips)
                </comment>
            </bits>
            <bits name='BEDlyMode' access='rw' rst='1' pos='6'>
                <comment>0: BE active after OEDly/WEDly
                    <br/>1: BE active during full access
                </comment>
            </bits>
            <bits name='WaitMode' access='rw' rst='1' pos='8'>
                <comment>1 to use the wait input to delay end of a read access.
                    <br/>(RdLat min 4)
                </comment>
            </bits>
            <bits name='WriteWaitMode' access='rw' rst='1' pos='9'>
                <comment>1 to use the wait input to delay end of a write access.
                    <br/>(WrLAt min 4)
                </comment>
            </bits>
            <bits name='PageSize' access='rw' rst='all1' pos='14:12'>
                <options>
                    <option name='4HW' value='0'><comment>4 half words </comment></option>
                    <option name='8HW' value='1'><comment>8 half words </comment></option>
                    <option name='16HW' value='2'><comment>16 half words </comment></option>
                    <option name='32HW' value='3'><comment>32 half words </comment></option>
                    <option name='64HW' value='4'><comment>64 half words </comment></option>
                    <option name='128HW' value='5'><comment>128 half words </comment></option>
                    <option name='256HW' value='6'><comment>256 half words </comment></option>
                    <option name='FULL' value='7'><comment>Full page (in burst mode, else reserved)</comment></option>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
                <comment>Page size for page or bursts access.
                </comment>
            </bits>
            <bits name='PageMode' access='rw' rst='1' pos='16'>
                <comment>1 enable page mode for read access:
                    <br/>only address changes, chip select keeps enabled while address keeps in a page (defined by PageSize). 
                </comment>
            </bits>
            <bits name='WritePageMode' access='rw' rst='1' pos='17'>
                <comment>1 enable page mode for write access.
                </comment>
            </bits>
            <bits name='BurstMode' access='rw' rst='1' pos='20'>
                <comment>1 enable burst mode for read access.
                    <br/>Use PageSize.
                    <br/>Require the use of the M_ADV and M_CLK pins.
                </comment>
            </bits>
            <bits name='WriteBurstMode' access='rw' rst='1' pos='21'>
                <comment>1 enable burst mode for write access.
                </comment>
            </bits>
            <bits name='ADVAsync' access='rw' rst='1' pos='24'>
                <comment>1 the M_ADV pin is low only during the first cycle of an asynchronous access (for asynchronous modes on burst capable chips)
                </comment>
            </bits>
            <bits name='ADVWEPulse' access='rw' rst='1' pos='25'>
                <comment>1 the M_WE is valid only during the M_ADV pulse.
                </comment>
            </bits>
            <bits name='ADMuxDly' access='rw' rst='0' pos='27:26'>
                <comment>Address/Data Mux timing
                </comment>
                <options>
                    <option name='normal' value='0'><comment>ADV signal as in burst mode</comment></option>
                    <option name='F1' value='1'><comment>ADV signal fall a half cycle after CS for 1 cycle</comment></option>
                    <option name='F1_5' value='2'><comment>ADV signal fall a half cycle after CS for 1.5 cycle</comment></option>
                    <option name='F2' value='3'><comment>ADV signal fall a half cycle after CS for 2 cycle</comment></option>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
            </bits>
            <bits name='WriteSingle' access='rw' rst='1' pos='28'>
                <comment>1 the Write Burst mode PageSize is replaced by 1 to do synchronous single write access. (while PageSize is still used for Read burst access)
                </comment>
            </bits>
            <bits name='WriteHold' access='rw' rst='1' pos='29'>
                <comment>1 the data remains driven during Relaxation time.
                </comment>
            </bits>
        </reg>
        <reg name='CS_Time' protect='r'>
            <comment>This register cannot be written direclty. To update it, write to the CS_Time_write register, then to the CS_Mode register.
            </comment>
            <bits name='RdLatHalfMode' access='r' rst='1' pos='0'>
                <comment>Read access Latency Half cycle Mode:
                    <br/>when 1 reduce the cycle latency by half a cycle between 2 consecutive half word access.
                    <br/>In burst mode, when 1 extend the cycle latency by half a cycle for all half word access.
                </comment>
            </bits>
            <bits name='RdLat' access='r' rst='all1' pos='5:1'>
                <comment>Read access Latency: Access time for read.
                    <br/>Access time in clock cycle is the value of this field +1.
                </comment>
                <options>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
            </bits>
            <bits name='OEDlyHalfMode' access='r' rst='1' pos='8'>
                <comment>Chip select to Output enable Setup half mode:
                    <br/>1 add one half cycle to the time
                </comment>
            </bits>
            <bits name='OEDly' access='r' rst='all1' pos='11:9'>
                <comment>Chip select to Output enable Setup time:
                    <br/>The time in clock cycle is the value of this field.

                </comment>
                <options>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
            </bits>
            <bits name='PageLat' access='r' rst='all1' pos='15:13'>
                <comment>Page mode Latency value: Page mode access time (for read or write page mode)
                    <br/>Access time in clock cycle is the value of this field +1.
                    <br/>Note: if Half cycle mode is enabled it also applies to the page mode.
                </comment>
                <options>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
            </bits>
            <bits name='WrLatHalfMode' access='r' rst='1' pos='16'>
                <comment>Write access Latency Half cycle Mode:
                    <br/>when 1 reduce the cycle latency by half a cycle between 2 consecutive half word access.
                </comment>
            </bits>
            <bits name='WrLat' access='r' rst='all1' pos='21:17'>
                <comment>Write access Latency: Access time for write.
                    <br/>Access time in clock cycle is the value of this field +1.
                </comment>
                <options>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
            </bits>
            <bits name='WEDlyHalfMode' access='r' rst='1' pos='24'>
                <comment>Chip select to Write enable Setup half mode:
                    <br/>1 add one half cycle to the time
                </comment>
            </bits>
            <bits name='WEDly' access='r' rst='all1' pos='27:25'>
                <comment>Chip select to Write enable Setup time:
                    <br/>The time in clock cycle is the value of this field.
                </comment>
                <options>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
            </bits>
            <bits name='Relax' access='r' rst='all1' pos='30:28'>
                <comment>Relaxation delay between sequence of access (all read or all write) to the same chip select and any new sequence or idle state. (burst reaching end of page in non Full Page mode also insert a Relaxation delay)
                    <br/>The delay in number of clock cycle is the value of this field.
                </comment>
                <options>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
            </bits>
            <bits name='ForceRelax' access='r' rst='1' pos='31'>
                <comment>Force Relaxation cycles to be inserted between any access. (same page or same burst consecutive access are considered a single access)
                </comment>
            </bits>
        </reg>
    </struct>
    <hole size='1600'/> 

    
    <reg name='AHBM_Ctrl' protect='rw'>
        <bits name='Enable' access='rw' rst='1' pos='0'>
            <comment>Enable the AHB Master
                <br/>1 = Enable
                <br/>0 = Disable (will finish current transfer anyway)
            </comment>
        </bits>
    </reg>
    <reg name='AHBM_Status' protect='rw'>
        <bits name='Enable' access='r' rst='1' pos='0'>
            <comment>Enable status of the module (as reading AHBM_Ctrl will return the written value)
            </comment>
        </bits>
        <bits name='Update_SB' access='r' rst='0' pos='4'>
            <comment>This bits shows that a SpaceBase update is in progress. It reads as 1 when a SpaceBase register has been written but not yet updated in the actual configuration. This is to ensure the configuration does not change during an access.
            </comment>
        </bits>
    </reg>
    <hole size='64'/>
    <reg name='SpaceBase' protect='rw' count='EBC_NB_CS'>
        <bits name='BaseAddr' display='hex' access='rw' rst='all1' pos='31:4'>
            <comment>Base address added to the lower bits of address from FIFO.
            </comment>
        </bits>
    </reg>


</module>


<module name='mem_FIFO' category='System'>

    <reg name='Flush' protect='rw'>
        <comment>Reading this register ensure the previous write command are all done (any read would do anyway) but this does not access external controller.
        </comment>
        <bits name='Flush' access='r' rst='0' pos='0'>
        </bits>
    </reg>


    <reg name='EBC_CRE' protect='rw'>
        <bits name='CRE' access='rw' rst='0' pos='0'>
            <comment>Write here the desired state of the M_CRE pin. 
                <br/>As this register is placed in the FIFO with the memory commands, it ensure the sequence of memory access and change to this register will be kept in sequence.
            </comment>
        </bits>
    </reg>
    <reg name='EBC_Flash_Block_Remap' protect='rw'>
        <bits name='Block_Remap' access='rw' rst='all1' pos='NB_BITS_EXTADDR-1:22'>
            <comment>When the address in CS0 is in the range 0xC00000 to 0xFFFFFF, the bits 23:22 are repalced and extended by the bits in this register. <font color='red'>(value of 0,1,2 should be avoided)</font>
                <br/>As this register is placed in the FIFO with the memory commands, it ensure the sequence of memory access and change to this register will be kept in order.
            </comment>
            <options><default/><mask/><shift/></options>
        </bits>
    </reg>

    <reg name='Side_Id' protect='r'>
        <bits name='Side_Id' access='r' rst='no' pos='0'>
            <comment>Read as 0 on System side, as 1 on BaseBand Side.
            </comment>
            <options>
                <option name='System' value='0'/>
                <option name='Baseband' value='1'/>
            </options>
        </bits>
    </reg>
</module>

<module name='ebc_cs0' category='System'>
    <memory name='ram_array' size='EBC_CS0_SIZE'>
        <comment>EBC Chip select 0 memory space.
            <br/>Space accessed by M_CS_0 line.
            <br/>This chip select is dedicated to Flash access, the CPU will boot from here.
        </comment>
    </memory>
</module>
<module name='ebc_cs1' category='System'>
    <memory name='ram_array' size='EBC_CS1_SIZE'>
        <comment>EBC Chip select 1 memory space.
            <br/>Space accessed by M_CS_1 line.
            <br/>This chip select is dedicated to ram access.
        </comment>
    </memory>
</module>
<module name='ebc_cs2' category='System'>
    <memory name='ram_array' size='EBC_CS2_SIZE'>
        <comment>EBC Chip select 2 memory space.
            <br/>Space accessed by M_CS_2 line
        </comment>
    </memory>
</module>
<module name='ebc_cs3' category='System'>
    <memory name='ram_array' size='EBC_CS3_SIZE'>
        <comment>EBC Chip select 3 memory space.
            <br/>Space accessed by M_CS_3 line
        </comment>
    </memory>
</module>
<module name='ebc_cs4' category='System'>
    <memory name='ram_array' size='EBC_CS4_SIZE'>
        <comment>EBC Chip select 4 memory space.
            <br/>Space accessed by M_CS_4 line
        </comment>
    </memory>
</module>


<module name='int_sram' category='System'>
    <memory name='sram_array' size='INT_RAM_SIZE'>
        <comment>Internal SRam Space
        </comment>
    </memory>
</module>

<module name='int_rom' category='System'>
    <memory name='rom_array' size='INT_ROM_SIZE'>
        <comment>Internal Rom Space
            <br/>This rom is used for boot code.
        </comment>
    </memory>
</module>

</archive>
<archive relative='debug_port.xml'>


<module name='debug_port' category='Debug'>
    
    <enum name='Debug_Mux_Clocks'>
        <entry name='DBG_SEL_SYS_NOGATE'/>
        <entry name='DBG_SEL_SYSD_SCI'/>
        <entry name='DBG_SEL_SYSD_SPI'/>
        <entry name='DBG_SEL_SYSD_SPI2'/>
        <entry name='DBG_SEL_SYSD_RF_SPI'/>
        <entry name='DBG_SEL_SYSD_OSC'/>
        <entry name='DBG_SEL_SYSD_PWM'/>
        <entry name='DBG_SEL_BBD_DAIS_208K'/>
        <entry name='DBG_SEL_HOST'/>
        <entry name='DBG_SEL_AUDIO_PLL'/>
        <entry name='DBG_SEL_AUDIO_BCK'/>
        <entry name='DBG_SEL_UART'/>
        <entry name='DBG_SEL_UART2'/>
        <entry name='DBG_SEL_RF_RX'/>
        <entry name='DBG_SEL_RF_TX'/>
        <entry name='DBG_SEL_MEM_BRIDGE'/>        
        <entry name='DBG_SEL_VOC'/>
        <entry name='DBG_SEL_32K'/>
        <entry name='DBG_SEL_USBPHY'/>
        <entry name='DBG_SEL_CAMERA'/>
        <entry name='DBG_SEL_OSC'><comment>this clock is taken before clock root</comment></entry>
        <entry name='DBG_SEL_REF'><comment>this clock is taken before clock root</comment></entry>
        <entry name='DBG_SEL_SLOW'><comment>this clock is taken before clock root</comment></entry>
        <entry name='DBG_SEL_FAST_PLL'><comment>this clock is taken before clock root</comment></entry>
        <entry name='DBG_SEL_FAST_ACCO_PLL'><comment>this clock is taken before clock root</comment></entry>
        <entry name='DBG_SEL_FAST_EXT_PLL'><comment>this clock is taken before clock root</comment></entry>
        <entry name='DBG_SEL_VOC_PLL'><comment>this clock is taken before clock root</comment></entry>
        <entry name='DBG_SEL_UART_PLL'><comment>this clock is taken before clock root</comment></entry>
        <entry name='DBG_SEL_AU_CLK_520K'/>
        <entry name='DBG_SEL_AU_CLK_40K'/>
        <entry name='DBG_SEL_PADAC_CLK'/>
        <entry name='DBG_SEL_AFCDAC_CLK'/>
        <entry name='DBG_SEL_GPADC_CLK'/>
        <entry name='DBG_SEL_TX_CLK_FS'/>
        <entry name='DBG_SEL_RX_CLK_FS'/>
        <entry name='DBG_SEL_EXT_DBG'><comment>this clock is taken outside granite ip</comment></entry>
        
        <bound name='NB_CLK_DBG_SEL'/>
    </enum>

    <enum name='Debug_Signal_Select'>
        
        <entry name='DBG_SYS_IRQ_TCU0'/>
        <entry name='DBG_SYS_IRQ_TCU1'/>
        <entry name='DBG_SYS_IRQ_FRAME'/>
        <entry name='DBG_SYS_IRQ_DMA_TX_SDMMC'/>
        <entry name='DBG_SYS_IRQ_DMA_RX_SDMMC'/>
        <entry name='DBG_SYS_IRQ_DMA_TX_LCDC'/>
        <entry name='DBG_SYS_IRQ_DMA_RX_CAMERA'/>
        <entry name='DBG_SYS_IRQ_COM0'/>
        <entry name='DBG_SYS_IRQ_COM1'/>
        <entry name='DBG_SYS_IRQ_VOC'/>
        <entry name='DBG_SYS_IRQ_DMA'/>
        <entry name='DBG_SYS_IRQ_GPIO'/>
        <entry name='DBG_SYS_IRQ_KEYPAD'/>
        <entry name='DBG_SYS_IRQ_TIMERS'/>
        <entry name='DBG_SYS_IRQ_OS_TIMER'/>
        <entry name='DBG_SYS_IRQ_CALENDAR'/>
        <entry name='DBG_SYS_IRQ_SPI'/>
        <entry name='DBG_SYS_IRQ_SPI2'/>
        <entry name='DBG_SYS_IRQ_DEBUG_UART'/>
        <entry name='DBG_SYS_IRQ_UART'/>
        <entry name='DBG_SYS_IRQ_UART2'/>
        <entry name='DBG_SYS_IRQ_I2C'/>
        <entry name='DBG_SYS_IRQ_SCI'/>
        <entry name='DBG_SYS_IRQ_RF_SPI'/>
        <entry name='DBG_SYS_IRQ_LPS'/>
        <entry name='DBG_SYS_IRQ_BBIFC0'/>
        <entry name='DBG_SYS_IRQ_BBIFC1'/>
        <entry name='DBG_SYS_IRQ_USBC'/>
        <entry name='DBG_SYS_IRQ_LCDC'/>
        <entry name='DBG_SYS_IRQ_SDMMC'/>
        <entry name='DBG_SYS_IRQ_CAMERA'/>
        <entry name='DBG_SYS_IRQ_EXTAPB'/>
        
        <entry name='DBG_SYS_HREADY'><comment/></entry>
        <entry name='DBG_XCPU_I_FETCH'><comment/></entry>
        <entry name='DBG_XCPU_I_MISS'><comment/></entry>
        <entry name='DBG_XCPU_D_FETCH'><comment/></entry>
        <entry name='DBG_XCPU_D_MISS'><comment/></entry>
        <entry name='DBG_XCPU_MAIN_IRQ'><comment/></entry>
        
        <entry name='DBG_BB_IRQ_TCU0' value='64'/>
        <entry name='DBG_BB_IRQ_TCU1'/>
        <entry name='DBG_BB_IRQ_FRAME'/>
        <entry name='DBG_BB_IRQ_COM0'/>
        <entry name='DBG_BB_IRQ_COM1'/>
        <entry name='DBG_BB_IRQ_VOC'/>
        <entry name='DBG_BB_IRQ_IFC0'/>
        <entry name='DBG_BB_IRQ_IFC1'/>
        <entry name='DBG_BB_IRQ_IFC2'/>
        <entry name='DBG_BB_IRQ_RF_IF'/>
        <entry name='DBG_BB_IRQ_ITLV'/>
        <entry name='DBG_BB_IRQ_VITAC'/>
        <entry name='DBG_BB_IRQ_XCOR'/>
        
        
        <entry name='DBG_SYS_IRQ_PAGE_SPY' value='83'><comment/></entry>
        <entry name='DBG_EXT_PLL_LOCKED'><comment/></entry>
        <entry name='DBG_ACCO_PLL_LOCKED'><comment/></entry>
        <entry name='DBG_WATCH0'><comment/></entry>
        <entry name='DBG_WATCH1'><comment/></entry>
        <entry name='DBG_WATCH2'><comment/></entry>
        <entry name='DBG_WATCH3'><comment/></entry>
        <entry name='DBG_DIGRF_STROBE'><comment/></entry>
        <entry name='DBG_RX_SOC'><comment/></entry>
        <entry name='DBG_VOC_DMA_BUSY'><comment/></entry>
        <entry name='DBG_VOC_BUSY'><comment/></entry>
        <entry name='DBG_SYS_EBC_BUSY'><comment/></entry>
        <entry name='DBG_BB_EBC_BUSY'><comment/></entry>
        <entry name='DBG_BB_HREADY'><comment/></entry>
        <entry name='DBG_BCPU_I_FETCH'><comment/></entry>
        <entry name='DBG_BCPU_I_MISS'><comment/></entry>
        <entry name='DBG_BCPU_D_FETCH'><comment/></entry>
        <entry name='DBG_BCPU_D_MISS'><comment/></entry>
        <entry name='DBG_BCPU_MAIN_IRQ'><comment/></entry>
    </enum>
    
    <reg name='Debug_Port_Mode' protect='rw'>
        <comment>All this register is locked by the host_lock_reg signal</comment>
        <bits name='mode_Config' access='rw' rst='0' pos='2:0'>
            <options>
                <option name='Mode_Pxts_Exl_Off' value='0'><comment>when mode_Config="000" the module is switched off </comment></option>
                <option name='Mode_Exl' value='1'><comment>when mode_Config="001" the mode Exl is set</comment></option>                
                <option name='Mode_Pxts' value='2'><comment>when mode_Config="010" the mode Pxts is set</comment></option>
                <option name='Mode_Pxts_Exl' value='3'><comment>when mode_Config="011" the mode Pxts_Exl is set</comment></option>           
                <option name='Mode_Signal_Spy' value='4'><comment>when mode_Config="100" the mode Signal Spy is set</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name='Pxts_Exl_Clock_pol' access='rw' rst='0' pos='3'>
            <comment>
               Pxts Exl Clock polarity, when 1 this bit switch the clock polarity.</comment>
        </bits>

        <bits name='Pxts_Fifo_Empty' access='r' rst='0' pos='4'>
            <comment>
                Pxts bit Status, 1 when the fifo is empty </comment>
        </bits>
        <bits name='Pxts_Fifo_Ovf' access='rw' rst='0' pos='5'>
            <comment>
                Pxts bit Status, 1 when the fifo is overflow, writing 1 will clear this bit. </comment>
        </bits>
         <bits name='Exl_Fifo_Empty' access='r' rst='0' pos='8'>
            <comment>
                Exl bit Status, 1 when the fifo is empty </comment>
        </bits>
        <bits name='Exl_Fifo_Ovf' access='rw' rst='0' pos='9'>
            <comment>
                Exl bit Status, 1 when the fifo is overflow, writing 1 will clear this bit. </comment>
        </bits>
      </reg>
        
      <reg name='Pxts_Exl_Cfg' protect='rw'>
        <comment>All this register is locked by the host_lock_reg signal</comment>
        <bits name='Record_Trigger_Type' access='rw' rst='0' pos='3:0'>
            <options>
                <option name='Record_jumANDbranch' value='0'><comment>When "0000", Any jump inst, Any branch inst (taken or not)</comment></option>
                <option name='Record_branch' value='1'><comment>When "0001", Selected branch inst (taken or not)</comment></option>
                <option name='Record_branchNotTaken' value='2'><comment>When "0010", Selected branch inst, branch not taken)</comment></option>
                <option name='EXL_Record_branchTaken' value='3'><comment>When "0011", Selected branch inst, branch taken</comment></option>
                <option name='EXL_Record_NojumNobranch' value='4'><comment>When others, No jump/branch inst (useful for tracing interrupts only)</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name='Any_Branch' access='rw' rst='1' pos='4'>
            <comment>When 1, Record any kind of branch, otherwise use the field Branch_Type.
            </comment>
        </bits>
        <bits name='Int_En' access='rw' rst='1' pos='5'>
            <comment>When 1, Record Interruptions.
            </comment>
        </bits>
        <bits name='Cpu_Select' access='rw' rst='1' pos='6'>
            <options>
                <option name='BCpu' value='0'/>
                <option name='XCpu' value='1'/>
            </options>
        </bits>
        <bits name='Branch_Type' access='rw' rst='0' pos='12:8'>
            <options>
                <option name='BLTZ' value='0'><comment>branch_sel_type := "00000"</comment></option>
                <option name='BGEZ' value='1'><comment>branch_sel_type := "00001"</comment></option>
	            <option name='BEQ' value='2'><comment>branch_sel_type := "00010"</comment></option>
	            <option name='BNE' value='3'><comment>branch_sel_type := "00011"</comment></option>
	            <option name='BLEZ' value='4'><comment>branch_sel_type := "00100"</comment></option>
	            <option name='BGTZ' value='5'><comment>branch_sel_type := "00101"</comment></option>
	            <option name='BC1F' value='6'><comment>branch_sel_type := "00110"</comment></option>
	            <option name='BC1T' value='7'><comment>branch_sel_type := "00111"</comment></option>
	            <option name='BC2F' value='8'><comment>branch_sel_type := "01000"</comment></option>
	            <option name='BC2T' value='9'><comment>branch_sel_type := "01001"</comment></option>
                <option name='NO_BRANCH' value='10'><comment>branch_sel_type := "01010", Jump only</comment></option>
                <option name='BR' value='11'><comment>branch_sel_type := "10000"</comment></option>
                <option name='BEQZ' value='12'><comment>branch_sel_type := "10001"</comment></option>
                <option name='BNEZ' value='13'><comment>branch_sel_type := "10010"</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name='Enable_Pxts_Tag' cut='1' cutprefix='Enable_Pxts_Tag' access='rw' rst='0' pos='31:16'>
            <comment>
                Enable the corresponding PXTS TAG when the bit is set. </comment>
        </bits>

    </reg>
    <reg name='WD_Addr_cfg' protect='rw'>
        <bits name='WD_Address' access='rw' rst='no' pos='24:0'>
            <comment>
                Loaded during WatchDog reset with the XCPU current execution address.
            </comment>
        </bits>
    </reg>

    <reg name='Signal_Spy_Cfg' protect='rw'>
        <comment>
            <table border='1'> 
<tr><th>Pin</th><th>MODE_SYS</th><th>MODE_BB</th><th>MODE_PA</th><th>MODE_others</th></tr>
<tr><td>DBG_BUS_STB</td><td colspan='4'>FInt_H</td></tr>
<tr><td>DBG_BUS_0</td><td colspan='4'>GMSK_ON / RX_ON</td></tr>
<tr><td>DBG_BUS_1</td><td colspan='4'>RX_DEC_ON / TX_ON</td></tr>
<tr><td>DBG_BUS_2</td><td>Xcpu_Main_irq_L</td><td>Vitac_Stall or ITLV stall or Xcor Stall</td><td>PA_RAMP(0)</td><td>Next Fc_h</td></tr>
<tr><td>DBG_BUS_3</td><td>Bcpu_Main_irq_L</td><td>VITAC Busy</td><td>PA_RAMP(1)</td><td>Send_Spi_CMD</td></tr>
<tr><td>DBG_BUS_4</td><td>Sys_IntEnabled_H</td><td>XCOR Busy</td><td>PA_RAMP(2)</td><td>First Gain_H</td></tr>
<tr><td>DBG_BUS_5</td><td>BB_IntEnabled_H</td><td>ITLV Busy</td><td>PA_NEW_RAMP</td><td>Next Gain_H</td></tr>

<tr><td>DBG_BUS_6</td><td colspan='4'>Signal_Select0</td></tr>
<tr><td>DBG_BUS_7</td><td colspan='4'>Signal_Select1</td></tr>
            </table>
        </comment>
        <bits name='Dbg_Bus_RXTX_Sel0' access='rw' rst='1' pos='0'>
            <comment>This bit select the output on pin DBG_BUS_0</comment>
            <options>
                <option name='RX_ON' value='1'/>
                <option name='GMSK_ON' value='0'/>
            </options>
        </bits>
        <bits name='Dbg_Bus_RXTX_Sel1' access='rw' rst='1' pos='4'>
            <comment>This bit select the output on pin DBG_BUS_1</comment>
            <options>
                <option name='TX_ON' value='1'/>
                <option name='RX_DEC_ON' value='0'/>
            </options>
        </bits>
        <bitgroup name='Dbg_Bus_RXTX_Sel'>
            <entry ref='Dbg_Bus_RXTX_Sel0'/>
            <entry ref='Dbg_Bus_RXTX_Sel1'/>
        </bitgroup>
        <bits name='Dbg_Bus_Mode' access='rw' rst='all1' pos='9:8'>
            <comment>This bit select the output on pins DBG_BUS_2 to DBG_BUS_5
            </comment>
            <options>
                <option name='DEBUG_MODE_SYS' value='0'><comment>When "00", select DEBUG_MODE_SYS</comment></option>
                <option name='DEBUG_MODE_BB' value='1'><comment>When "01", Select DEBUG_MODE_BB</comment></option>
                <option name='DEBUG_MODE_PA' value='2'><comment>When "10", Select DEBUG_MODE_PA</comment></option>
                <option name='DEBUG_MODE_others' value='3'><comment>When "11", Select DEBUG_MODE_others</comment></option>
                 <default/>
                <mask/>
                <shift/>
            </options>

        </bits>
        <bits name='Dbg_Bus_Sig_Sel0' access='rw' rst='all1' pos='22:16'>
            <comment>This bit select the output on pin DBG_BUS_6</comment>
            <options linkenum='Debug_Signal_Select'>
                <default/>
                <mask/>
                <shift/>
            </options>

        </bits>
        <bits name='Dbg_Bus_Sig_Sel1' access='rw' rst='all1' pos='30:24'>
            <comment>This bit select the output on pin DBG_BUS_7</comment>
            <options linkenum='Debug_Signal_Select'>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
    </reg>

     <reg name='Dbg_Clk_Cfg' protect='rw'>
        <bits name='Sel_Source' access='rw' rst='all1' pos='5:0'>
            <comment>Selects the clock debug source
            </comment>
            <options linkenum='Debug_Mux_Clocks'>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name='Enable_DBG' access='rw' rst='1' pos='20'>
            <options>
                <option name='masked' value='0'><comment>The DBG clock is masked</comment></option>
                <option name='enabled' value='1'><comment>The DBG clock is enabled</comment></option>
            </options>
        </bits>
    </reg>

   <reg name='Dbg_Watch_Set' protect='rw'>
         <bits name='Dbg_Watch_S_C' access='rs' rst='1' pos='3:0'>
            <comment>Writing '1' to any of these bits sets the corresponding register, reading it returns the register value.
                <br/>These bits can be selected by the Signal_Spy_Cfg register configuration. to monitor some peace of software.
            </comment>
        </bits>
    </reg>
    <reg name='Dbg_Watch_Clr' protect='rw'>
         <bits name='Dbg_Watch_S_C' access='rc' rst='0' pos='3:0'>
            <comment>Writing '1' to any of these bits clears the corresponding register, reading it returns the register value.
                <br/>These bits can be selected by the Signal_Spy_Cfg register configuration. to monitor some peace of software.
            </comment>
        </bits>
    </reg>

    <hole size='32*9'/>
     <reg name='Pxts_tag' protect='rw' count='16'>
        <bits name='tag_pxts' access='w' rst='0' pos='15:0'>
            <comment>
                When Mode_Pxts and the corresponding Enable_Pxts_Tag are enabled, each write into tag_pxts register provide a 16 bits packet send to the romulator throught the DBG_BUS port </comment>
        </bits>
    </reg>
</module>

</archive>

<archive relative='gpio.xml'>


  
  <include file='granite_ip_config.xml'/>

  
  <var name='IDX_GPIO_DCON' value='0'/>
  <var name='IDX_GPO_CHG' value='0'/>


<module name='gpio' category='Periph'>

  

  <reg name='gpio_oen_val' protect='rw'>
    <bits name='oen_val' display='hex' access='rw' rst='0xffffff' pos='NB_GPIO-1:0'>
      <options>
        <option name='INPUT' value='1'/>

        <option name='OUTPUT' value='0'/>

        <default/>
      </options>

      <comment>Set the direction of the GPIO n.<br/>0 = output<br/>1 =
      input</comment>
    </bits>
  </reg>

  <reg name='gpio_oen_set_out' protect='rw'>
    <bits name='oen_set_out' access='rc' rst='0' pos='NB_GPIO-1:0'>
      <comment>'Write '1' sets the corresponding GPIO pin as output.</comment>
    </bits>
  </reg>

  <reg name='gpio_oen_set_in' protect='rw'>
    <bits name='oen_set_in' display='hex' access='rs' rst='0xffffff' pos='NB_GPIO-1:0'>
      <comment>'Write '1' sets the corresponding GPIO pin as input.</comment>
    </bits>
  </reg>

  

  <reg name='gpio_val' protect='rw'>
    <bits name='gpio_val' display='hex' access='rw' rst='0xffffff' pos='NB_GPIO-1:0'>
      <comment>When write, update the output value. When read, get the input
      value. </comment>
    </bits>
  </reg>

  <reg name='gpio_set' protect='rw'>
    <bits name='gpio_set' access='rs' rst='0' pos='NB_GPIO-1:0'>
      <comment>Write '1' will set GPIO output value. When read, get the GPIO
      output value.</comment>
    </bits>
  </reg>

  <reg name='gpio_clr' protect='rw'>
    <bits name='gpio_clr' access='rc' rst='0' pos='NB_GPIO-1:0'>
      <comment>'Write '1' clears corresponding GPIO output value. When read, get the GPIO
      output value. </comment>
    </bits>
  </reg>

  

  <reg name='gpint_ctrl_set' protect='rw'>
    <bits name='gpint_r_set' access='rs' rst='0' pos='7:0'>
      <comment>Write '1' will set GPIO interrupt mask for rising edge and
      level high. When read, get the GPIO interrupt mask for rising edge and
      level high. </comment>
    </bits>

    <bits name='gpint_f_set' access='rs' rst='0' pos='15:8'>
      <comment>Write '1' will set GPIO interrupt mask for falling edge and
      level low. When read, get the GPIO interrupt mask for falling edge and
      level low.</comment>
    </bits>

    <bits name='dbn_en_set' access='rs' rst='0' pos='23:16'>
      <comment>Write '1' will enable debounce mechanism.</comment>
    </bits>

    <bits name='gpint_mode_set' access='rs' rst='0' pos='31:24'>
      <comment>Write '1' will set interruption mode to level.</comment>
    </bits>
  </reg>

  <reg name='gpint_ctrl_clr' protect='rw'>
    <bits name='gpint_r_clr' access='rc' rst='0' pos='7:0'>
      <comment>'Write '1' will clear GPIO interrupt mask for rising edge and
      level high.</comment>
    </bits>

    <bits name='gpint_f_clr' access='rc' rst='0' pos='15:8'>
      <comment>Write '1' will clear GPIO interrupt mask for falling edge and
      level low.</comment>
    </bits>

    <bits name='dbn_en_clr' access='rc' rst='0' pos='23:16'>
      <comment>Write '1' will disable debounce mechanism.</comment>
    </bits>

    <bits name='gpint_mode_clr' access='rc' rst='0' pos='31:24'>
      <comment>Write '1' will set interruption mode to edge
      triggered.</comment>
    </bits>
  </reg>

  

  <reg name='int_clr' protect='w'>
    <bits name='gpint_clr' access='c' rst='0' pos='NB_GPIO_INT-1:0'>
      <comment>'Write '1' will clear GPIO interrupt.</comment>
    </bits>
  </reg>

  <reg name='int_status' protect='r'>
    <bits name='gpint_status' access='r' rst='0' pos='NB_GPIO_INT-1:0'>
      <comment>Each bit represents if there is a GPIO interrupt
      pending.</comment>
      <options>
        <default/>
        <mask/>
        <shift/>
      </options>
    </bits>
  </reg>

  
  <reg name='chg_ctrl' protect='rw'>
    <bits name='out_time' display='hex' access='rw' rst='0xf' pos='3:0'>
        <comment>time for which GPIO0 is set to output mode, after a start read
            DCON command is issued.<br/>The output time = (OUT_TIME+1)*30.5us.
        </comment>
    </bits>

    <bits name='wait_time' display='hex' access='rw' rst='0x3f' pos='9:4'>
        <comment>time for which GPIO0 should wait before reading DC_ON, after
            a start read DCON command is issued.<br/>The wait time = (WAIT_TIME+1)*30.5us.
            <br/>NOTE: wait_time must be strictly greater than out_time;
        </comment>
    </bits>

    <bits name='int_mode' display='hex' access='rw' rst='0x3' pos='17:16'>
        <comment>interruption mode of GPIO0 in mode DC_ON detection.<br/>
        </comment>
            <options>
                <option name='L2H' value='0'>
                    <comment>
                        "00" = send IRQ if last read DCON is '0' and now is '1'. 
                    </comment>
                </option>
                <option name='H2L' value='1'>
                    <comment>
                        "01" = send IRQ if last read DCON is '1' and now is '0'.
                    </comment>
                </option>
                <option name='RR' value='3'>
                    <comment>
                        "11" = send IRQ every time read is ready.
                    </comment>
                </option>
            </options>
    </bits>
  </reg>
  
  

  <reg name='chg_cmd' protect='w'>
    <bits name='dcon_mode_set' access='s' rst='0' pos='0'>
      <comment>Write '1' to set GPIO0 to charger DCON detect mode.</comment>
    </bits>
      
    <bits name='chg_mode_set' access='s' rst='0' pos='4'>
      <comment>Write '1' to set GPO0 to charger watchdog mode.</comment>
    </bits>

    <bits name='dcon_mode_clr' access='c' rst='0' pos='8'>
      <comment>Write '1' to clear charger DCON detect mode of GPIO0.</comment>
    </bits>

    <bits name='chg_mode_clr' access='c' rst='0' pos='12'>
      <comment>Write '1' to clear the charger watchdog mode of GPO0.</comment>
    </bits>

    <bits name='chg_down' access='s' rst='0' pos='24'>
      <comment>Write '1' to generate a pulse of '0' on GPO0 for 16 CLK_OSC cycles.</comment>
    </bits>
  </reg>

  

  <reg name='gpo_set' protect='rw'>
    <bits name='gpo_set' display='hex' access='rs' rst='0xaaaaaaaa' pos='NB_GPO-1:0'>
      <comment>'Write '1' will set GPO output value. When read, get the GPO
      output value.</comment>
    </bits>
  </reg>

  <reg name='gpo_clr' protect='rw'>
    <bits name='gpo_clr' display='hex' access='rc' rst='0xaaaaaaaa' pos='NB_GPO-1:0'>
      <comment>'Write '1' will clear GPO output value. When read, get the GPO
      output value.</comment>
    </bits>
  </reg>
</module>


</archive>

<archive relative='i2c_master.xml'>


<module name='i2c_master' category='Periph'>
    
    <reg name='CTRL' protect='rw'>
        
 		<bits name='EN' access='rw' rst='0' pos='0'>
			<comment> I2C master enable, high active. 
			</comment>
		</bits>
        
		<bits name='IRQ_MASK' access='rw' rst='0' pos='8'>
			<comment> I2C master interrupt enable, high active. 
			</comment>
		</bits>
        
		<bits name='Clock_Prescale' access='rw' rst='0xFFFF' pos='31:16'>
            <comment> This register is used to prescale the SCL clock line. Due to the structure of I2C interface, this module uses a 5*SCL clock frequency. Clock_Prescale must be programmed to this 5*SCL clock frequency (minus 1). Change the value of Clock_Prescale only when bit EN is cleared. <br/> <br/> Example:<br/> PCLK_MOD is 52 MHz, desired SCL is 100 KHz. <br/> Prescale = 52MHz / (5 * 100KHz) -1 = 103.
			</comment>
            <options><mask/></options>
		</bits>
	</reg>

    <reg name='STATUS' protect='r'>
        
        <bits name='IRQ_Cause' access='r' rst='0' pos='0'>
			<comment> IRQ Cause bit. This bit is set when one byte transfer has been completed or arbitration is lost, this bit is generated by bit IRQ_Status AND bit IRQ_MASK.
			</comment>
        </bits>
        
		<bits name='IRQ_Status' access='r' rst='0' pos='4'>
			<comment> IRQ status bit. 
			</comment>
        </bits>
        
		<bits name='TIP' access='r' rst='0' pos='8'>
			<comment> TIP, Transfer in progress.
				'1' when transferring data. '0' when transfer complete.
			</comment>
		</bits>
        
		<bits name='AL' access='r' rst='0' pos='12'>
			<comment> AL,Arbitration lost.
				This bit is set when the I2C master lost arbitration.
			</comment>
		</bits>
        
		<bits name='Busy' access='r' rst='0' pos='16'>
			<comment> Busy,I2C bus busy.
				'1' after START signal detected.
				'0' after STOP signal detected.
			</comment>
		</bits>
        
		<bits name='RxACK' access='r' rst='0' pos='20'>
			<comment> RxACK, Received acknowledge from slave.
				'1'= "No ACK" received.
				'0'= ACK received.
			</comment>
		</bits>
    </reg>
    
	<reg name='TXRX_BUFFER' protect='wr'>
        
		<bits name='TX_DATA' access='w' rst='-' pos='7:0'>
			<comment> Byte to transmit via I2C. <br/> for Bit 0, In case of a data transfer this bit represents the data's LSB. In case of a slave address transfer this bit represents the RW bit. <br/> '1' = reading from slave. <br/> '0' = writing to slave.   
			</comment>
		</bits>

 		<bits name='RX_DATA' access='r' rst='-' pos='7:0'>
			<comment> Last byte received via I2C. 
			</comment>
		</bits>
        
	</reg>

	<reg name='CMD' protect='w'>

		<bits name='ACK' access='w' rst='0' pos='0'>
			<comment> ACK,when master works as a receiver,sent ACK(ACK='0') or NACK(ACK='1').
			</comment>
		</bits>

		<bits name='RD' access='w' rst='0' pos='4'>
			<comment> RD,read from slave, this bit is auto cleared.
			</comment>
		</bits>

		<bits name='STO' access='w' rst='0' pos='8'>
			<comment> STO,generate stop condition, this bit is auto cleared.
			</comment>
		</bits>
        
		<bits name='WR' access='w' rst='0' pos='12'>
			<comment> WR,write to slave, this bit is auto cleared.
			</comment>
		</bits>

		<bits name='STA' access='w' rst='0' pos='16'>
			<comment> STA,generate (repeated) start condition, this bit is auto cleared.
			</comment>
		</bits>
    </reg>

  	<reg name='IRQ_CLR' protect='w'>  
        
		<bits name='IRQ_Clr' access='c' rst='0' pos='0'>
			<comment> When write '1', clears a pending I2C interrupt.
			</comment>
        </bits>
    </reg>
    

</module>
</archive>


<archive relative='itlv.xml'>


<include file='globals.xml'/>

<module name='itlv' category='Baseband'>
  <reg name='command' protect='rw'>
    <bits name='nb_bits' access='rw' rst='0x0' pos='29:20'>
      <comment>Number of bits to be (De)Interleaved.</comment>
    </bits>

    <bits name='burst_offset' access='rw' rst='0x0' pos='12:8'>
      <comment>This value gives the write offset (in number of bursts) to be
      added to a Burst Base address (ignored for Type 1b). For normal
      operation, this offset should be even (lsb will be ignored).</comment>
    </bits>

    <bits name='itlv_type' access='rw' rst='0x0' pos='6:4'>
      <comment>Selects (de-)interleaving type.</comment>
            <options>
                <option name='TYPE_1A' value='0'>
                    <comment>TCH/FS, TCH/EFS, FACCH/F, TCH/F2.4, TCH/AFS (speech, ratscch, sid_first)</comment>
                </option>
                <option name='TYPE_1B' value='1'>
                    <comment>SACCH, TCH/AFS(sid_update), PDTCH(CS-1 to CS-4), BCCH, PCH, AGCH, PACCH, PBCCH, PAGCH, PPCH, PNCH, PTCCH/D</comment>
                </option>
                <option name='TYPE_1C' value='2'>
                    <comment>FACCH/H</comment>
                </option>
                <option name='TYPE_2A' value='3'>
                    <comment>TCH/HS and TCH/AHS</comment>
                </option>
                <option name='TYPE_2B' value='4'>
                    <comment>TCH/HS and TCH/AHS</comment>
                </option>
                <option name='TYPE_3' value='5'>
                    <comment>TCH/F14.4, TCH/F9.6, TCH/F4.8, TCH/H4.8, and TCH/H2.4</comment>
                </option>
                <default/>
                <mask/>
                <shift/>
            </options>
    </bits>

    <bits name='int_mask' access='rw' rst='0x0' pos='3'>
      <comment>Sets the interrupt mask ('1': interruption enabled)</comment>
    </bits>

    <bits name='ditlv_start' access='rw' rst='0x0' pos='1'>
      <comment>Starts the de-interleaving process.</comment>
    </bits>

    <bits name='itlv_start' access='rw' rst='0x0' pos='0'>
      <comment>Starts the interleaving process.</comment>
    </bits>
  </reg>

  <reg name='status' protect='r'>
    <bits name='busy' access='r' rst='0x0' pos='0'>
      <comment>This bit is high when a (de-)interleaving process is ongoing. It
      stays high if the module is stalled during operation.</comment>
    </bits>
  </reg>

  <reg name='burst_base' protect='rw'>
    <bits name='burst_base' access='rw' rst='0x0' pos='BB_SRAM_ADDR_WIDTH+1:2'>
      <comment>This is the start address of the burst buffer in SRAM
      </comment>
    </bits>
  </reg>

  <reg name='frame_base' protect='rw'>
    <bits name='frame_base' access='rw' rst='0x0' pos='BB_SRAM_ADDR_WIDTH+1:2'>
      <comment>This is the start address of the frame buffer in
      SRAM.</comment>
    </bits>
  </reg>

  <reg name='int_status' protect='r'>
    <bits name='it_status' access='r' rst='0x0' pos='16'>
      <comment>This bit is the unmasked version of the IT_CAUSE bit.</comment>
    </bits>

    <bits name='it_cause' access='r' rst='0x0' pos='0'>
      <comment>This bit is set when the ITLV module finishes an ongoing
      operation. It can be masked by setting ITLV_CMD(IT_MASK) to '1'.
      Resetting this bit is done by writing in IT_CLEAR register. IT_CAUSE is
      the image of the ITLV_DONE_H interrupt line to the CPU. </comment>
    </bits>
  </reg>

  <reg name='int_clear' protect='w'>
    <bits name='it_clear' access='w' rst='0x0' pos='0'>
      <comment>Setting this bit to '1' resets the Interleaver's
      interrupt.</comment>
    </bits>
  </reg>
</module>

</archive>


<archive relative='page_spy.xml'>


<include file='globals.xml'/>


<module name='page_spy' category='Debug'>

  <var name='PAGE_SPY_NB_PAGE' value='6'/>

  <reg name='enable' protect='rw'>
    <bits name='enable_page' cut='1' cutprefix='enable_page' access='rs' rst='0' pos='PAGE_SPY_NB_PAGE-1:0'>
      <comment>Writing '1' enable the page (n), writing '0' leave the page in
      it's current state. Reading returns '1' if the page is active (hit or
      not).</comment>
    </bits>
  </reg>

  <reg name='status' protect='r'>
    <bits name='status_page' cut='1' cutprefix='status_page' access='r' rst='0' pos='PAGE_SPY_NB_PAGE-1:0'>
      <options>
        <option name='NOT_HIT' value='0'/>

        <option name='HIT' value='1'/>

        <default/>
      </options>
      <comment>Status of the page.</comment>
    </bits>

  </reg>

  <reg name='disable' protect='rw'>
    <bits name='disable_page' cut='1' cutprefix='disable_page' access='rc' rst='0' pos='PAGE_SPY_NB_PAGE-1:0'>
      <comment>Writing '1' disable the page (n) and clears the hit status if
      any, writing '0' leave the page in it's current state. Reading returns
      '1' if the page is active (hit or not).</comment>
    </bits>
  </reg>

  <hole size='32'/>

  <struct name='page' count='PAGE_SPY_NB_PAGE'>
    <reg name='start' protect='rw'>
      <bits name='start_address' access='rw' rst='no' pos='NB_BITS_ADDR-1:0'>
        <comment>Start address of page (n) (included). </comment>
      </bits>

      <bits name='detect_read' access='rw' rst='no' pos='30'>
        <comment>If '1' any read within the range will trigger the
        page.</comment>
      </bits>

      <bits name='detect_write' access='rw' rst='no' pos='31'>
        <comment>If '1' any read within the range will trigger the
        page.</comment>
      </bits>
      <bitgroup name='mode'>
        <entry ref='detect_read'/>
        <entry ref='detect_write'/>
      </bitgroup>  
    </reg>

    <reg name='end' protect='rw'>
      <bits name='end_address' access='rw' rst='no' pos='NB_BITS_ADDR-1:0'>
        <comment>End address of page (n) (excluded).</comment>
      </bits>
    </reg>

    <reg name='master' protect='r'>
      <bits name='master' access='r' rst='0' pos='2:0'>
        <options>
          <option name='NO_ACCESS' value='0'/>

          <option name='IFC' value='1'/>

          <option name='DMA' value='2'/>

          <option name='SYS_XCPU' value='3'/>

          <option name='AHB2AHB' value='4'/>

          <default/>
        </options>

        <comment>The master that wrote in the page (n). </comment>
      </bits>
    </reg>

    <reg name='addr' protect='r'>
      <bits name='hit_addr' access='r' rst='no' pos='24:0'>
        <comment>Address that triggered page (n). </comment>
      </bits>

      <bits name='hit_read' access='r' rst='no' pos='30'>
        <comment>If '1' a read has triggered the page.</comment>
      </bits>

      <bits name='hit_write' access='r' rst='no' pos='31'>
        <comment>If '1' a write has triggered the page.</comment>
      </bits>
    </reg>
  </struct>
</module>

</archive>
<archive relative='rf_if.xml'>

<module name='rf_if' category='Baseband'>

  <reg name='Buffer' protect='w'>
    <bits name='Rx/Tx data' access='rw' rst='no' pos='31:0'>
      <comment>In read mode this register contains the sample received on the Rx chain. I component is located on bit[11:0] and Q component is located on bit[27:16].
      <br/>This register accesses to the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data sample arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overflow error will also occur.
      <br/>The data written into this register is the data transmitted. Any attempt to write data when the FIFO is full results in the write data being lost.
      </comment>
    </bits>
  </reg>

  <reg name='Ctrl' protect='rw'>
    <bits name='Enable' access='rw' rst='0' pos='0'>
      <options>
        <option name='Disable' value='0'/>
        <option name='Enable' value='1'/>
      </options>
      <comment>Turn on/off the rf_if interface</comment>
    </bits>
    
    <bits name='DigRF Enable' access='rw' rst='0' pos='1'>
      <options>
        <option name='Disable' value='0'><comment>Analog more selected</comment></option>
        <option name='Enable' value='1'><comment>DigRF mode selected</comment></option>
      </options>
      <comment>Turn on/off the DigRF mode</comment>
    </bits>
    
    <bits name='Rx overflow Enable' access='rw' rst='1' pos='4'>
      <options>
        <option name='Disable' value='0'><comment>Disable (mask) Rx fifo overflow interrupt</comment></option>
        <option name='Enable' value='1'><comment>Enable Rx fifo overflow interrupt</comment></option>
      </options>
      <comment>Rx Fifo Overflow interrupt Enable</comment>
    </bits>
    
    <bits name='Rx Cal Bypass' access='rw' rst='1' pos='5'>
      <options>
        <option name='Enabled' value='0'/>
        <option name='Bypassed' value='1'/>
      </options>
      <comment>Calibration bypass</comment>
    </bits>
    
    <bits name='Rx Swap I/Q' access='rw' rst='0' pos='6'>
      <options>
        <option name='NO' value='0'><comment>No Swap</comment></option>
        <option name='YES' value='1'><comment>Swap I/Q</comment></option>
      </options>
      <comment>Rx swap I/Q</comment>
    </bits>
    
    <bits name='Rx Force ADC On' access='rw' rst='0' pos='7'>
      <options>
        <option name='NO' value='0'><comment>No forced, Rx_On output controlled by TCO_RX_ON signal from the TCU</comment></option>
        <option name='YES' value='1'><comment>Forced ADC on;Rx_On output always high</comment></option>
      </options>
      <comment>Force Rx On. This bit is used only with the analog option.</comment>
    </bits>

    <bits name='Rx Force Dec On' access='rw' rst='0' pos='8'>
      <options>
        <option name='NO' value='0'><comment>No forced, decimator controlled by Rx_dec_on signal from the TCU</comment></option>
        <option name='YES' value='1'><comment>Forced; decimator always on</comment></option>
      </options>
      <comment>Force Decimator On</comment>
    </bits>
    
    <bits name='Rx Force SOC' access='w' rst='no' pos='9'>
      <comment>Force start of calibation in receive mode
        <br/>Writing a 1 to this bit launch the calibration phase. Write only bit, this bit doesn't need to be cleared.
      </comment>
    </bits>
    
    <bits name='Rx Fifo Reset' access='w' rst='no' pos='10'>
      <comment>Writing a 1 to this bit resets and flush the receive Fifo. 
        <br/>Write only bit, this bit doesn't need to be cleared.
      </comment>
    </bits>
    
  
    <bits name='Tx overflow Enable' access='rw' rst='1' pos='16'>
      <options>
        <option name='Disable' value='0'><comment>Disable (mask) Tx fifo overflow interrupt</comment></option>
        <option name='Enable' value='1'><comment>Enable Tx fifo overflow interrupt</comment></option>
      </options>
      <comment>Tx Fifo Overflow interrupt Enable</comment>
    </bits>
    
    <bits name='Tx underflow Enable' access='rw' rst='1' pos='17'>
      <options>
        <option name='Disable' value='0'><comment>Disable (mask) Tx fifo undeflow interrupt</comment></option>
        <option name='Enable' value='1'><comment>Enable Tx fifo underflow interrupt</comment></option>
      </options>
      <comment>Tx Fifo Underflow interrupt Enable:</comment>
    </bits>
    
    <bits name='Tx Force DAC On' access='rw' rst='0' pos='18'>
      <options>
        <option name='NO' value='0'><comment>No forced, Tx_On output controlled by TCO_TX_ON signal from the TCU</comment></option>
        <option name='YES' value='1'><comment>Forced DAC on; Tx_On output always high</comment></option>
      </options>
      <comment>Force DAC On. This bit is used only with the analog option.</comment>
    </bits>
    
    <bits name='Tx Force DAC Off' access='rw' rst='0' pos='19'>
      <options>
        <option name='NO' value='0'><comment>No forced, Tx_On output controlled by TCO_TX_ON signal from the TCU</comment></option>
        <option name='YES' value='1'><comment>Forced DAC Off; Tx_On output always low</comment></option>
      </options>
      <comment>Force DAC Off. This bit is used only with the analog option.</comment>
    </bits>


    <bits name='Tx Force oen' access='rw' rst='0' pos='20'>
      <options>
        <option name='NO' value='0'><comment>No forced, Tx_Oen controlled by TCO_TX_OEN signal from the TCU</comment></option>
        <option name='YES' value='1'><comment>Forced; Tx_Oen always high, Low pass output in HZ</comment></option>
      </options>
      <comment>Force Tx Oen. This bit is used only with the analog option.</comment>
    </bits>
  
    <bits name='Tx Force GMSK On' access='rw' rst='0' pos='21'>
      <options>
        <option name='NO' value='0'><comment>No forced, transmit serial interface controlled by TCO_GMSK_ON signal from the TCU</comment></option>
        <option name='YES' value='1'><comment>Forced; serializer always enabled</comment></option>
      </options>
      <comment>Force GMSK On. In digRF mode this bit force the digRF output RxTxEn to one.</comment>
    </bits>
    <bits name='Tx Swap I/Q' access='rw' rst='0' pos='22'>
      <options>
        <option name='NO' value='0'><comment>No Swap</comment></option>
        <option name='YES' value='1'><comment>Swap I/Q</comment></option>
      </options>
      <comment>Tx swap I/Q. This bit is used only with the analog option.</comment>
    </bits>
 
    <bits name='Tx Fifo Reset' access='w' rst='no' pos='23'>
      <comment>Writing a 1 to this bit resets and flush the transmit Fifo. 
        <br/>Write only bit, this bit doesn.t need to be cleared.
      </comment>
    </bits>
    
    <bits name='DigRF Rx Rate' access='rw' rst='1' pos='24'>
      <options>
        <option name='ONE' value='0'><comment>One sample per symbol</comment></option>
        <option name='TWO' value='1'><comment>Two samples per symbol</comment></option>
      </options>
      <comment>Rx rate for DigRF interface. This bit is used only when DigRF is enabled (DigRF Enabled)
      </comment>
    </bits>
    
    <bits name='DigRF Rx Clk Pol' access='rw' rst='1' pos='25'>
      <comment>Change the polarity of the DigRF Rx clock. This bit is used only when DigRF is enabled (DigRF Enabled)
        <br/>0 = No inversion
        <br/>1 = Invert clock polarity
      </comment>
    </bits>
    
    <bits name='DigRF Tx mode' access='rw' rst='1' pos='26'>
      <options>
        <option name='Stream' value='0'/>
        <option name='Block' value='1'/>
      </options>
      <comment>Tx mode for the DigRF interface. This bit is used only when DigRF is enabled (DigRF Enabled)
      </comment>
    </bits>

    <bits name='DigRF Tx Clk Pol' access='rw' rst='1' pos='27'>
      <comment>Change the polarity of the DigRF Rx clock. This bit is used only when DigRF is enabled (DigRF Enabled)
        <br/>0 = No inversion
        <br/>1 = Invert clock polarity
      </comment>
    </bits>

    <bits name='DigRF Shift Sample' display='hex' access='rw' rst='all1' pos='30:28'>
      <comment>Shift input sample in DigRF mode only. This bit is used only when DigRF is enabled (DigRF Enabled)
        <br/>000 = Keep MSB bit 
        <br/>001 = 1 shift on the right
        <br/>010 = 2 shift on the right
        <br/>011 = 3 shift on the right 
        <br/>100 = 4 shift on the right (don't use it in 13-bit mode)
      </comment>
    </bits>
    <bits name='DigRF Nb bit Select' display='hex' access='rw' rst='0' pos='31'>
      <comment>Select the number of useful bit. Option available only when  DigRF is enabled (DigRF Enabled)
        <br/>1 = 13-bit 
        <br/>0 = 12-bit
      </comment>
    </bits>
  </reg>

    <reg name='Status' protect='r'>
      <bits name='Rx Fifo level' access='r' rst='0' pos='2:0'>
        <comment>Those bits indicate the number of data available in the Rx Fifo.</comment>
      </bits>
      <bits name='Tx Fifo level' access='r' rst='0' pos='7:3'>
        <comment>Those bits indicate the number of data available in the Tx Fifo. Those data will be sent.
        </comment>
      </bits>
      <bits name='Rx Overflow Cause' access='r' rst='0' pos='8'>
        <comment>Rx overflow cause register
        <br/>This bit indicates that an interruption was generated when the Rx fifo is overflow. 
        <br/>This bit is cleared when the Rx_Overflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written.
        </comment>
      </bits>
      <bits name='Tx Overflow Cause' access='r' rst='0' pos='9'>
        <comment>Tx overflow cause register
        <br/>This bit indicates that an interruption was generated when the Tx fifo is overflow. 
        <br/>This bit is cleared when the Tx_Overflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written.
        </comment>
      </bits>
      <bits name='Tx Underflow Cause' access='r' rst='0' pos='10'>
        <comment>Tx underflow cause register
        <br/>This bit indicates that an interruption was generated when the Tx fifo is underflow. 
        <br/>This bit is cleared when the Tx_underflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written.
        </comment>
      </bits>
      <bits name='Rx Overflow Status' access='r' rst='0' pos='16'>
        <comment>This bit indicates that the receiver received a new sample when the FIFO was already full. 
        <br/>The new sample is discarded. This bit is cleared when the Rx_Overflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written
        </comment>
      </bits>
      <bits name='Tx Overflow Status' access='r' rst='0' pos='17'>
        <comment>This bit indicates that the user tried to write on the FIFO while it was already full. 
        <br/>This bit is cleared when the Tx_Overflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written
        </comment>
      </bits>
      <bits name='Tx Underflow Status' access='r' rst='0' pos='18'>
        <comment>This bit indicates that the modulator tried to read on the FIFO while it was empty. 
        <br/>This bit is cleared when the Tx_Underflow_Int field in the RF_IF_INTERRUPT_CLEAR register is written
        </comment>
      </bits>
    </reg>

    <reg name='Interruption_clear' protect='w'>
      <bits name='Rx Overflow' access='w' rst='no' pos='0'>
        <comment>Clear Rx Interrupt Overflow interrupt.
        </comment>
      </bits>
      <bits name='Tx Overflow' access='w' rst='no' pos='1'>
        <comment>Clear Tx Interrupt Overflow interrupt.
        </comment>
      </bits>
      <bits name='Tx Underflow' access='w' rst='no' pos='2'>
        <comment>Clear Tx Interrupt Underflow interrupt.
        </comment>
      </bits>
    </reg>
    
    <reg name='Rx Offset' protect='r'>
      <bits name='Rx_Offset_I' display='hex' access='r' rst='all0' pos='12:0'>
        <comment>Rx offset measured after calibration for I channel
        </comment>
      </bits>
      <bits name='Rx_Offset_Q' display='hex' access='r' rst='all0' pos='28:16'>
        <comment>Rx offset measured after calibratio for Q channel
        </comment>
      </bits>
    </reg>
</module>
</archive>
<archive relative='rf_spi.xml'>


    <var name='CMD_FIFO_LEN_BITS' value='5'/>
    <var name='CMD_FIFO_LEN' value='20'/> 
    <var name='CMD_SIZE_BITS' value='8'/>
    
    <var name='CMD_DATA_FIFO_LEN_BITS' value='4'/>
    <var name='CMD_DATA_FIFO_LEN' value='exp2(CMD_DATA_FIFO_LEN_BITS)'/>
    
    <var name='GAIN_TABLE_LEN_BITS' value='4'/>
    <var name='GAIN_TABLE_LEN' value='15'/>  
    <var name='GAIN_SIZE_BITS' value='4'/>

    <var name='RX_DATA_FIFO_LEN_BITS' value='2'/>
    <var name='RX_DATA_FIFO_LEN' value='exp2(RX_DATA_FIFO_LEN_BITS)'/>
    

<module name='rf_spi' category='Modem'>

    <reg name='Ctrl' protect='rw'>
        <bits name='Enable' access='rw' rst='0' pos='0'>
            <comment>Enable the rf spi
                <br/>1 = Enable
                <br/>0 = Disable (will finish current command anyway)
            </comment>
        </bits>
        <bits name='CS_Polarity' access='rw' rst='1' pos='1'>
            <comment>Chip select polarity
                <br/>1 = the chip select is active low
                <br/>0 = the chip select is active high
            </comment>
        </bits>
        <bits name='DigRF_Read' access='rw' rst='1' pos='2'>
            <comment>DigRF Read style mode
                <br/>1 = DigRF Read style mode (read after CS disabled)
                <br/>0 = SPI Read mode (read during write)
            </comment>
        </bits>
        <bits name='Clocked_Back2Back' access='rw' rst='1' pos='3'>
            <comment>DigRF style clocked back to back mode
                <br/>1 = clocked back to back transfers using turnarround timing only when more data are present in the FIFO.
                <br/>0 = stop the clock between each access according to CS_End_Hold and CS_Pulse_Min timings
            </comment>
        </bits>
        <bits name='Input_Mode' access='rw' rst='1' pos='4'>
            <comment>Input mode
                <br/>1 = Record input data to input FIFO
                <br/>0 = No input data
            </comment>
        </bits>
        <bits name='Clock_Polarity' access='rw' rst='1' pos='5'>
            <comment>SPI Clock polarity
                <br/>1 = the clock disabled level is high, and the first edge is a falling edge.
                <br/>0 = the clock disabled level is low, and the first edge is a rising edge.
            </comment>
        </bits>
        <bits name='Clock_Delay' access='rw' rst='3' pos='7:6'>
            <comment>Transfer start to first edge delay
                <br/> value from 0 to 2 is the number of spi clock half period between the Transfer start and the first clock edge.
            </comment>
        </bits>
        <bits name='DO_Delay' access='rw' rst='3' pos='9:8'>
            <comment>Transfer start to first data out delay
                <br/> value from 0 to 2 is the number of spi clock half period between the Transfer start and the first data out.
            </comment>
        </bits>
        <bits name='DI_Delay' access='rw' rst='3' pos='11:10'>
            <comment>Transfer start to first data in sampled delay
                <br/> value from 0 to 3 is the number of spi clock half period between the Transfer start and the first data sampled in.
                <br/> The DI_Delay only specify the sampling time, for frame size, the counter is based on the DO_Delay even in DigRF read mode.
            </comment>
        </bits>
        <bits name='CS_Delay' access='rw' rst='3' pos='13:12'>
            <comment>Transfer start to CS activation delay
                <br/> value from 0 to 3 is the number of spi clock half period between the Transfer start and the CS activation edge.
            </comment>
        </bits>
        <bits name='CS_End_Hold' access='rw' rst='3' pos='15:14'>
            <comment>Transfer end to chip select deactivation delay
                <br/> value from 0 to 3 is the number of spi clock half period between the end of transfer (DO) and the CS deactivation edge.
                <br/> <Strong>Not used for Clocked_Back2Back mode</Strong>
            </comment>
        </bits>
        <bits name='Frame_Size' access='rw' rst='31' pos='20:16'>
            <comment>Number of data in the frame, or number of out data in DigRF read mode.
                <br/>The actual frame size is the value of this register + 1; valid value are 3 to 31 (frame size 4 to 32bits)
                <br/>The frame size is given for the number of data, the actual number of clock pulses might be greater. First if Clock_Delay &lt; DO_Delay an extra clock pulse is generated, second in case of DigRF read or back2back, some more clock pulses will be generated.
            </comment>
        </bits>
        <bits name='CS_End_Pulse' access='rw' rst='3' pos='23:22'>
            <comment>Chip select deactivation to new start of transfer minimum delay
                <br/>value from 0 to 3 is the number of spi clock half period between the CS deactivation and a new transfer start (transfer will start only if more data are available in the transmit FIFO)
                <br/> <Strong>Not used for Clocked_Back2Back mode</Strong>
            </comment>
        </bits>
        <bits name='Input_Frame_Size' access='rw' rst='31' pos='28:24'>
            <comment>Frame Size For Input in DigRF input mode
                <br/>The actual frame size is the value of this register + 1; valid value are 3 to 31 (frame size 4 to 32bits)
            </comment>
        </bits>
        <bits name='TurnAround_Time' access='rw' rst='3' pos='31:30'>
            <comment>TurnAround time: end of write frame to start of read frame delay (in cycles)
                <br/>value from 0 to 3 is the number of spi clock period between the end of the output frame (without the DO_Delay) and the Input Frame start.
                <br/>Also used for Clocked_Back2Back mode, when Clocked_Back2Back=1 and there is more data available in the transmit FIFO:
                <br/>value from 0 to 3 is the number of spi clock period between the end of the frame (without the DO_Delay) and the start of the new frame.
                (It can also be seen as the number of spi clock period between the end of the last data bit and the start of the new data bit.)
            </comment>
        </bits>
    </reg>
    <reg name='Status' protect='rw'>
        <bits name='Active_Status' access='r' rst='0' pos='0'>
            <comment>The SPI activity status
                <br/>1 = A transfer is in progress
                <br/>0 = The transfer is done
            </comment>
        </bits>
        <bits name='Error_Cmd' access='rc' rst='0' pos='1'>
            <comment>Error status
                <br/>1 = a new command (or gain) has been requested while a command was in progress.
                <br/>0 = No error
                <br/>Write 1 to clear.
            </comment>
        </bits>
        <bits name='Table_Ovf' access='rc' rst='0' pos='6'>
            <comment>The Gain Table overflow status.
                <br/>1 = Too many data has been written in the table
                <br/>Writing a 1 clear the overflow status.
            </comment>
        </bits>
        <bits name='Table_Udf' access='rc' rst='0' pos='7'>
            <comment>The Gain Table underflow status.
                <br/> 1 = a next gain request has been received while the read pointer was already at the top of the table.
                <br/> Writing a '1' clear the underflow status.
            </comment>
        </bits>
        <bits name='Cmd_Level' access='r' rst='0' pos='CMD_FIFO_LEN_BITS+7:8'>
            <options>
                <mask/>
                <shift/>
            </options>
            <comment>Command FIFO level, number of command in the FIFO
            </comment>
        </bits>
        <bits name='Cmd_Ovf' access='rc' rst='0' pos='14'>
            <comment>The command FIFO overflow status.
                <br/>1 = Too many data has been written in the FIFO
                <br/>Writing a 1 clear the overflow status.
            </comment>
        </bits>
        <bits name='Cmd_Udf' access='rc' rst='0' pos='15'>
            <comment>The command FIFO underflow status.
                <br/>1 = Data has been requested to read while the FIFO was empty
                <br/>Writing a 1 clear the underflow status.
            </comment>
        </bits>
        <bits name='Cmd_Data_Level' access='r' rst='0' pos='CMD_DATA_FIFO_LEN_BITS+16:16'>
            <options>
                <mask/>
                <shift/>
            </options>
            <comment>Command FIFO level, number of bytes in the FIFO
            </comment>
        </bits>
        <bits name='Cmd_Data_Ovf' access='rc' rst='0' pos='22'>
            <comment>The command data FIFO overflow status.
                <br/>1 = Too many data has been written in the FIFO
                <br/>Writing a 1 clear the overflow status.
            </comment>
        </bits>
        <bits name='Cmd_Data_Udf' access='rc' rst='0' pos='23'>
            <comment>The command data FIFO underflow status.
                <br/>1 = Data has been requested to read while the FIFO was empty
                <br/>Writing a 1 clear the underflow status.
            </comment>
        </bits>
        <bits name='Rx_Level' access='r' rst='0' pos='RX_DATA_FIFO_LEN_BITS+24:24'>
            <options>
                <mask/>
                <shift/>
            </options>
            <comment>Receive FIFO level, number of bytes in the FIFO
            </comment>
        </bits>
        <bits name='Rx_Ovf' access='rc' rst='0' pos='30'>
            <comment>The receive FIFO overflow status.
                <br/>1 = Too many data has been written in the FIFO
                <br/>Writing a 1 clear the overflow status.
            </comment>
        </bits>
        <bits name='Rx_Udf' access='rc' rst='0' pos='31'>
            <comment>The receive FIFO underflow status.
                <br/>1 = Data has been requested to read while the FIFO was empty
                <br/>Writing a 1 clear the underflow status.
            </comment>
        </bits>
    </reg>
    <reg name='Rx_Data' protect=''>
        <bits name='Rx_Data' access='rw' rst='no' pos='7:0'>
            <comment>Read in the receive FIFO
                <br/>Writing this register will write to Cmd_Data fifo (same as Cmd_Data register). This is because this address is used by the IFC channels to access the fifos.
            </comment>
        </bits>
    </reg>
    <reg name='Command' protect='w'>
        <bits name='Send_Cmd' access='w' pos='0'>
            <comment> Writing 1 send the next command in the Cmd FIFO (This replace the TCU next cmd signal)
            </comment>
        </bits>
        <bits name='Flush_Cmd_FIFO' access='w' pos='8'>
            <comment>Writing 1 flush both Cmd, and cmd_data FIFO, <Strong>don't do it when SPI is active (transfer in progress)</Strong>
            </comment>
        </bits>
        <bits name='Flush_Rx_FIFO' access='w' pos='16'>
            <comment>Writing 1 flush the receive data FIFO, <Strong>don't do it when SPI is active (transfer in progress)</Strong>
            </comment>
        </bits>
        <bits name='Restart_Gain' access='w' pos='24'>
            <comment>Writing 1 place the read pointer at the beginning of the gain table. <Strong>don't do it when SPI is active (transfer in progress)</Strong>
            </comment>
        </bits>
        <bits name='Reload_Gain' access='w' pos='28'>
            <comment>Writing 1 place the write pointer at the beginning of the gain table allowing to fill the table.
            </comment>
        </bits>
        <bits name='Drive_Zero' access='rw' rst='1' pos='31'>
            <comment>Writing 1 change all the ouputs of the SPI interface to drive a logical '0'. This mode stops when a new command is requested to be send (by TCU) or when writting 0 to this register. This mode is useful when powering off the tranciever chip connected to the RF_SPI.
            </comment>
        </bits>
    </reg>
    <reg name='Cmd_Size' protect='w'>
        <bits name='Cmd_Size' access='w' rst='no' pos='CMD_SIZE_BITS-1:0'>
            <comment>Write the size in bytes of the next command in the FIFO
            </comment>
        </bits>
        <bits name='Cmd_Mark' access='w' rst='no' pos='31'>
            <comment>Write 1 to mark the command.
                <br/>Marked commands are discarded if Enable_Rf_Spi_Marked_Cmd is low in the tcu register.
            </comment>
        </bits>
    </reg>
    <reg name='Cmd_Data' protect='w'>
        <bits name='Cmd_Data' access='w' rst='no' pos='7:0'>
            <comment>Write in the Command data FIFO
            </comment>
        </bits>
    </reg>
    <reg name='Gain_Size' protect='rw'>
        <bits name='Gain_Size' access='rw' rst='0' pos='GAIN_SIZE_BITS-1:0'>
            <comment>Size of a Gain command in bytes.
            </comment>
        </bits>
    </reg>
    <reg name='Gain_Data' protect='w'>
        <bits name='Gain_Data' access='w' rst='no' pos='7:0'>
            <comment>Write in the Gain Table (the pointer auto increments)
            </comment>
        </bits>
    </reg>
    <reg name='IRQ' protect='rw'>
        <bits name='Cmd_Data_DMA_Done_Cause' access='rc' rst='0' pos='0'>
            <comment>Cmd_Data_DMA_Done IRQ Cause bit
                <br/> 1 = the IRQ was triggered by the end of the DMA transfer to the cmd FIFO.
                <br/> To clear it write 1 in this bit or Cmd_Data_DMA_Done_Status bit.
            </comment>
        </bits>
        <bits name='Cmd_FIFO_empty_Cause' access='r' rst='0' pos='2'>
            <comment>Cmd_FIFO_empty IRQ Cause bit
                <br/> 1 = the IRQ was triggered because the Cmd_FIFO is empty.
                <br/> To clear it, fill the FIFO.
            </comment>
        </bits>
        <bits name='Cmd_Threshold_Cause' access='r' rst='0' pos='3'>
            <comment>Cmd_Threshold IRQ Cause bit
                <br/> 1 = the IRQ was triggered because the Cmd_FIFO level is below the Cmd_Threshold.
                <br/> To clear it, fill the FIFO.
            </comment>
        </bits>
        <bits name='Rx_FIFO_full_Cause' access='r' rst='0' pos='4'>
            <comment>Rx_FIFO_full IRQ Cause bit
                <br/> 1 = the IRQ was triggered because the Rx_Data_FIFO is full.
                <br/> To clear it, read from the FIFO.
            </comment>
        </bits>
        <bits name='Rx_Threshold_Cause' access='r' rst='0' pos='5'>
            <comment>Rx_Threshold IRQ Cause bit
                <br/> 1 = the IRQ was triggered because the Rx_Data_FIFO level is over the Rx_Threshold.
                <br/> To clear it, read from the FIFO.
            </comment>
        </bits>
        <bits name='Error_Cause' access='r' rst='0' pos='6'>
            <comment>Error IRQ Cause bit
                <br/> 1 = the IRQ was triggered because an error occured. Read the Status register to check the kind of error.
                <br/> To clear it, clear it in the Status register.
            </comment>
        </bits>
        <bitgroup name='All_Cause'>
            <entry ref='Cmd_Data_DMA_Done_Cause'/>
            <entry ref='Cmd_FIFO_empty_Cause'/>
            <entry ref='Cmd_Threshold_Cause'/>
            <entry ref='Rx_FIFO_full_Cause'/>
            <entry ref='Rx_Threshold_Cause'/>
            <entry ref='Error_Cause'/>
        </bitgroup>
        <bits name='Cmd_Data_DMA_Done_Status' access='rc' rst='0' pos='16'>
            <comment>Cmd_Data_DMA_Done IRQ Status bit
                <br/> 1 = the end of the DMA transfer to the cmd FIFO occured.
                <br/> To clear it write 1 in this bit or Cmd_Data_DMA_Done_Cause bit.
            </comment>
        </bits>
        <bits name='Cmd_FIFO_empty_Status' access='r' rst='0' pos='18'>
            <comment>Cmd_FIFO_empty IRQ Status bit
                <br/> 1 = the Cmd_FIFO is empty.
            </comment>
        </bits>
        <bits name='Cmd_Threshold_Status' access='r' rst='0' pos='19'>
            <comment>Cmd_Threshold IRQ Status bit
                <br/> 1 = the Cmd_FIFO level is bellow the Cmd_Threshold.
            </comment>
        </bits>
        <bits name='Rx_FIFO_full_Status' access='r' rst='0' pos='20'>
            <comment>Rx_FIFO_full IRQ Status bit
                <br/> 1 = the Rx_Data_FIFO is full.
            </comment>
        </bits>
        <bits name='Rx_Threshold_Status' access='r' rst='0' pos='21'>
            <comment>Rx_Threshold IRQ Status bit
                <br/> 1 = the Rx_Data_FIFO level is over the Rx_Threshold.
            </comment>
        </bits>
        <bits name='Error_Status' access='r' rst='0' pos='22'>
            <comment>Error IRQ Status bit
                <br/> 1 = an error occured. Read the Status register to check the kind of error.
            </comment>
        </bits>
        <bitgroup name='All_Status'>
            <entry ref='Cmd_Data_DMA_Done_Status'/>
            <entry ref='Cmd_FIFO_empty_Status'/>
            <entry ref='Cmd_Threshold_Status'/>
            <entry ref='Rx_FIFO_full_Status'/>
            <entry ref='Rx_Threshold_Status'/>
            <entry ref='Error_Status'/>
        </bitgroup>
    </reg>
    <reg name='IRQ_Mask' protect='rw'>
        <bits name='Cmd_Data_DMA_Done_Mask' access='rw' rst='0' pos='0'>
            <comment>Cmd_Data_DMA_Done IRQ Mask bit
                <br/> 1 = the Cmd_Data_DMA_Done IRQ is enabled
                <br/> 0 = the Cmd_Data_DMA_Done IRQ is disabled
            </comment>
        </bits>
        <bits name='Cmd_FIFO_empty_Mask' access='rw' rst='0' pos='2'>
            <comment>Cmd_FIFO_empty IRQ Mask bit
                <br/> 1 = the Cmd_FIFO_empty IRQ is enabled
                <br/> 0 = the Cmd_FIFO_empty IRQ is disabled
            </comment>
        </bits>
        <bits name='Cmd_Threshold_Mask' access='rw' rst='0' pos='3'>
            <comment>Cmd_Threshold IRQ Mask bit
                <br/> 1 = the Cmd_Threshold IRQ is enabled
                <br/> 0 = the Cmd_Threshold IRQ is disabled
            </comment>
        </bits>
        <bits name='Rx_FIFO_full_Mask' access='rw' rst='0' pos='4'>
            <comment>Rx_FIFO_full IRQ Mask bit
                <br/> 1 = the Rx_FIFO_full IRQ is enabled
                <br/> 0 = the Rx_FIFO_full IRQ is disabled
            </comment>
        </bits>
        <bits name='Rx_Threshold_Mask' access='rw' rst='0' pos='5'>
            <comment>Rx_Threshold IRQ Mask bit
                <br/> 1 = the Rx_Threshold IRQ is enabled
                <br/> 0 = the Rx_Threshold IRQ is disabled
            </comment>
        </bits>
        <bits name='Error_Mask' access='rw' rst='0' pos='6'>
            <comment>Error IRQ Mask bit
                <br/> 1 = the Error IRQ is enabled
                <br/> 0 = the Error IRQ is disabled
            </comment>
        </bits>
        <bitgroup name='All_Mask'>
            <entry ref='Cmd_Data_DMA_Done_Mask'/>
            <entry ref='Cmd_FIFO_empty_Mask'/>
            <entry ref='Cmd_Threshold_Mask'/>
            <entry ref='Rx_FIFO_full_Mask'/>
            <entry ref='Rx_Threshold_Mask'/>
            <entry ref='Error_Mask'/>
        </bitgroup>
    </reg>
    <reg name='IRQ_Threshold' protect='rw'>
        <bits name='Cmd_Threshold' access='r' rst='all1' pos='CMD_FIFO_LEN_BITS+7:8'>
            <comment>Command FIFO Threshold, number of command in the FIFO bellow which the Cmd_Threshold_IRQ is triggered.
            </comment>
        </bits>
        <bits name='Rx_Threshold' access='r' rst='all1' pos='RX_DATA_FIFO_LEN_BITS+23:24'>
            <comment>Receive FIFO Threshold, number of bytes in the FIFO above which the Rx_Threshold_IRQ is triggered.
            </comment>
        </bits>
    </reg>
    <reg name='Divider' protect='rw'>
        <bits name='Divider' access='rw' rst='0' pos='6:1'>
            <comment>Clock Divider
                <br/>The state machine clock is generated by dividing the system clock by the value of this register + 1. So the output clock is divided by (register + 1)*2
            </comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name='Clock_Limiter' access='rw' rst='0' pos='28'>
            <comment>When enabled the clock input to the divider is not the system clock, but a limited version of it: It cannot be above 52MHz, so the output clock will never be above 26MHz.
                <br/> for system clock of 104Mhz the clock input to the divider is 52Mhz, for system clock of 78Mhz the clock input to the divider is 39Mhz, for lower system clock value, the input to the divider is the system clock.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
</module>
</archive>
<archive relative='sci.xml'>

<module name='sci' category='Modem'>
    <reg name='Config' protect='rw'>
        <bits name='Enable' access='rw' rst='0' pos='0'>
            <comment>Enables the SIM Card IF module
            </comment>
        </bits>
        <bits name='Parity' access='rw' rst='0' pos='1'>
            <comment>Selects the parity generation/detection
            </comment>
            <options>
                <option name='Even_parity' value='0'/>
                <option name='Odd_parity' value='1'/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name='PERF' access='rw' rst='0' pos='2'>
            <comment>Parity Error Receive Feed-through
                <br/>0 = Don't store bytes with detected parity errors
                <br/>1 = Feed-through bytes with detected parity errors
            </comment>
        </bits>
        <bits name='Filter_Disable' access='rw' rst='0' pos='3'>
            <comment>Enable or disable NULL (0x60) character filtering when SIM card sends NULL to reset WWT timer.
                <br/>0 = Enable NULL character filtering, NULL characters are not reported if not data.
                <br/>1 = Disable NULL character filtering.  NULL characters (0x60) are transferred to the SCI data buffer.
            </comment>
        </bits>
        <bits name='ClockStop' access='rw' rst='1' pos='4'>
            <comment>Manual SCI Clock Stop control.  Manually starts and stops the SCI clock.  This bit must be set to '1' when Autostop mode is enabled.
                <br/>0 = Enable the SCI clock
                <br/>1 = Disable SCI clock
            </comment>
        </bits>
        <bits name='AutoStop_En_H' access='rw' rst='0' pos='5'>
            <comment>Enables automatic clock shutdown when command is complete.  Enabling this will generate the necessary startup and shutdown delays required by the SIM protocol.
                <br/>0 = Auto clock control not enabled.  SCI clock controlled by SCI_Clockstop bit
                <br/>1 = Auto clock control enabled.
            </comment>
        </bits>
        <bits name='MSBH_LSBL' access='rw' rst='1' pos='6'>
            <comment>Sets the transmission and reception bit order:
                <br/>0 = LSB is sent/recieved first (Direct convention)
                <br/>1 = MSB is sent/received first (Inverse convention)
            </comment>
        </bits>
        <bits name='LLI' access='rw' rst='1' pos='7'>
            <comment>Logic Level Invert:
                <br/>0 = Logic level 0 data is sent/received as '0' or 'A' which is the same as the start bit.  (Direct convention)
                <br/>1 = Logic level 0 data is sent/received as '1' or 'Z' which is the opposite of the start bit.  (Inverse convention)
            </comment>
        </bits>
        <bits name='PEGen_Len' access='rw' rst='0' pos='8'>
            <comment>Parity Error signal length.  This configuration bit can be used to extend the duration of the parity error signal generation from 1 ETU to 1.5 ETU
                <br/>0 = Parity Error signal duration is 1 ETU starting at 10.5 ETU
                <br/>1 = Parity Error signal duration is 1.5 ETU starting at 10.5 ETU
            </comment>
        </bits>
        <bits name='Parity_En' access='rw' rst='0' pos='9'>
            <comment>Enable or disable parity error checking on the receive data
                <br/>0 = Disable parity error checking
                <br/>1 = Enable parity error checking
            </comment>
        </bits>
        <bits name='Stop_Level' access='rw' rst='1' pos='10'>
            <comment>Logical value of the clock signal when SCI clock is stopped (either due to automatic shutdown or manual shutdown)
                <br/>0 = Stop clock at low level
                <br/>1 = Stop clock at high level
            </comment>
        </bits>
        <bits name='ARG_H' access='rw' rst='0' pos='16'>
            <comment>Automatic Reset Generator.  Write a '1' to this bit to initiate an automatic reset procedure on the SIM.  Write '0' to switch back to SCI_Reset control (bit 20).  An ARG interrupt will be generated if the ARG process succeeded or failed.  The ARG status bit (ARG_Det) must be read to determine if a reset response from the card was detected.  This bit needs to be cleared between ARG attempts.
            </comment>
        </bits>
        <bits name='AFD_En_H' access='rw' rst='0' pos='17'>
            <comment>Automatic format detection.  This bit is generally set in conjunction with the ARG_H bit to enable automatic detection of the data convention.
                <br/>1 = Enable TS detection and automatic convention settings programming
                <br/>0 = disable automatic settings and use the register bits (MSBH_LSBL and LLI) to control the convention
            </comment>
        </bits>
        <bits name='Tx_Resend_En_H' access='rw' rst='1' pos='18'>
            <comment>1 = Enable automatic resend of characters when Tx parity error is detected
                <br/>0 = Disable automatic resend
            </comment>
        </bits>
        <bits name='Reset' access='rw' rst='0' pos='20'>
            <comment>Direct connection to the SIM card reset pin.  This is overridden when ARG_H is enabled
                <br/>0 = SCI_Reset low voltage
                <br/>1 = SCI Reset high voltage
            </comment>
        </bits>
        <bits name='Dly_Sel' access='rw' rst='0' pos='21'>
            <comment>This selects between two delay times for the automatic clock stop startup and shutdown:
                <br/>0 = short delay
                <br/>Startup/Shutdown : 744 SCI clocks / 1860 SCI clocks
                <br/>1 = long delay
                <br/>Startup/Shutdown : (2 x 744) SCI clocks / (2 x 1860) SCI clocks
            </comment>
        </bits>
        <bits name='Par_Chk_Offset' access='rw' rst='0xe' pos='29:24'>
            <comment>Allows fine control of the parity check position during the parity error time period.
            </comment>
        </bits>
        <bits name='Reserved' access='rw' rst='0' pos='31:30'>
            <comment>These bits are reserved and must be written as '00' for the SCI module to work properly:
                <br/>"11" = Ser In &lt;- Ser Out loopback
                <br/>"10" = Ser In &lt;- Ser In (unmasked)
                <br/>others = Ser In &lt;- Ser In masked with Txing_H (normal mode)
            </comment>
        </bits>
    </reg>
    <reg name='Status' protect='r'>
        <bits name='RxData_Rdy' access='r' pos='0'>
            <comment>Returns the status of the Rx FIFO:
                <br/>0 = Rx FIFO empty
                <br/>1 = There is at least 1 character in the Rx FIFO
            </comment>
        </bits>
        <bits name='Tx_FIFO_Rdy' access='r' pos='1'>
            <comment>Returns the status of the Tx FIFO:
                <br/>0 = Tx FIFO is full
                <br/>1 = There is at least 1 free spot in the Tx FIFO
            </comment>
        </bits>
        <bits name='Format_Det' access='r' pos='2'>
            <comment>Returns the status of the automatic format detection after reset:
                <br/>0 = TS character has not been detected in the ATR
                <br/>1 = TS character has been detected and SCI module is using the automatic convention settings
                <br/>
                <br/>This bit is cleared when the AFD_En bit is cleared
            </comment>
        </bits>
        <bits name='ARG_Det' access='r' pos='3'>
            <comment>Returns the status of the automatic reset procedure:
                <br/>0 = ARG detection has failed
                <br/>1 = ARG detection has detected that the SIM has responded to the reset
                <br/>
                <br/>This bit is used in conjunction with the ARG interrupt.  The ARG interrupt will be generated at the successful or unsuccessful termination of the ARG process.  This bit can be used to determine the success or failure.
            </comment>
        </bits>
        <bits name='Reset' access='r' pos='4'>
            <comment>This is the status of the Reset pin when automatic reset generation is enabled.  This bit can be used to discover whether the SIM card that has successfully responded to an ARG procedure has an active high or active low reset.
            </comment>
        </bits>
        <bits name='Clk_Rdy_H' access='r' pos='5'>
            <comment>Status of the control signal to the clock control module.  This bit respects the startup and shutdown phases, so during these times, the clock may actually be on, but it is not considered to be 'ready'
                <br/>0 = SCI clock may be on or off but is not ready for use
                <br/>1 = SCI clock is on and ready for use
            </comment>
        </bits>
        <bits name='Clk_Off' access='r' pos='6'>
            <comment>Status bit of the Sci clock. 
                <br/>0 = Sci clock is ON
                <br/>1 = Sci clock is OFF
            </comment>
        </bits>
        <bits name='Rx_Err' access='r' pos='8'>
            <comment>A receive parity error was detected. Reading this register clears the bit.
            </comment>
        </bits>
        <bits name='Tx_Err' access='r' pos='9'>
            <comment>A transmit parity error was detected. Reading this register clears the bit.
            </comment>
        </bits>
        <bits name='RxOverflow' access='r' pos='10'>
            <comment>The internal receive FIFO has reached an overflow condition. Reading this register clears the bit.
            </comment>
        </bits> 
        <bits name='TxOverflow' access='r' pos='11'>
            <comment>The internal transmit FIFO has reached an overflow condition. Reading this register clears the bit.
            </comment>
        </bits>
        <bits name='AutoStop_State' access='r' pos='31:30'>
            <comment>Returns the state of the clock management state machine when AutoStop mode is enabled.  This value is '00' when manual mode is selected.
            </comment>
            <options>
                <option name='Startup_phase' value='0'><comment>Clock is on, but not ready to be used.</comment></option>
                <option name='Auto_on' value='1'><comment>Clock is on and ready to be used</comment></option>
                <option name='Shutdown_phase' value='2'><comment>Clock is still on, but should not be used.</comment></option>
                <option name='Clock_off' value='3'><comment>Clock is off.</comment></option>
                <mask/>
                <shift/>
            </options>
        </bits>
    </reg>
    <reg name='Data' protect='--'>
        <bits name='Data_IN' access='w' pos='7:0'>
            <comment>Writing to this register will send the data to the SIM card. If automatic clock shutdown is enabled, the appropriate delay will be applied before the data is actually sent. 
            </comment>
        </bits>
        <bits name='Data_OUT' access='r' pos='7:0'>
            <comment>Reading this register will read from the receive data FIFO.
            </comment>
        </bits>
    </reg>
    <reg name='ClkDiv' protect='rw'>
        <bits name='ClkDiv' access='rw' rst='0x174' pos='8:0'>
            <comment>Clock divider for generating the baud clock from the SCI clock.  This value must match the value used by the SIM card whose default value is 0x174.
            </comment>
        </bits>
        <bits name='ClkDiv_16' access='rw' rst='0x18' pos='23:16'>
            <comment>Secondary clock divider for generating 16x baud clock.
            </comment>
        </bits>
        <bits name='MainDiv' access='rw' rst='0x4' pos='30:24'>
            <comment>Main clock divider to generate the SCI clock.  This value should be calculated as follows:
                <br/>MainDiv = Clk_Sys/(2xSCI_Clk) - 1
                <br/>where SCI_Clk is in the range of 3-5 MHz as specified in the SIM specification.
            </comment>
            <options><mask/><default/></options>
        </bits>
        <bits name='Clk_Inv' access='rw' rst='0' pos='31'>
            <comment>Inverts the polarity of the SCI clock to the SIM card.
                <br/>0 = No inversion
                <br/>1 = Invert external SCI clock
            </comment>
        </bits>
    </reg>
    <reg name='RxCnt' protect='rw'>
        <bits name='RxCnt' access='rw' rst='0' pos='9:0'>
            <comment>This value should be programmed with the number of expected characters to receive.  It will be decremented each time a character is <strong>actually</strong> received and should be 0 when the transfer is complete.  If a character is sent after the RxCnt reaches zero, the extra character flag will be set but this value will stay at zero.
            </comment>
        </bits>
        <bits name='Clk_Persist' access='rw' rst='0' pos='31'>
            <comment>When in automatic clock shutdown mode, this bit can prevent the clock from entering shutdown mode when the transfer is complete.  This should be used for multi-transfer commands where the clock must not be shut down until the command is complete.  This bit must be programmed for each transfer.
                <br/>1 = Keep clock on
                <br/>0 = Allow clock shutdown when transfer is complete
            </comment>
        </bits>
    </reg>
    <reg name='Times' protect='rw'>
        <bits name='ChGuard' access='rw' rst='1' pos='7:0'>
            <comment>This is the extra guard time that can be added to the 2 ETU minimum (and default) guard time between successive transmitted characters.  This should be programmed depending on the SIM's ATR.  The total ETU guard time will be ChGuard + 1.
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name='TurnaroundGuard' access='rw' rst='0x6' pos='11:8'>
            <comment>Turnaround guard time configuration.  This value can be used to adjust the delay between the leading edge of a received character and the leading edge of the next transmitted character.  The minimum time specified in the SIM recommendation is 16 ETU.  The number of ETUs can be calculated using the following formula:
                <br/>Total Turnaround Time (in ETUs) = 11 + TurnaroundGuard
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name='WI' access='rw' rst='0x0A' pos='23:16'>
            <comment>Work Waiting Time factor.  A timeout will be generated when the WWT is exceeded.  The WWT is calculated by:
                <br/>       WWT = 960 x WI x (F/Fi)
                <br/>where Fi is the main SCI clock frequency (3-5 MHz) and F is 372 before an enhanced PPS and 512 after an enhanced PPS.
                <br/>The SCI_WI value must be calculated as follows:
                <br/>       SCI_WI = WI * D
                <br/>Thus, by default (WI = 10) this value needs to be set to 10 before an EPPS, but needs to be scaled to WI*D=80 after the EPPS procedure.
            
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name='Tx_PERT' access='rw' rst='0xFF' pos='31:24'>
            <comment>Number of times to try resending character when the SIM indicates a parity error.
            </comment>
        </bits>
    </reg>  
    <reg name='Ch_Filt' protect='rw'>
        <bits name='Ch_Filt' access='rw' rst='0x60' pos='7:0'>
            <comment>Value of the character to be filtered.  0x60 is the NULL character in the SIM protocol.  If character filtering is enabled, the <strong>first</strong> 0x60 character that is received by the SIM during a transfer will <strong>not</strong> be recorded.  The purpose of this character is to enable the SIM to reset the WWT counter when the SIM is not ready to send the data.  This filter has no effect on characters within the datastream.
            </comment>
        </bits>
    </reg>  
    
    <reg name='dbg' protect='rw'>
        <comment>UNDOCUMENTED FEATURE</comment>
    </reg>  
    <reg name='Int_Cause' protect='r'>
        <bits name='Rx_Done' access='r' rst='0' pos='0'>
            <comment>Number of expected Rx characters, as programmed in the RxCnt register, has been received.
            </comment>
        </bits>
        <bits name='Rx_Half' access='r' rst='0' pos='1'>
            <comment>Receiver FIFO is half full.
            </comment>
        </bits>
        <bits name='WWT_Timeout' access='r' rst='0' pos='2'>
            <comment>No Tx character has been sent NOR any Rx character detected within the WWT timeout.
            </comment>
        </bits>
        <bits name='Extra_Rx' access='r' rst='0' pos='3'>
            <comment>An extra character has been received after the number of characters in RxCnt has been received.
            </comment>
        </bits>
        <bits name='Resend_Ovfl' access='r' rst='0' pos='4'>
            <comment>The automatic re-transmit of parity error characters has exceeded the threshold specified in the Tx_PERT field.
            </comment>
        </bits>     
        <bits name='ARG_End' access='r' rst='0' pos='5'>
            <comment>End of the ARG sequence. The status register must be read to determine whether the ARG sequence was successful or not.
            </comment>
        </bits>     
        <comment>
            This register is a <b>READ ONLY</b> register that returns the logical <b>and</b> of the SCI_INT_STATUS register and the SCI_INT_MASK. If any of these bits is '1', the SCI module will generate an interrupt.  Bits 21:16 return the <u>status</u> of the interrupt which is the interrupt state before the mask is applied.  These bits should only be used for debugging.
        </comment>
    </reg>  
    <reg name='Int_Clr' protect='w'>
        <bits name='Rx_Done' access='c' pos='0'>
            <comment>Number of expected Rx characters, as programmed in the SCI_RxCnt register, has been received.
            </comment>
        </bits>
        <bits name='Rx_Half' access='c' pos='1'>
            <comment>Receiver FIFO is half full.
            </comment>
        </bits>
        <bits name='WWT_Timeout' access='c' pos='2'>
            <comment>No Tx character has been sent NOR any Rx character detected within the WWT timeout.
            </comment>
        </bits>
        <bits name='Extra_Rx' access='c' pos='3'>
            <comment>An extra character has been received after the number of characters in SCI_RxCnt has been received.
            </comment>
        </bits>
        <bits name='Resend_Ovfl' access='c' pos='4'>
            <comment>The automatic re-transmit of parity error characters has exceeded the threshold specified in the SCI_Tx_PERT field.
            </comment>
        </bits>     
        <bits name='ARG_End' access='c' pos='5'>
            <comment>End of the ARG sequence. The status register must be read to determine whether the ARG sequence was successful or not.
            </comment>
        </bits>     
        <comment>
            This is a WRITE ONLY register that is used to clear an SCI interrupt. Write a '1' to the interrupt that is to be cleared. Writing '0' has no effect.
        </comment>
    </reg>  
    <reg name='Int_Mask' protect='rw'>
        <bits name='Rx_Done' access='rw' rst='0' pos='0'>
            <comment>Number of expected Rx characters, as programmed in the SCI_RxCnt register, has been received.
            </comment>
        </bits>
        <bits name='Rx_Half' access='rw' rst='0' pos='1'>
            <comment>Receiver FIFO is half full.
            </comment>
        </bits>
        <bits name='WWT_Timeout' access='rw' rst='0' pos='2'>
            <comment>No Tx character has been sent NOR any Rx character detected within the WWT timeout.
            </comment>
        </bits>
        <bits name='Extra_Rx' access='rw' rst='0' pos='3'>
            <comment>An extra character has been received after the number of characters in SCI_RxCnt has been received.
            </comment>
        </bits>
        <bits name='Resend_Ovfl' access='rw' rst='0' pos='4'>
            <comment>The automatic re-transmit of parity error characters has exceeded the threshold specified in the SCI_Tx_PERT field.
            </comment>
        </bits>     
        <bits name='ARG_End' access='rw' rst='0' pos='5'>
            <comment>End of the ARG sequence. The status register must be read to determine whether the ARG sequence was successful or not.
            </comment>
        </bits>     
        <comment>
            This register is READ/WRITE register that enables the desired interrupt. A '1' in a bit position indicates that the corresponding interrupt is enabled and if the interrupt occurs, the SCI will generate a hardware interrupt.
        </comment>
    </reg>  
</module>
</archive>
<archive relative='spi.xml'>

<var name='SPI_TX_FIFO_SIZE' value='16'/>
<var name='SPI_RX_FIFO_SIZE' value='16'/>

<module name='spi' category='Periph'>
    <reg name='ctrl' protect='rw'>
        <bits name='Enable' access='rw' pos='0'>
            <comment>Enable the module and activate the chip select selected by CS_sel field.
            </comment>
        </bits>
        <bits name='CS_sel' access='rw' pos='1:2'>
            <comment>Selects the active CS.
            </comment>
            <options>
                <option name='CS0' value='0'/>
                <option name='CS1' value='1'/>
                <option name='CS2' value='2'/>
                <option name='CS3' value='3'/>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name='Input_sel' access='rw' pos='3'>
            <comment>Selects the input line to be used as SPI data in.
                <br/>when '0' the SPI_DI_0 is used.
                <br/>When '1' the SPI_DI_1 is used.
            </comment>
        </bits>
        <bits name='Input_mode' access='rw' rst='1' pos='4'>
            <comment>When set to 1 the inputs are activated, else only the output is driven and no data are stored in the receive FIFO.
            </comment>
        </bits>
        <bits name='Clock_Polarity' access='rw' rst='1' pos='5'>
            <comment>The spi clock polarity
                <br/>when '0' the clock disabled level is low, and the first edge is a rising edge.
                <br/>When '1' the clock disabled level is high, and the first edge is a falling edge.
            </comment>
        </bits>
        <bits name='Clock_Delay' access='rw' rst='3' pos='7:6'>
            <comment>Transfer start to first edge delay value from 0 to 2 is the number of spi clock half period between the CS activation and the first clock edge.
            </comment>
        </bits>
        <bits name='DO_Delay' access='rw' rst='3' pos='9:8'>
            <comment>Transfer start to first data out delay value from 0 to 2 is the number of spi clock half period between the CS activation and the first data out
            </comment>
        </bits>
        <bits name='DI_Delay' access='rw' rst='3' pos='11:10'>
            <comment>Transfer start to first data in sample delay value from 0 to 3 is the number of spi clock half period between the CS activation and the first data in sampled.
                <br/>NOTE: DI_Delay must be less or equal to DO_Delay + CS_Delay + 2.
                <br/>In other words DI_Delay can be 3 only if DO_Delay and CS_Delay are not both equal to 0.
            </comment>
        </bits>
        <bits name='CS_Delay' access='rw' rst='3' pos='13:12'>
            <comment>Transfer end to chip select deactivation delay value from 0 to 3 is the number of spi clock half period between the end of transfer and CS deactivation
            </comment>
        </bits>
        <bits name='CS_Pulse' access='rw' rst='3' pos='15:14'>
            <comment>Chip select deactivation to reactivation minimum delay value from 0 to 3 is the number of spi clock half period between the CS deactivation and a new CS activation (CS will activate only if more data are available in the transmit FIFO)
            </comment>
        </bits>
        <bits name='Frame_Size' access='rw' rst='31' pos='20:16'>
            <comment>Frame Size
                <br/>The frame size is the binary value of this register + 1 valid value are 3 to 31 (frame size 4 to 32bits)
            </comment>
        </bits>
        <bits name='OE_delay' access='rw' rst='31' pos='28:24'>
            <comment>OE delay
                <br/>When 0: regular mode, SPI_DO pin as output only.
                <br/>Value from 1 to 31 is the number of data out to transfert before the SPI_DO pin switch to input.
            </comment>
        </bits>
        
    </reg>
        
    <reg name='status' protect='rw'>

        <bits name='Active_Status' access='r' pos='0'>
            <comment>'1' when a transfer is in progress.
            </comment>
        </bits>
        <bits name='Cause_Rx_Ovf_Irq' access='rw' pos='3'>
            <comment>The receive FIFO overflow irq cause.
                <br/>Writing a '1' clear the receive overflow status and cause.
            </comment>
        </bits>
        <bits name='Cause_Tx_Th_Irq' access='r' pos='4'>
            <comment>The transmit FIFO threshold irq cause.
            </comment>
        </bits>
        <bits name='Cause_Tx_Dma_Irq' access='rw' pos='5'>
            <comment>The transmit Dma Done irq cause.
                <br/>Writing a '1' clear the transmit Dma Done status and cause.
            </comment>
        </bits>
        <bits name='Cause_Rx_Th_Irq' access='r' pos='6'>
            <comment>The receive FIFO threshold irq cause.
            </comment>
        </bits>
        <bits name='Cause_Rx_Dma_Irq' access='rw' pos='7'>
            <comment>The receive Dma Done irq cause.
                <br/>Writing a '1' clear the receive Dma Done status and cause.
            </comment>
        </bits>
        <bitgroup name='Irq_Cause'>
            <entry ref='Cause_Rx_Ovf_Irq'/>
            <entry ref='Cause_Tx_Th_Irq'/>
            <entry ref='Cause_Tx_Dma_Irq'/>
            <entry ref='Cause_Rx_Th_Irq'/>
            <entry ref='Cause_Rx_Dma_Irq'/>
        </bitgroup>
        <bits name='Tx_Ovf' access='rw' pos='9'>
            <comment>The transmit FIFO overflow status.
                <br/>Writing a '1' clear the transmit overflow status and cause.
            </comment>
        </bits>
        <bits name='Rx_Udf' access='rw' pos='10'>
            <comment>The receive FIFO underflow status.
                <br/>Writing a '1' clear the receive underflow status and cause.
            </comment>
        </bits>
        <bits name='Rx_Ovf' access='rw' pos='11'>
            <comment>The receive FIFO overflow status.
                <br/>Writing a '1' clear the receive overflow status and cause.
            </comment>
        </bits> 
        <bits name='Tx_Th' access='r' pos='12'>
            <comment>The transmit FIFO threshold status.
            </comment>
        </bits> 
        <bits name='Tx_Dma_Done' access='rw' pos='13'>
            <comment>The transmit Dma Done status.
                <br/>Writing a '1' clear the transmit Dma Done status and cause.
            </comment>
        </bits> 
        <bits name='Rx_Th' access='r' pos='14'>
            <comment>The receive FIFO threshold status.
            </comment>
        </bits> 
        <bits name='Rx_Dma_Done' access='rw' pos='15'>
            <comment>The receive Dma Done status.
                <br/>Writing a '1' clear the receive Dma Done status and cause.
            </comment>
        </bits> 
        <bits name='Tx_Space' access='r' rst='16' pos='20:16'>
            <comment>Transmit FIFO Space
                <br/>Number of empty spot in the FIFO
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits> 
        <bits name='Rx_Level' access='r' pos='28:24'>
            <comment>Receive FIFO level
                <br/>Number of bytes in the FIFO
            </comment>
            <options>
                <mask/>
                <shift/>
            </options>
        </bits> 
        <bits name='FIFO_Flush' access='w' pos='30'>
            <comment>Writing '1' flush both FIFO, don't do it when SPI is active (transfer in progress)
            </comment>
        </bits>
    </reg>
    <reg name='rxtx_buffer' protect='--'>
        <bits name='DATA_IN' access='w' pos='7:0'>
            <comment>Write to the transmit FIFO
            </comment>
        </bits>
        <bits name='DATA_OUT' access='r' pos='7:0'>
            <comment>Read in the receive FIFO
            </comment>
        </bits>
    </reg>
    <reg name='cfg' protect='rw'>
        <bits name='CS_Polarity' cut='1' cutprefix='CS_Polarity' access='rw' rst='all1' pos='3:0'>
            <comment>Chip select polarity
            </comment>
            <options>
                <option name='active high' value='0'><comment>chip select is active high</comment></option>
                <option name='active low' value='1'><comment>chip select is active low</comment></option>
                <mask/><shift/><default/>
            </options>
        </bits>
        <bits name='Clock_Divider' access='rw' rst='1023' pos='25:16'>
            <comment>Clock Divider
                <br/>The state machine clock is generated by dividing the system clock by the value of this register + 1.
                <br/>So the output clock is divided by (register + 1)*2
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name='Clock_Limiter' access='rw' rst='0' pos='28'>
            <comment>When enabled the clock input to the divider is not the system clock, but a limited version of it: It cannot be above 52MHz, so the output clock will never be above 26MHz.
                <br/> for system clock of 104Mhz the clock input to the divider is 52Mhz, for system clock of 78Mhz the clock input to the divider is 39Mhz, for lower system clock value, the input to the divider is the system clock.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>

    </reg>

    <reg name='pattern' protect='rw'>
        <bits name='pattern' access='rw' pos='7:0'>
            <comment>MMC Pattern value for RX pattern match mode.
            </comment>
        </bits>
        <bits name='pattern_mode' access='rw' rst='0' pos='8'>
            <comment> Enable the pattern mode.
            </comment>
            <options>
                <option name='disabled' value='0'><comment>Spi Behaviour.</comment></option>
                <option name='enabled' value='1'><comment>Pattern matching.</comment></option>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name='pattern_selector' access='rw' rst='0' pos='9'>
            <comment> Select the RX pattern matching mode when the pattern_mode is enabled( set 1). Used for SD/MMC SPI mode.</comment>
            <options>
                <option name='UNTIL' value='0'><comment>No datas are written into the RX FIFO UNTIL the received data is equal to the pattern.</comment></option>
                <option name='WHILE' value='1'><comment>No datas are written into the RX FIFO WHILE the received data is equal to the pattern.</comment></option>
                <default/><shift/><mask/>
            </options>
        </bits>
    </reg>
    
    <reg name='stream' protect='rw'>
        <bits name='tx_stream_bit' access='rw' rst='0' pos='0'>
            <comment>When TX stream mode is enabled, once the TX fifo is empty, all new bits send have the value of this bit.
            </comment>
            <options>
                <option name='zero' value='0'/>
                <option name='one' value='1'/>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name='tx_stream_mode' access='rw' rst='0' pos='8'>
            <comment>Enable the TX stream mode. Used for SD/MMC SPI mode.
                <br/>When enabled, this mode provide infinite bit stream for sending, after fifo is empty the extra bits generated all have the same value. The value is in tx_stream_bit.
            </comment>    
            <options>
                <option name='disabled' value='0'/>
                <option name='enabled' value='1'/>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name='tx_stream_stop_with_rx_dma_done' access='rw' rst='0' pos='16'>
            <comment>Allow to automatically clear the tx_stream_mode when Rx_Dma_Done is set.
            </comment>    
            <options>
                <option name='disabled' value='0'/>
                <option name='enabled' value='1'/>
                <default/><shift/><mask/>
            </options>
        </bits>
    </reg>
    <reg name='pin_control' protect='rw'>
        <bits name='clk_ctrl' access='rw' rst='0' pos='1:0'>
            <options>
                <option name='Spi Ctrl' value='0'><comment>The Spi_Clk pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name='Input Ctrl' value='1'><comment>The Spi_Clk pin is set INPUT (High Impedance).</comment></option>
                <option name='Force 0 Ctrl' value='2'><comment>The Spi_Clk pin is set OUTPUT and forced to 0.</comment></option>
                <option name='Force 1 Ctrl' value='3'><comment>The Spi_Clk pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name='do_ctrl' access='rw' rst='0' pos='2:3'>
            <options>
                <option name='Spi Ctrl' value='0'><comment>The Spi_DO pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name='Input Ctrl' value='1'><comment>The Spi_DO pin is set INPUT (High Impedance).</comment></option>
                <option name='Force 0 Ctrl' value='2'><comment>The Spi_DO pin is set OUTPUT and forced to 0.</comment></option>
                <option name='Force 1 Ctrl' value='3'><comment>The Spi_DO pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>            
        </bits>
        <bits name='cs0_ctrl' access='rw' rst='0' pos='4:5'>
            <options>
                <option name='Spi Ctrl' value='0'><comment>The Spi_CSO pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name='Input Ctrl' value='1'><comment>The Spi_CSO pin is set INPUT (High Impedance).</comment></option>
                <option name='Force 0 Ctrl' value='2'><comment>The Spi_CSO pin is set OUTPUT and forced to 0.</comment></option>
                <option name='Force 1 Ctrl' value='3'><comment>The Spi_CSO pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>               
        </bits>        
        <bits name='cs1_ctrl' access='rw' rst='0' pos='6:7'>
            <options>
                <option name='Spi Ctrl' value='0'><comment>The Spi_CS1 pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name='Input Ctrl' value='1'><comment>The Spi_CS1 pin is set INPUT (High Impedance).</comment></option>
                <option name='Force 0 Ctrl' value='2'><comment>The Spi_CS1 pin is set OUTPUT and forced to 0.</comment></option>
                <option name='Force 1 Ctrl' value='3'><comment>The Spi_CS1 pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>   
        </bits>
        <bits name='cs2_ctrl' access='rw' rst='0' pos='8:9'>
            <options>
                <option name='Spi Ctrl' value='0'><comment>The Spi_CS2 pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name='Input Ctrl' value='1'><comment>The Spi_CS2 pin is set INPUT (High Impedance).</comment></option>
                <option name='Force 0 Ctrl' value='2'><comment>The Spi_CS2 pin is set OUTPUT and forced to 0.</comment></option>
                <option name='Force 1 Ctrl' value='3'><comment>The Spi_CS2 pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>   
        </bits> 
        <bits name='cs3_ctrl' access='rw' rst='0' pos='10:11'>
            <options>
                <option name='Spi Ctrl' value='0'><comment>The Spi_CS3 pin is set OUTPUT(Basic SPI Behaviour).</comment></option>
                <option name='Input Ctrl' value='1'><comment>The Spi_CS3 pin is set INPUT (High Impedance).</comment></option>
                <option name='Force 0 Ctrl' value='2'><comment>The Spi_CS3 pin is set OUTPUT and forced to 0.</comment></option>
                <option name='Force 1 Ctrl' value='3'><comment>The Spi_CS3 pin is set OUTPUT and forced to 1.</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>   
        </bits> 
    </reg>
    <reg name='irq' protect='rw'>
        <bits name='Mask_Rx_ovf_Irq' access='rw' pos='0'>
            <comment>Mask the receive FIFO overflow irq
            </comment>
        </bits>
        <bits name='Mask_Tx_Th_Irq' access='rw' pos='1'>
            <comment>Mask the transmit FIFO threshold irq
            </comment>
        </bits>
        <bits name='Mask_Tx_Dma_Irq' access='rw' pos='2'>
            <comment>Mask the transmit Dma Done irq
            </comment>
        </bits>
        <bits name='Mask_Rx_Th_Irq' access='rw' pos='3'>
            <comment>Mask the receive FIFO threshold irq
            </comment>
        </bits>
        <bits name='Mask_Rx_Dma_Irq' access='rw' pos='4'>
            <comment>Mask the receive DMA Done irq
            </comment>
        </bits>
        <bitgroup name='Irq_Mask'>
            <entry ref='Mask_Rx_ovf_Irq'/>
            <entry ref='Mask_Tx_Th_Irq'/>
            <entry ref='Mask_Tx_Dma_Irq'/>
            <entry ref='Mask_Rx_Th_Irq'/>
            <entry ref='Mask_Rx_Dma_Irq'/>
        </bitgroup>
        <bits name='Tx_Threshold' access='rw' rst='3' pos='6:5'>
            <comment>Transmit FIFO threshold this threshold is used to generate the irq.
            </comment>
            <options>
                <option name='1 Empty Slot' value='0'/>
                <option name='4 Empty Slots' value='1'/>
                <option name='8 Empty Slots' value='2'/>
                <option name='12 Empty Slots' value='3'/>
                <default/><shift/><mask/>
            </options>
        </bits>
        <bits name='Rx_Threshold' access='rw' rst='3' pos='8:7'>
            <comment>Receive FIFO threshold this threshold is used to generate the irq.
            </comment>
            <options>
                <option name='1 Valid Data' value='0'/>
                <option name='4 Valid Data' value='1'/>
                <option name='8 Valid Data' value='2'/>
                <option name='12 Valid Data' value='3'/>
                <default/><shift/><mask/>
            </options>
        </bits>
    </reg>

</module>
</archive>
<archive relative='sys_ahb_monitor.xml'>

<module name='sys_ahb_monitor' category='Debug'>
    <reg name='Control' protect='rw'>
        <bits name='Enable' access='rw' rst='0' pos='0'>
            <comment>Enable (start) the Monitor.
            </comment>
        </bits>
        <bits name='Record' access='rw' rst='1' pos='4'>
            <options>
                <option name='Single_Shot' value='0'><comment>Monitor disable itself after the time window expires.</comment></option>
                <option name='Multi_Shot' value='1'/>
            </options>
        </bits>
        <bits name='Accumulation_Mode' access='rw' rst='1' pos='5'>
            <options>
                <option name='Mean' value='0'><comment>get use counter value in the read register, sum the latency and count the number of access</comment></option>
                <option name='Max' value='1'><comment>get maximum of use counter and read register per time window, get maximum of latency per access.</comment></option>
            </options>
        </bits>
        <bits name='Target' access='rw' rst='0' pos='11:8'>
            <comment>Define the element to monitor, it can be the BUS, a master, a slave or a special signal from Debug_Port: Signal_Select0 or Signal_Select1.</comment>
            <options>
                <option name='Sys_BUS' value='0'/>
                <option name='Sys_IFC' value='1'><comment>Masters</comment></option>
                <option name='DMA' value='2'/>
                <option name='XCPU' value='3'/>
                <option name='Sys_AHB2AHB' value='4'/>
                <option name='Sys_Mem_Ext' value='5'><comment>Slaves</comment></option>
                <option name='Sys_Mem_Int' value='6'/>
                <option name='Sys_AHB2AHB_Slave' value='7'/>
                <option name='Sys_IFC' value='8'/>
                <option name='Signal_Select0' value='10'><comment>Signal (counted as Slaves, the signal is used as a select signal)</comment></option>
                <option name='Signal_Select1' value='11'/>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name='Time_Window' access='rw' rst='1' pos='18:16'>
            <comment>Define the duration af a Time Window</comment>
            <options>
                <option name='TW_1kC' value='0'><comment>1024 System clock cycle</comment></option>
                <option name='TW_32kC' value='1'><comment>32768 System clock cycle</comment></option>
                <option name='TW_1MC' value='2'><comment>1048576 System clock cycle</comment></option>
                <option name='TW_16MC' value='3'><comment>16777216 System clock cycle</comment></option>
                <option name='TW_1F' value='4'><comment>1 Frame (TCU must be running)</comment></option>
                <option name='TW_26F' value='5'><comment>26 Frames (TCU must be running)</comment></option>
                <option name='TW_52F' value='6'><comment>52 Frames (TCU must be running)</comment></option>
                <option name='TW_104F' value='7'><comment>104 Frames (TCU must be running)</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
    </reg>
    <reg name='Access_Count' protect='rw'>
        <bits name='Access_Count' access='r' rst='0' pos='23:0'>
            <comment>Access counter reader (full 24bits view, 8 lower bit are also readable in latency register).
                <br/>
                <br/>For masters: count the number of access
                <br/>For slaves: count the number of access by checking the falling edge of select signal.
            </comment>
        </bits>
    </reg>
    <reg name='Use' protect='rw'>
        <bits name='Use' access='r' rst='0' pos='23:0'>
            <comment>Bus usage counter reader.
                <br/>
                <br/>For the bus: Count the cycles when the bus is used (by any master)
                <br/>For masters: Count cycles when selected master is granted
                <br/>For slaves: Count cycles when select signal is high.
            </comment>
        </bits>
    </reg>
    <reg name='Latency' protect='rw'>
        <bits name='Latency' access='r' rst='0' pos='23:0'>
            <comment>Latency counter reader (0xffffff means overflow)
                <br/>In Max mode, it's updated after each access, else it's adding the latency from all access in the time window
                <br/>For slaves it counts the duration of each access (in mean mode, it will give the same value as Use)
                <br/>
                <br/>For masters: count cycles between rise of request and first access.
                <br/>For slaves: count the duration of access by counting the high cycles. In that case it is equivalent to the use counter except in max mode where it counts the max by access not by time window.
            </comment>
        </bits>
        <bits name='Access_Cnt' access='r' rst='0' pos='31:24'>
            <comment>Number of access (0xff means overflow)
                <br/>In max mode: 0 if no access, 1 if at least 1 access.
                <br/>In mean mode: it counts the number of access during the time window.
                <br/>
                <br/>For masters: count the number of access
                <br/>For slaves: count the number of access by checking the falling edge of select signal.
                <br/>
                <br/>It is the same as the Access_Count register except that the value is saturated on 8 bits. It's repeated here to garanty coherence with Latency to enable calculs of Mean Latency by doing the following operation:
                <br/> Mean_Latency = Latency/Access_Cnt .
            </comment>
        </bits>
    </reg>
</module>
</archive>
<archive relative='ip_version.xml' vhdlpkg='ip_version_pkg'>

    <typedef name='IP_Version' rubyconstants='yes'>
        <reg name='IP_Version' protect='r'>
            <bits name='Major' access='r' rst='no' pos='31:28'>
            </bits>
            <bits name='Minor' access='r' rst='no' pos='27:24'>
            </bits>
            <comment>This register contains the IP version and release date for released IP
                <br/>If the version Major is 0 the the register contains the svn revision used and the IP is not a released IP!
            </comment>

            <bits name='Year' access='r' rst='no' pos='19:16'>
            </bits>
            <bits name='Month' display='hex' access='r' rst='no' pos='15:8'>
            </bits>
            <bits name='Day' display='hex' access='r' rst='no' pos='7:0'>
            </bits>
        </reg>
    </typedef>
    <var name='RELEASED_IP' value='1'><comment>This is a released IP!</comment></var>
    <var name='IP_VERSION_NUMBER' value='0x13080325'/>
</archive>
<archive relative='sys_ctrl.xml'>


<include file='globals.xml'/>
<include file='ip_version.xml'/>

<module name='sys_ctrl' category='System'>
    
    <enum name='Cpu_Id'>
        <entry name='XCPU'><comment>CPU IDs</comment></entry>
        <entry name='BCPU'/>
    </enum>

    
    <enum name='Sys_Clks'>
    
        <entry name='SYS_XCPU'><comment>System side System clocks</comment></entry>
        <entry name='SYS_XCPU_int'/>
        <entry name='SYS_AMBA'/>
        <entry name='SYS_PCLK_CONF'/>
        <entry name='SYS_PCLK_DATA'/>
        <entry name='SYS_DMA'/>
        <entry name='SYS_EBC'/>
        <entry name='SYS_IFC_CH0'/>
        <entry name='SYS_IFC_CH1'/>
        <entry name='SYS_IFC_CH2'/>
        <entry name='SYS_IFC_CH3'/>
        <entry name='SYS_IFC_CH4'/>
        <entry name='SYS_IFC_CH5'/>
        <entry name='SYS_IFC_CH6'/>
        <entry name='SYS_IFC_CH7'/>
        <entry name='SYS_IFC_DBG'/>
        <entry name='SYS_A2A'/>
        <entry name='SYS_COM_REGS'/>
        <entry name='SYS_DEBUG_UART'/>
        <entry name='SYS_DBGHST'/>
        <entry name='SYS_GPADC'/>         
    
        <entry name='SYSD_SCI'><comment>System side divided clock (either divided by module or by sys_ctrl)</comment></entry>
        <entry name='SYSD_RF_SPI'/>
        <entry name='SYSD_OSC'/>
        <entry name='SYSD_PWM'/>
        <bound name='NB_SYS_CLK_AEN'/>
    
        <entry name='SYS_GPIO'><comment>the following don't have an auto enable</comment></entry>
        <entry name='SYS_IRQ'/>
        <entry name='SYS_TCU'/>
        <entry name='SYS_TIMER'/>
        <bound name='NB_SYS_CLK_EN'/>
    
        <entry name='SYS_SCI'><comment>the following are sharing their enable</comment></entry>
        <entry name='SYS_NOGATE'><comment>keep last</comment></entry>
        <bound name='NB_SYS_CLK'/>
    </enum>
    
    <enum name='Per_Clks'>
    
        <entry name='PER_UART'><comment>System side System clocks for Peripherals</comment></entry>
        <entry name='PER_UART2'/>
        <entry name='PER_I2C'/>
        <entry name='PER_LCDC'/>
        <entry name='PER_SDMMC'/>
    
        <entry name='PERD_SPI'><comment>System side divided clock (either divided by module or by sys_ctrl)</comment></entry>
        <entry name='PERD_SPI2'/>
        <bound name='NB_PER_CLK_AEN'/>
    
        <entry name='PER_USBC'/>
        <entry name='PER_CAMERA'/>
        <entry name='PER_SPY'/>
        <entry name='PER_TEST'/>
        <bound name='NB_PER_CLK_EN'/>
    
        <bound name='NB_PER_CLK'/>
    </enum>    
    
    <enum name='BB_Clks'>
    
        <entry name='BB_BCPU'><comment>Baseband side System clocks</comment></entry>
        <entry name='BB_BCPU_int'/>
        <entry name='BB_AMBA'/>
        <entry name='BB_PCLK_CONF'/>
        <entry name='BB_PCLK_DATA'/>
        <entry name='BB_VOC_AHB'/>
        <entry name='BB_IFC_CH0'/>
        <entry name='BB_IFC_CH1'/>
        <entry name='BB_IFC_CH2'/>
        <entry name='BB_SRAM'/>
        <entry name='BB_A2A'/>
        <entry name='BB_ITLV'/>
        <entry name='BB_VITERBI'/>
        <entry name='BB_CIPHER'/>
        <entry name='BB_RF_IF'/>
        <entry name='BB_COPRO'/>
        <entry name='BB_CP2_REG'/>
        <entry name='BB_XCOR'/>
        <entry name='BB_AIF'/>
    
        <entry name='BBD_DAIS_208K'><comment>Baseband side divided clock<br/>divided BCK clock for DAI</comment></entry>
        <bound name='NB_BB_CLK_AEN'/>
    
        <entry name='BB_IRQ'><comment>the following don't have an auto enable</comment></entry>
        <bound name='NB_BB_CLK_EN'/>
        <bound name='NB_BB_CLK'/>
    </enum>
    
    <enum name='Other_Clks'>
        
        
        
        <bound name='OC_HOST_UART'><comment>Other clocks<br/>clocks with auto enble<br/>the debug host clock auto enable is not used in host mode, only in uart mode</comment></bound>
        <entry name='OC_DEBUG_UART'/>
        <entry name='OC_BCK'/>
        <entry name='OC_UART'/>
        <entry name='OC_UART2'/>
        <entry name='OC_RF_RX'/>
        <entry name='OC_RF_TX'/>
        <entry name='OC_MEM_BRIDGE'/>        
        <bound name='NB_OTHER_CLK_VOC_AEN_SYNC'/>
        <entry name='OC_VOC_CORE'/>
        <entry name='OC_VOC_AHB'/>
        <entry name='OC_VOC_DAI'/>
        <bound name='NB_OTHER_CLK_AEN'/>
        
        <entry name='OC_VOC'><comment>the following don't have an auto enable</comment></entry>
        <entry name='OC_LPS'/>
        <entry name='OC_GPIO'/>
        <entry name='OC_USBPHY'/>
        <entry name='OC_CAMERA'/>
        <entry name='OC_CLK_OUT'/>
        <entry name='OC_MEM_CLK_OUT'/>
        <bound name='NB_OTHER_CLK_EN'/>
        
        <bound name='NB_OTHER_CLK'/>
    </enum>
    
    
    <enum name='Resets'>
        
        <entry name='RST_XCPU'><comment>System side resets</comment></entry>
        <entry name='RST_SYS_IRQ'/>
        <entry name='RST_SYS_A2A'/>
        <entry name='RST_COM_REGS'/>
        <entry name='RST_DMA'/>
        <entry name='RST_TIMER'/>
        <entry name='RST_TCU'/>
        <entry name='RST_GPIO'/>
        <entry name='RST_KEYPAD'/>
        <entry name='RST_PWM'/>
        <entry name='RST_UART'/>
        <entry name='RST_UART2'/>
        <entry name='RST_SPI'/>
        <entry name='RST_SPI2'/>
        <entry name='RST_RF_SPI'/>
        <entry name='RST_SCI'/>
        <entry name='RST_SPY'/>
        <entry name='RST_TEST'/>
        <entry name='RST_I2C'/>
        <entry name='RST_MEM_BRIDGE'/>
        <entry name='RST_PA_AFC'/>
        <entry name='RST_GPADC'/>
        <entry name='RST_ANA_ACCO'/>
        <entry name='RST_EXT_APB'/>
        <entry name='RST_LCDC'/>
        <entry name='RST_SDMMC'/>
        <entry name='RST_CAMERA'/>
        <entry name='RST_USBC'/>
        <entry name='RST_USBPHY'/>
        <bound name='NB_SRST'/>
        
        <bound name='BOUND_BRST_FIRST'><comment>Baseband side resets</comment></bound>
        <entry name='RST_BCPU'/>
        <entry name='RST_BB_IRQ'/>
        <entry name='RST_BB_A2A'/>
        <entry name='RST_BB_IFC'/>
        <entry name='RST_BB_SRAM'/>
        <entry name='RST_ITLV'/>
        <entry name='RST_VITERBI'/>
        <entry name='RST_CIPHER'/>
        <entry name='RST_XCOR'/>
        <entry name='RST_COPRO'/>
        <entry name='RST_RF_IF'/>
        <entry name='RST_VOC'/>
        <entry name='RST_AIF'/>
        <entry name='RST_DAI'/>
        <bound name='BOUND_BRST_AFTER'/>
        <entry name='RST_BB_FULL'/>
        <bound name='NR_RST_REG'><comment>The following reset does not have register</comment></bound>
        <entry name='RST_SYS_FULL'/> 
        <bound name='NB_RST'/>
    </enum>
    <var name='NB_BRST' value='BOUND_BRST_AFTER-BOUND_BRST_FIRST'/>

    
    <enum name='Reset_Others'>
        <entry name='RSTO_DBG_HOST'><comment>Reset Other : resync on corresponding clock other</comment></entry>
        <entry name='RSTO_BCK'/>
        <entry name='RSTO_UART'/>
        <entry name='RSTO_UART2'/>
        <bound name='BOUND_RSTO_RF_FIRST'/>
        <entry name='RSTO_RF_RX'/>
        <entry name='RSTO_RF_TX'/>
        <bound name='BOUND_RSTO_RF_AFTER'/>
        <entry name='RSTO_MEM_BRIDGE'/>        
        <entry name='RSTO_VOC_DAI'/>
        <entry name='RSTO_VOC'/>
        <entry name='RSTO_LPS'/>
        <entry name='RSTO_GPIO'/>
        <entry name='RSTO_WDTIMER'/>
        <entry name='RSTO_USBPHY'/>
        <bound name='NB_RSTO'/>
    </enum>

    <range name='p_Reset_BB_L' left='BOUND_BRST_AFTER-1' right='BOUND_BRST_FIRST'><comment>Range for Reset register generation</comment></range>

    <range name='range_Reset_Sys_Reg_L' left='NR_RST_REG-1' right='0'/>
    <range name='range_Reset_Sys_L' left='NB_RST-1' right='0'/>
    <range name='range_Reset_Other_L' left='NB_RSTO-1' right='0'/>

    <range name='range_Clock_Sys_H' left='NB_SYS_CLK-1' right='0'><comment>Range for clock_ctrl generation</comment></range>
    <range name='range_Mode_Clock_Sys_H' left='NB_SYS_CLK_AEN-1' right='1'/>
    <range name='range_Enable_Clock_Sys_H' left='NB_SYS_CLK_EN-1' right='0'/>
    
    <range name='range_Clock_Per_H' left='NB_PER_CLK-1' right='0'/>
    <range name='range_Mode_Clock_Per_H' left='NB_PER_CLK_AEN-1' right='0'/>
    <range name='range_Enable_Clock_Per_H' left='NB_PER_CLK_EN-1' right='0'/>
    
    <range name='range_Clock_BB_H' left='NB_BB_CLK-1' right='0'/>
    <range name='range_Mode_Clock_BB_H' left='NB_BB_CLK_AEN-1' right='1'/>
    <range name='range_Enable_Clock_BB_H' left='NB_BB_CLK_EN-1' right='0'/>

    <range name='range_Clock_Other_H' left='NB_OTHER_CLK-1' right='0'/>
    <range name='range_Mode_Clock_Other_H' left='NB_OTHER_CLK_AEN-1' right='0'/>
    <range name='range_Enable_Clock_Other_H' left='NB_OTHER_CLK_EN-1' right='0'/>

    <range name='range_Clock_VOC_H' left='OC_VOC' right='NB_OTHER_CLK_VOC_AEN_SYNC'/>
    <range name='range_Mode_Clock_VOC_H' left='NB_OTHER_CLK_AEN-1' right='NB_OTHER_CLK_VOC_AEN_SYNC'/>



    <range name='range_Cfg_Clk_Host' left='5' right='0'><comment>Range for clock_ctrl generation, as there is no config register for this clock in sys_ctrl</comment></range>


    <var name='SYS_CTRL_PROTECT_LOCK' value='0xa50000'><comment>For REG_DBG protect lock/unlock value</comment></var>
    <var name='SYS_CTRL_PROTECT_UNLOCK' value='0xa50001'/>




    <reg name='REG_DBG' protect='rw'>
        <comment><strong>This register is used to Lock and Unlock the protected registers.</strong>
        </comment>
        <bits name='Scratch' access='rw' rst='no' pos='15:0'>
            <comment>Scratch register: used for debug
            </comment>
        </bits>
        <bits name='Write Unlock Status' access='r' rst='0' pos='30'>
            <comment>Is set to 1 when a write attempt has been done on a protected register
                <br/>Can be reset by writing 0xa50000 or 0xa50001 to the debug register (With the LSB at 1 to unlock the protected registers, with the LSB at 0 to lock them)
            </comment>
        </bits>
        <bits name='Write Unlock' access='r' rst='1' pos='31'>
            <comment>When this bit is set to 1, the protected registers are accessible
                <br/>When this bit is set to 0, the protected registers can not be written
                <br/>Write 0xa50000 to the debug register to set this bit to 0
                <br/>Write 0xa50001 to the debug register to set this bit to 1
            </comment>
        </bits>
    </reg>

    <instance name='IP_Version' type='IP_Version'/>

    <reg name='Sys_Rst_Set' protect='rw'>
        <comment>This register is protected.
        </comment>
        <bits name='Set_Sys_Rst' cut='1' cutprefix='Set' cutenum='Resets' cutstart='0' access='rs' rst='1' pos='NB_SRST-1:0'>
            <comment>Writing a 1 to any of the reset bit will reset the corresponding module and leave it in reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
        <bits name='Set_Rst_Out' access='rs' rst='0' pos='30'>
            <comment>Writing a 1 to this bit will output a 0 on the RST_OUT pin
                <br/>Reading this bit will return the RST_OUT line state.
            </comment>
        </bits>
        <bits name='Soft_Rst' access='s' rst='0' pos='31'>
            <comment>Writing a 1 to this bit will reset the entire chip.
            </comment>
        </bits>
    </reg>
    <reg name='Sys_Rst_Clr' protect='rw'>
        <bits name='Clr_Sys_Rst' cut='1' cutprefix='Clr' cutenum='Resets' cutstart='0' access='rc' rst='1' pos='NB_SRST-1:0'>
            <comment>Writing a 1 to any of the reset bit will take the corresponding module out of reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
        <bits name='Clr_Rst_Out' access='rc' rst='0' pos='30'>
            <comment>Writing a 1 to this bit will output a 1 on the RST_OUT pin
                <br/>Reading this bit will return the RST_OUT line state.
            </comment>
        </bits>
    </reg>
    <reg name='BB_Rst_Set' protect='rw'>
        <comment>This register is protected.
        </comment>
        <bits name='Set_BB_Rst' cut='1' cutprefix='Set' cutenum='Resets' cutstart='BOUND_BRST_FIRST' access='rs' rst='1' pos='NB_BRST-1:0'>
            <comment>Writing a 1 to any of the reset bit will reset the corresponding module and leave it in reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
        <bits name='Set_RST_BB_FULL' access='rs' rst='1' pos='31'>
            <comment>Writing a 1 to this reset bit will reset the all  modules on the baseband  and leave them in reset state. (this resets more modules than all lower bits of this register)
                <br/>Reading this register returns the reset state of the full baseband side.
                <br/>0 : in reset
                <br/>1 : out of reset

            </comment>
        </bits>
    </reg>
    <reg name='BB_Rst_Clr' protect='rw'>
        <bits name='Clr_BB_Rst' cut='1' cutprefix='Clr' cutenum='Resets' cutstart='BOUND_BRST_FIRST' access='rc' rst='1' pos='NB_BRST-1:0'>
            <comment>Writing a 1 to any of the reset bit will take the corresponding module out of reset state
                <br/>Reading this register returns the reset state of all the corresponding modules
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
        <bits name='Clr_RST_BB_FULL' access='rc' rst='1' pos='31'>
            <comment>Writing a 1 to this reset bit will take all the modules on the baseband   out of reset state. (modules can be kept in reset if the corresponding bit in lower bits of this register is still forcing it's reset)
                <br/>Reading this register returns the reset state of the full baseband side.
                <br/>0 : in reset
                <br/>1 : out of reset
            </comment>
        </bits>
    </reg>
    <reg name='Clk_Sys_Mode' protect='rw'>
        <bits name='Mode_SYS_XCPU' access='r' rst='1' pos='0'>
            <comment> fixed to '1'. This clock is gated only by manual mode or xcpu_sleep from irq module.
            </comment>   
        </bits>
        <bits name='Mode_Clk_Sys' cut='1' cutprefix='Mode' cutenum='Sys_Clks' cutstart='1' access='rw' rst='1' pos='NB_SYS_CLK_AEN-1:1'>
            <options>
                <option name='Automatic' value='0'><comment>automatic clock gating enabled</comment></option>
                <option name='Manual' value='1'><comment>manual clock gating only</comment></option>
            </options>
        </bits>
    </reg>
    <reg name='Clk_Sys_Enable' protect='rw'>
        <bits name='Enable_Clk_Sys' cut='1' cutprefix='Enable' cutenum='Sys_Clks' cutstart='0' access='rs' rst='1' pos='NB_SYS_CLK_EN-1:0'>
            <comment>Each bit controls the manual enable  for one clock 
                <br/>Writing a 1 to bit x of this register will enable the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x 
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name='Clk_Sys_Disable' protect='rw'>
        <comment>This register is protected.
        </comment>
        <bits name='Disable_Clk_Sys' cut='1' cutprefix='Disable' cutenum='Sys_Clks' cutstart='0' access='rc' rst='1' pos='NB_SYS_CLK_EN-1:0'>
            <comment>Each bit controls the manual enable  for one clock 
                <br/>Writing a 1 to bit x of this register will disable  the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x 
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name='Clk_Per_Mode' protect='rw'>
        <bits name='Mode_Clk_Per' cut='1' cutprefix='Mode' cutenum='Per_Clks' cutstart='0' access='rw' rst='1' pos='NB_PER_CLK_AEN-1:0'>
            <options>
                <option name='Automatic' value='0'><comment>automatic clock gating enabled</comment></option>
                <option name='Manual' value='1'><comment>manual clock gating only</comment></option>
            </options>
        </bits>
    </reg>
    <reg name='Clk_Per_Enable' protect='rw'>
        <bits name='Enable_Clk_Per' cut='1' cutprefix='Enable' cutenum='Per_Clks' cutstart='0' access='rs' rst='1' pos='NB_PER_CLK_EN-1:0'>
            <comment>Each bit controls the manual enable  for one clock 
                <br/>Writing a 1 to bit x of this register will enable the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x 
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name='Clk_Per_Disable' protect='rw'>
        <comment>This register is protected.
        </comment>
        <bits name='Disable_Clk_Per' cut='1' cutprefix='Disable' cutenum='Per_Clks' cutstart='0' access='rc' rst='1' pos='NB_PER_CLK_EN-1:0'>
            <comment>Each bit controls the manual enable  for one clock 
                <br/>Writing a 1 to bit x of this register will disable  the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x 
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name='Clk_BB_Mode' protect='rw'>
       <bits name='Mode_BB_BCPU' access='r' rst='1' pos='0'>
            <comment> fixed to '1'. This clock is gated only by manual mode or bcpu_sleep from irq module.  
            </comment>   
        </bits>
        <bits name='Mode_Clk_BB' cut='1' cutprefix='Mode' cutenum='BB_Clks' cutstart='1' access='rw' rst='1' pos='NB_BB_CLK_AEN-1:1'>
            <options>
                <option name='Automatic' value='0'><comment>automatic clock gating enabled</comment></option>
                <option name='Manual' value='1'><comment>manual clock gating only</comment></option>
            </options>
        </bits>
    </reg>
    <reg name='Clk_BB_Enable' protect='rw'>
        <bits name='Enable_Clk_BB' cut='1' cutprefix='Enable' cutenum='BB_Clks' cutstart='0' access='rs' rst='1' pos='NB_BB_CLK_EN-1:0'>
            <comment>Each bit controls the manual enable  for one clock 
                <br/>Writing a 1 to bit x of this register will enable the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x 
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name='Clk_BB_Disable' protect='rw'>
        <comment>This register is protected.
        </comment>
        <bits name='Disable_Clk_BB' cut='1' cutprefix='Disable' cutenum='BB_Clks' cutstart='0' access='rc' rst='1' pos='NB_BB_CLK_EN-1:0'>
            <comment>Each bit controls the manual enable  for one clock 
                <br/>Writing a 1 to bit x of this register will disable  the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x 
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name='Clk_Other_Mode' protect='rw'>
        <bits name='Mode_Clk_Other' cut='1' cutprefix='Mode' cutenum='Other_Clks' cutstart='0' access='rw' rst='1' pos='NB_OTHER_CLK_AEN-1:0'>
            <options>
                <option name='Automatic' value='0'><comment>automatic clock gating enabled</comment></option>
                <option name='Manual' value='1'><comment>manual clock gating only</comment></option>
            </options>
        </bits>
    </reg>
    <reg name='Clk_Other_Enable' protect='rw'>
        <bits name='Enable_Clk_Other' cut='1' cutprefix='Enable' cutenum='Other_Clks' cutstart='0' access='rs' rst='1' pos='NB_OTHER_CLK_EN-1:0'>
            <comment>Each bit controls the manual enable  for one clock 
                <br/>Writing a 1 to bit x of this register will enable the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x 
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name='Clk_Other_Disable' protect='rw'>
        <comment>This register is protected.
        </comment>
        <bits name='Disable_Clk_Other' cut='1' cutprefix='Disable' cutenum='Other_Clks' cutstart='0' access='rc' rst='1' pos='NB_OTHER_CLK_EN-1:0'>
            <comment>Each bit controls the manual enable  for one clock 
                <br/>Writing a 1 to bit x of this register will disable  the corresponding clocks
                <br/>Writing a 0 to bit x has no effect on clock x 
                <br/>Reading this register gives the current status for all the clocks (1 : enabled, 0: disabled)
            </comment>
        </bits>
    </reg>
    <reg name='Sel_Clock' protect='rw'>
        <comment>This register is protected.
        </comment>
        <bits name='Slow_sel_RF' access='rw' rst='1' pos='0'>
            <comment>PreSelects between RF clock and Oscillator clock for Clock Slow
            </comment>
            <options>
                <option name='Oscillator' value='1'/>
                <option name='RF' value='0'/>
            </options>
        </bits>
        <bits name='Sys_sel_Fast' access='rw' rst='1' pos='4'>
            <comment>Selects between the Slow clock and the Fast Clock (Pll clock)
            </comment>
            <options>
                <option name='Slow' value='1'/>
                <option name='Fast' value='0'/>
            </options>
        </bits>
        <bits name='Sys_sel_PLL' access='rw' rst='1' pos='8'>
            <comment>Selects between the 2 pll sources
            </comment>
            <options>
                <option name='Acco' value='1'/>
                <option name='Ext' value='0'/>
            </options>
        </bits>
        <bitgroup name='Clock_Select'>
            <entry ref='Slow_sel_RF'/>
            <entry ref='Sys_sel_Fast'/>
            <entry ref='Sys_sel_PLL'/>
        </bitgroup>
        <bits name='ClockOut_sel_RF' access='rw' rst='1' pos='12'>
            <comment>Selects between RF clock and Oscillator clock for Clock OUT pin
            </comment>
            <options>
                <option name='Oscillator' value='1'/>
                <option name='RF' value='0'/>
            </options>
        </bits>

        <bits name='Clock_PLL_UART_Sel' access='rw' rst='1' pos='16'>
            <comment>Select the Fast clock UART frequency (104MHz is available only with 312MHz Pll)
            </comment>
            <options>
                <option name='104MHz' value='1'/>
                <option name='52MHz' value='0'/>
            </options>
        </bits>


        <bits name='RF_detected' access='r' rst='no' pos='20'>
            <options>
                <option name='Ok' value='1'><comment>When 1, the clock from the XCver is detected.</comment></option>
                <option name='No' value='0'><comment>When 0, the clock from the XCver is not detected.</comment></option>
            </options>
        </bits>
        <bits name='RF_Detect_Bypass' access='rw' rst='0' pos='21'>
            <comment>If RF_Detect_Bypass = 0, RF clock is selected when she is detected.
                <br/>If RF_Detect_Bypass = 1, RF clock is selected even she is not detected.
            </comment> 
        </bits>

        <bits name='RF_Detect_Reset' access='rw' rst='0' pos='22'>
            <comment>When 1, The RF clock detection counter is force reseted.
                <br/>When 0, The RF clock detection counter is enabled.
            </comment>               
        </bits>
        <bits name='RF_selected_L' access='r' rst='1' pos='23'>
            <comment>0 when RF clock is effectively selected for Slow Clock. RF clock selection is not done until the clock has been detected.
            </comment>
        </bits>
        <bits name='Ext_PLL_Locked' access='r' rst='0' pos='24'>
            <comment>1 when the External pll is locked.
            </comment>
        </bits>  
        <bits name='Acco_PLL_Locked' access='r' rst='0' pos='25'>
            <comment>1 when the Acco pll is locked.
            </comment>
        </bits>  
        <bits name='PLL_bypass_Lock' access='rw' rst='0' pos='27'>
            <comment>When set to 1, the system clock will switch to the fast clock even if the pll is not locked.
                <br/>When set to 0, the system clock is only allowed to switch to the fast clock if the pll is locked
            </comment>
        </bits>
        <bits name='Sys_PLL_Selected' access='r' rst='1' pos='30'>
            <comment>Show which PLL is actually selected
            </comment>
            <options>
                <option name='Acco' value='1'/>
                <option name='Ext' value='0'/>
            </options>
        </bits>
        <bits name='Fast_Selected_L' access='r' rst='1' pos='31'>
            <comment>0 when Fast clock is effectively selected. Fast clock selection is not done until the PLL has locked.
            </comment>
        </bits>
    </reg>

    <reg name='Cfg_Clk_Sys' protect='rw'>
        <comment>Bit force_div_update in this register is protected.
        </comment>
        <bits name='Freq' access='rw' rst='all1' pos='2:0'>
            <options>
                <option name='13M' value='0'/>
                <option name='26M' value='1'/>
                <option name='39M' value='2'/>
                <option name='52M' value='3'/>
                <option name='78M' value='4'/>
                <option name='104M' value='5'/>
                <default/>
                <mask/>
                <shift/>
            </options>
            <comment>Note: for unvalid values the system will run at 13MHz
                <br/>any writing to this register will trigger an update request. The update will be effective when the gsm clocks are in the proper phase to avoid schronization loss unless bit force_div_update is written '1'.
            </comment>
        </bits>
        <bits name='force_div_update' access='rw' rst='1' pos='4'>
            <comment>Allows to switch the system clock divider without taking care of the gsm clocks
                <br/>1 : update is immediate
                <br/>0 : update is dependent of the gsm clocks phase to avoid loosing synchronization
            </comment>
        </bits>
        <bits name='req_div_update' access='r' rst='0' pos='8'>
            <comment>Status to check if a request to update the pll divider is pending.
            </comment>
        </bits>
    </reg>
     <reg name='Cfg_Clk_Mem_Bridge' protect='rw'>
        <bits name='Freq' access='rw' rst='all1' pos='2:0'>
            <options>
                <option name='13M' value='0'/>
                <option name='26M' value='1'/>
                <option name='39M' value='2'/>
                <option name='52M' value='3'/>
                <option name='78M' value='4'/>
                <option name='104M' value='5'/>
                <default/>
                <mask/>
                <shift/>
            </options>
            <comment>Note: for unvalid values the memory interface will run at 13MHz
            </comment>
        </bits>
    </reg>

    <reg name='Cfg_Clk_Voc' protect='rw'>
        <bits name='Freq' access='rw' rst='all1' pos='2:0'>
            <options>
                <option name='13M' value='0'/>
                <option name='26M' value='1'/>
                <option name='39M' value='2'/>
                <option name='52M' value='3'/>
                <default/>
                <mask/>
                <shift/>
            </options>
            <comment>Note: for unvalid values Voc will run at 13MHz
            </comment>
        </bits>
        <bits name='Voc_Sel_PLL' access='rw' rst='1' pos='3'>
            <comment>Selects between the Slow clock and the Pll clock
            </comment>
            <options>
                <option name='Slow' value='1'/>
                <option name='PLL' value='0'/>
            </options>
            
        </bits>
    </reg>
    <reg name='Cfg_Clk_AudioBCK_Div' protect='rw'>
        <bits name='AudioBCK_Divider' access='rw' rst='all1' pos='10:0'>
            <comment>The generated clock frequency is equal to the 156MHz divided by this value + 2. The 156MHz clock comes from a PLL.
            </comment>
        </bits>
    </reg>
    
    <reg name='Cfg_Clk_Uart' protect='rw' count='3'>
        <bits name='Uart_Divider' access='rw' rst='all1' pos='9:0'>
            <comment>The generated clock frequency is equal to the selected source frequency divided by this value + 2 (see bit 12 clock select for source selection).
                <br/>The generated clock must be 4 or 16 times the expected baud rate depending on the Uart settings (see Uart section for details).
            </comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name='Uart_Sel_PLL' access='rw' rst='1' pos='12'>
            <options>
                <option name='Slow' value='0'><comment>The Uart clock is generated from the Slow clock divided by the divider value + 2</comment></option>
                <option name='PLL' value='1'><comment>The Uart clock is generated from a fast clock generated by the PLL (52 MHz or 104MHz see Sel_Clock Register) divided by the divider value + 2</comment></option>
            </options>
        </bits>
    </reg>

    <reg name='Cfg_Clk_PWM' protect='rw'>
        <bits name='PWM_Divider' access='rw' rst='all1' pos='7:0'>
            <comment>The Pwm reference clock frequency is the system clock divided by this register value + 1.
            </comment>
        </bits>
    </reg>
    
    <reg name='Cfg_AHB' protect='rw'>
        <comment>This register is protected.
        </comment>
        <bits name='Sys_Enable' cut='1' cutprefix='Enable' cutenum='Sys_Master_Id' cutstart='1' access='rw' rst='1' pos='SYS_NB_MASTERS-1:0'>
            <options>
                <option name='Enable' value='1'><comment>Normal configuration</comment></option>
                <option name='Disable' value='0'><comment>The master is never granted on the System AHB</comment></option>
            </options>
        </bits>
        <bits name='BB_Enable' cut='1' cutprefix='Enable' cutenum='BB_Master_Id' cutstart='1' access='rw' rst='1' pos='BB_NB_MASTERS+15:16'>
            <options>
                <option name='Enable' value='1'><comment>Normal configuration</comment></option>
                <option name='Disable' value='0'><comment>The master is never granted on the Baseband AHB</comment></option>
            </options>
        </bits>
        <bits name='USB_Ram_Test_Mode' access='rw' rst='0' pos='31'>
            <options>
                <option name='Enable' value='1'><comment>USB Ram test mode, allow access to 3 upper bits of the USB ram: mapped as lower bits</comment></option>
                <option name='Disable' value='0'><comment>Normal usage of the USB Ram</comment></option>
            </options>
        </bits>
    </reg>

    <reg name='XCpu_Dbg_BKP' protect='rw'>
        <bits name='BKPT_En' access='rw' rst='0' pos='0'>
            <comment>Enable XCPU hardware breakpoint.
            </comment>
        </bits>
        <bits name='BKPT_Mode' display='bin' access='rw' rst='all1' pos='5:4'>
            <options>
                <option name='I' value='0'><comment>Breakpoint is triggered when an instruction is fetched at XCpu_Dbg_Addr</comment></option>
                <option name='R' value='1'><comment>Breakpoint triggered when a data is read at XCpu_Dbg_Addr</comment></option>
                <option name='W' value='2'><comment>Breakpoint triggered when a data is written at XCpu_Dbg_Addr</comment></option>
                <option name='RW' value='3'><comment>Breakpoint triggered when a data is read OR written at XCpu_Dbg_Addr</comment></option>
                <default/>
            </options>
        </bits>
        <bits name='Stalled' access='rw' rst='0' pos='8'>
            <comment>When 1 the cpu is stalled and stays stalled until this bit is set to 0, when 0 the stall condition depends on the breakpoint trigger. If the breakpoint is triggered, the cpu stalls. It can be released by writing a 0 to this bit.
            </comment>
        </bits>
    </reg>
    <reg name='XCpu_Dbg_Addr' protect='rw'>
        <bits name='Breakpoint address' display='hex' access='rw' rst='no' pos='NB_BITS_ADDR-1:0'>
            <comment>Physical address of breakpoint
            </comment>
        </bits>
    </reg>
    <reg name='BCpu_Dbg_BKP' protect='rw'>
        <bits name='BKPT_En' access='rw' rst='0' pos='0'>
            <comment>Enable BCPU hardware breakpoint.
            </comment>
        </bits>
        <bits name='BKPT_Mode' display='bin' access='rw' rst='all1' pos='5:4'>
            <options>
                <option name='I' value='0'><comment>Breakpoint is triggered when an instruction is fetched at BCpu_Dbg_Addr</comment></option>
                <option name='R' value='1'><comment>Breakpoint triggered when a data is read at BCpu_Dbg_Addr</comment></option>
                <option name='W' value='2'><comment>Breakpoint triggered when a data is written at BCpu_Dbg_Addr</comment></option>
                <option name='RW' value='3'><comment>Breakpoint triggered when a data is read OR written at BCpu_Dbg_Addr</comment></option>
                <default/>
            </options>
        </bits>
        <bits name='Stalled' access='rw' rst='0' pos='8'>
            <comment>When 1 the cpu is stalled and stays stalled until this bit is set to 0, when 0 the stall condition depends on the breakpoint trigger. If the breakpoint is triggered, the cpu stalls. It can be released by writing a 0 to this bit.
            </comment>
        </bits>
    </reg>
    <reg name='BCpu_Dbg_Addr' protect='rw'>
        <bits name='Breakpoint address' display='hex' access='rw' rst='no' pos='NB_BITS_ADDR-1:0'>
            <comment>Physical address of breakpoint
            </comment>
        </bits>
        
    </reg>
    
    <reg name='Cfg_Cpus_Cache_Ram_Disable' protect='rw'>
        <bits name='XCpu_Use_Mode' access='rw' rst='0' pos='0'>
            <comment>When 1 the XCPU deselects its cache rams automatically when not in use, when 0 this feature is disabled.
            </comment>
        </bits>
        <bits name='XCpu_Clk_Off_Mode' access='rw' rst='0' pos='1'>
            <comment>When 1 the cache rams are automatically deselected  when the XCPU clock is shutdown, when 0 this feature is disabled.
            </comment>
        </bits>
        <bitgroup name='XCpu_Cache_Ram_Disable'>
            <entry ref='XCpu_Use_Mode'/>
            <entry ref='XCpu_Clk_Off_Mode'/>
        </bitgroup>
        <bits name='BCpu_Use_Mode' access='rw' rst='0' pos='16'>
            <comment>When 1 the BCPU deselects its cache rams automatically when not in use, when 0 this feature is disabled.
            </comment>
        </bits>
        <bits name='BCpu_Clk_Off_Mode' access='rw' rst='0' pos='17'>
            <comment>When 1 the cache rams are automatically deselected  when the BCPU clock is shutdown, when 0 this feature is disabled.
            </comment>
        </bits>
        <bitgroup name='BCpu_Cache_Ram_Disable'>
            <entry ref='BCpu_Use_Mode'/>
            <entry ref='BCpu_Clk_Off_Mode'/>
        </bitgroup>
        
    </reg>

    <reg name='Reset_Cause' protect='rw'>
        
        <bits name='WatchDog_Reset' access='rw' rst='no' pos='0'>
            <options>
                <option name='Happened' value='1'><comment>A watchdog reset has happened</comment></option>
                <option name='No' value='0'><comment>No watchdog reset happened since the last HW reset or power on.</comment></option>
            </options>
            <comment>Writing a 1 to this bit will reset the bits watchdog_Reset cause, GlobalSoft_Reset cause and HostDebug_Reset cause to 0.
            </comment>
        </bits>
        <bits name='GlobalSoft_Reset' access='r' rst='no' pos='4'>
            <options>
                <option name='Happened' value='1'><comment>A reset was initiated from Global soft reset register</comment></option>
                <option name='No' value='0'><comment>The reset was not from the soft reset register.</comment></option>
            </options>
        </bits>
        <bits name='HostDebug_Reset' access='r' rst='no' pos='8'>
            <options>
                <option name='Happened' value='1'><comment>A reset was initiated from the Host interface</comment></option>
                <option name='No' value='0'><comment>The reset was not from the debug interface.</comment></option>
            </options>
        </bits>
        <bits name='AlarmCause' access='r' rst='no' pos='12'>
            <options>
                <option name='Happened' value='1'><comment>An Alarm occur from the calendar</comment></option>
                <option name='No' value='0'><comment>No Alarm occur.</comment></option>
            </options>
        </bits>       
        <bits name='Boot_Mode' access='rw' rst='no' pos='21:16' display='bin' >
            <comment>This contains the state of boot mode pins latched during Reset.
                <br/> bit 16: BOOT_MODE_NO_AUTO_PU. Skip the power up state machine
                <br/> bit 17: BOOT_MODE_FORCE_MONITOR. Enable the monitor
                <br/> bit 18: BOOT_MODE_UART_MONITOR_ENABLE. Enable uart monitor
                <br/> bit 19: BOOT_MODE_USB_MONITOR_DISABLE. Disable usb monitor
                <br/> bit 20: reserved.
                <br/> bit 21: BOOT_MODE_FLASH_ADMUX.
                <br/> see DOC GreenstoneBootSequence for details.
            </comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name='Fonctional_Test_Mode' access='r' rst='no' pos='31'>
            <comment>When 1 the chip has booted in fonctional test mode (for chip production tests).
            </comment>
            
        </bits>
    </reg>
    
   <reg name='WakeUp' protect='rw'>
        <comment>This register is protected.
        </comment>
        <bits name='force_Wakeup' access='rw' rst='0' pos='0'>
            <comment>When 1, the wake up is set. When 0, the wake up is clear .
            </comment>
        </bits>
    </reg>
    
</module>

</archive>

<archive relative='sys_ifc.xml'>


<include file='globals.xml'/>

<include file='granite_ip_config.xml'/>

<var name='SYS_IFC_ADDR_ALIGN' value='0'/>

<var name='SYS_IFC_TC_LEN' value='20'/>

<var name='SYS_IFC_STD_CHAN_NB' value='SYS_IFC_NB_STD_CHANNEL'/> 

<var name='SYS_IFC_RFSPI_CHAN' value='1'/>

<module name='sys_ifc' category='System'>
  

  <reg name='get_ch' protect='w'>
    <bits name='ch_to_use' access='rw' rst='0' pos='3:0'>
      <comment>This field indicates which standard channel to use.
      <br/> Before using a channel, the CPU read this register to know which channel must be used.
      After reading this registers, the channel is to be regarded as
      busy.
      <br/> After reading this register, if the CPU doesn't want to use
      the specified channel, the CPU must write a disable in the control
      register of the channel to release the channel.
      <br/>0000 = use Channel0
      <br/>0001 = use Channel1
      <br/>0010 = use Channel2 
      <br/> ...
      <br/>0111 = use Channel7
      <br/>1111 = all channels are busy</comment>
      <options><mask/><shift/><default/></options>
    </bits>
  </reg>

  <reg name='dma_status' protect='r'>
    <bits name='ch_enable' access='r' rst='0' pos='SYS_IFC_STD_CHAN_NB+SYS_IFC_RFSPI_CHAN-1:0'>
      <comment>This register indicates which channel is enabled. It is a copy
      of the enable bit of the control register of each channel. One bit per
      channel, for example:
      <br/>0000_0000 = All channels disabled 
      <br/>0000_0001 = Ch0 enabled 
      <br/>0000_0010 = Ch1 enabled 
      <br/>0000_0100 = Ch2 enabled 
      <br/>0000_0101 = Ch0 and Ch2 enabled 
      <br/>0000_0111 = Ch0, Ch1 and Ch2 enabled 
      <br/>1111_1111 = all channels enabled</comment>
    </bits>

    <bits name='ch_busy' access='r' rst='0' pos='SYS_IFC_STD_CHAN_NB-1+16:16'>
      <comment>This register indicates which standard channel is busy (this field doesn't include the RF_SPI channel). A standard channel is mark as busy, when a channel is enabled or a previous reading of the GET_CH register, the field CH_TO_USE indicates this channel. One bit per channel</comment>
    </bits>
  </reg>

  <reg name='debug_status' protect='r'>
    <bits name='dbg_status' access='r' rst='0' pos='0'>
      <comment>Debug Channel Status .<br/>0= The debug channel is running
      (not idle) <br/>1= The debug channel is in idle mode</comment>
    </bits>
  </reg>

  <hole size='32'/>

  

  <struct name='std_ch' count='SYS_IFC_STD_CHAN_NB'>
    <reg name='control' protect='rw'>
      <bits name='enable' access='w' rst='no' pos='0'>
        <comment>Channel Enable, write one in this bit enable the channel.
        <br/>When the channel is enabled, for a peripheral to memory transfer
        the DMA wait request from peripheral to start transfer. </comment>
      </bits>

      <bits name='disable' access='w' rst='no' pos='1'>
        <comment>Channel Disable, write one in this bit disable the channel.
        <br/>When writing one in this bit, the current AHB transfer and
        current APB transfer (if one in progress) is completed and the channel
        is then disabled. </comment>
      </bits>

      <bits name='autodisable' access='rw' rst='1' pos='4'>
        <comment>Set Auto-disable mode<br/> 0 = when TC reach zero the
        channel is not automatically released.<br/> 1 = At the end of the
        transfer when TC reach zero the channel is automatically disabled. the
        current channel is released.</comment>
      </bits>
      
      <bits name='Size' access='rw' rst='0' pos='5'>
        <comment>Peripheral Size
            <br/> 0= 8-bit peripheral
            <br/> 1= 32-bit peripheral
        </comment>
      </bits>

      <bits name='req_src' display='hex' access='rw' rst='0x7' pos='12:8'>
        <options linkenum='Sys_Ifc_Request_IDs'> 
        
          <default/>
        </options>

        <comment>Select DMA Request source</comment>
      </bits>

        <bits name='flush' access='rw' rst='0' pos='16'>
        <comment>When one, flush the internal FIFO channel. 
        <br/>This bit must be used only in case of Rx transfer. Until this bit is 1, the APB
              request is masked. The flush doesn't release the channel. 
        <br/> Before writting back this bit to zero the internal fifo must empty.
        </comment>
        
      </bits>
    </reg>

    <reg name='status' protect='r'>
      <bits name='enable' access='r' rst='0' pos='0'>
        <comment>Enable bit, when '1' the channel is running  </comment>
      </bits>

      <bits name='fifo_empty' access='r' rst='1' pos='4'>
        <comment>The internal channel fifo is empty </comment>
      </bits>
    </reg>

    <reg name='start_addr' protect='rw'>
      <bits name='start_addr' display='hex' access='rw' rst='0xFFFFFFFF' pos='NB_BITS_ADDR-1:SYS_IFC_ADDR_ALIGN'>
        <comment>AHB Address. This field represent the start address of the
        transfer.
        <br/>For a 32-bit peripheral, this address must be aligned 32-bit.
        </comment>
      </bits>
    </reg>

    <reg name='tc' protect='rw'>
      <bits name='tc' display='hex' access='rw' rst='0xFFFFFFFF' pos='SYS_IFC_TC_LEN-1:0'>
        <comment>Transfer Count, this field indicated the transfer size in bytes to perform.
        <br/>During a transfer a write in this register add the new value to the current TC. 
        <br/>A read of this register return the current current transfer count.
        </comment>
      </bits>
    </reg>
  </struct>
  
  <hole size='32*4*(7-SYS_IFC_STD_CHAN_NB)'/>

  <reg name='ch_rfspi_control' protect='w'>
      <bits name='enable' access='s' rst='no' pos='0'>
        <comment>Channel Enable, write one in this bit enable the channel.
        <br/>This channel works only in fifo mode. </comment>
      </bits>

      <bits name='disable' access='c' rst='no' pos='1'>
        <comment>Channel Disable, write one in this bit to disable the channel.
        </comment>
      </bits>
    </reg>

    <reg name='ch_rfspi_status' protect='r'>
      <bits name='enable' access='r' rst='0' pos='0'>
        <comment>Enable bit, when '1' the channel is running  </comment>
      </bits>

      <bits name='fifo_empty' access='r' rst='1' pos='4'>
        <comment>The internal channel fifo is empty </comment>
      </bits>
    </reg>

    <reg name='ch_rfspi_start_addr' protect='rw'>
      <bits name='start_AHB_addr' display='hex' access='rw' rst='0xFFFFFFFF' pos='NB_BITS_ADDR-1:SYS_IFC_ADDR_ALIGN'>
        <comment>AHB Start Address. <br/>This field represent the start address of the fifo.
                 The start address must 32-bit aligned.
        </comment>
      </bits>
    </reg>
    
    <reg name='ch_rfspi_end_addr' protect='rw'>
      <bits name='end_AHB_addr' display='hex' access='rw' rst='0xFFFFFFFF' pos='NB_BITS_ADDR-1:SYS_IFC_ADDR_ALIGN'>
        <comment>AHB End Address. <br/>This field represent the last address of the fifo (it is the first address not used in the fifo). <br/>The end address must 32-bit aligned.
        </comment>
      </bits>
    </reg>


    <reg name='ch_rfspi_tc' protect='rw'>
      <bits name='tc' display='hex' access='rw' rst='0xFFFFFFFF' pos='SYS_IFC_TC_LEN-1:0'>
        <comment>Transfer Count, transfer size in bytes. <br/>This bit
        indicated the transfer size in bytes to perform. Up to 4kbytes per
        transfer. <br/>During a transfer a write in this register add the new
        value to the current TC. A read of this register return the current
        current transfer count.</comment>
      </bits>
    </reg>
</module>

</archive>
<archive relative='sys_irq.xml'>


<include file='globals.xml'/>

<module name='sys_irq' category='System'>
    
    
    <enum name='XCPU_Irq_Lines'>
        <entry name='XCpu_Main_Irq_Line'><comment>XCPU Irq Lines</comment></entry>
        
        <entry name='XCpu_Page_Spy_Irq_Line' value='3'/>
        <entry name='XCpu_Debug_Irq_Line' value='4'/>
        <entry name='XCpu_Host_Irq_Line'/>
    </enum>


    <reg name='Cause' protect='rw'>
        <comment>If cause is not null and interrupt are enabled then the interrupt line 0 is driven on the system CPU.
            <br/>The cause for the Irq sources, one bit for each module's irq source.
            <br/>The cause is the actual Irq source masked by the mask register.
        </comment>
        <bits name='Cause' cut='1' cutprefix='' cutenum='Sys_Irq_Id' cutstart='0' access='r' rst='0' pos='SYS_NB_IRQ-1:0'/>
    </reg>
    <reg name='Status' protect='rw'>
        <comment>The status for the level Irq sources, one bit for each module's irq source.
            <br/>The status reflect the actual Irq source.
        </comment>
        <bits name='Status' cut='1' cutprefix='' cutenum='Sys_Irq_Id' cutstart='0' access='r' rst='0' pos='SYS_NB_IRQ-1:0'/>
    </reg>
    <reg name='Mask_Set' protect='rw'>
        <comment>Writing '1' sets the corresponding bit in the mask register to '1'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name='Mask_Set' cut='1' cutprefix='' cutenum='Sys_Irq_Id' cutstart='0' access='rs' rst='0' pos='SYS_NB_IRQ-1:0'/>
    </reg>
    <reg name='Mask_Clear' protect='rw'>
        <comment>Writing '1' clears the corresponding bit in the mask register to '0'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name='Mask_Clr' cut='1' cutprefix='' cutenum='Sys_Irq_Id' cutstart='0' access='rc' rst='0' pos='SYS_NB_IRQ-1:0'/>
    </reg>
    <reg name='NonMaskable' protect='rw'>
        <bits name='Main_IRQ' access='r' rst='0' pos='10'>
            <comment>This is the Main Irq source it drive the system CPU interrupt line 0.
                <br/>This bit comes from the modules irq and is masked by the Mask and SC registers.
            </comment>
        </bits>
        <bits name='Page_Spy_IRQ' access='r' rst='0' pos='13'>
            <comment>This is the Page Spy Irq source it drive the system CPU interrupt line 3.
                <br/>This bit is controlled by the page spy module.
            </comment>
        </bits>
        <bits name='Debug_IRQ' access='rw' rst='0' pos='14'>
            <comment>This is the debug Irq source, the value written here drives the system CPU interrupt line 4.
            </comment>
        </bits>
        <bits name='Host_IRQ' access='r' rst='0' pos='15'>
            <comment>This is the Host Irq source it drive the system CPU interrupt line 5.
                <br/>This bit is controlled by the host internal register.
            </comment>
        </bits>
        <bits name='IntEnable_Status' access='r' rst='1' pos='31'>
            <comment>Status of the Interrupt enable semaphore bit.
            </comment>
        </bits>
   </reg>
    <reg name='SC' protect=''>
        <bits name='IntEnable' access='rw' rst='1' pos='0'>
            <comment>Interrupt enable semaphore, used for critical section.
                <br/>Read returns its value and then clears it to '0' disabling interrupts.
                <br/>Write the read value to restore the previous state, this will exit the critical section.
            </comment>
        </bits>
    </reg>
    <reg name='WakeUp_Mask' protect='rw'>
        <comment>Each bit to '1' in that registers allows the correcponding interrupt to wake up the System CPU (i.e.: Reenable it's clock, see CLOCK_SYS_ENABLE and CLOCK_SYS_DISABLE registers in sys_ctrl registers section)
        </comment>
        <bits name='WakeUp_Mask' cut='1' cutprefix='' cutenum='Sys_Irq_Id' cutstart='0' access='rw' rst='0' pos='SYS_NB_IRQ-1:0'/>
    </reg>
    <reg name='Cpu_Sleep' protect='rw'>
        <bits name='Sleep' access='w' rst='0' pos='0'>
            <comment>Writing '1' to this bit will put the XCPU to sleep (i.e.: Disable it's clock, see CLOCK_SYS_ENABLE and CLOCK_SYS_DISABLE registers in sys_ctrl registers section)
            </comment>
        </bits>
    </reg>
    <reg name='Pulse_Mask_Set' protect='rw'>
        <comment>Writing '1' sets the corresponding bit in the mask register to '1'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name='Pulse_Mask_Set' cut='1' cutprefix='' cutenum='Sys_Irq_Id' cutstart='0' access='rs' rst='0' pos='SYS_NB_IRQ_PULSE-1:0'/>
    </reg>
    <reg name='Pulse_Mask_Clr' protect='rw'>
        <comment>Writing '1' clears the corresponding bit in the mask register to '0'.
            <br/>Reading gives the value of the mask register.
        </comment>
        <bits name='Pulse_Mask_Clr' cut='1' cutprefix='' cutenum='Sys_Irq_Id' cutstart='0' access='rc' rst='0' pos='SYS_NB_IRQ_PULSE-1:0'/>
    </reg>
    <reg name='Pulse_Clear' protect='rw'>
        <comment>Writing '1' clears the corresponding Pulse IRQ.
            <br/>Pulse IRQ are set by the modules and cleared here.
        </comment>
        <bits name='Pulse_Clr' cut='1' cutprefix='' cutenum='Sys_Irq_Id' cutstart='0' access='c' rst='0' pos='SYS_NB_IRQ_PULSE-1:0'/>
    </reg>

</module>

</archive>
<archive relative='tcu.xml'>


<module name='tcu' category='Modem'>

    
    <var name='NB_TCO' value='15'/> 
    <var name='NB_TCU_PROG_EVENTS' value='60'/>

    <enum name='Internal_TCO_mapping'>
        <entry name='TCO_GMSK_ON' value='10'><comment>Internal TCO mapping</comment></entry>
        <entry name='TCO_TX_OEN'/>
        <entry name='TCO_TX_ON'/>
        <entry name='TCO_RX_ON'/>
        <entry name='TCO_RX_DEC_ON'/>
    </enum>

    <enum name='TCU_Event'>
        
        <entry name='Clr_TCO_0' value='0'><comment>Clear TCO 0 : set the TCO 0 to the inactive state<br/>To clear TCO n, use event 2*n</comment></entry>
        <entry name='Set_TCO_0' value='1'><comment>Set TCO 0 : set the TCO 0 to the active state<br/>To set TCO n, use event 2*n+1</comment></entry>
        <entry name='Clr_TCO_1'><comment>...</comment></entry>
        
        
        <entry name='Stop_GMSK' value='TCO_GMSK_ON*2'><comment>stop modulation</comment></entry>
        <entry name='Start_GMSK' value='TCO_GMSK_ON*2+1'><comment>starts modulation and output on IQ DAC</comment></entry>
        <entry name='HighZ_IQ_DAC' value='TCO_TX_OEN*2'/>
        <entry name='Drive_IQ_DAC' value='TCO_TX_OEN*2+1'/>
        <entry name='disable_IQ_DAC' value='TCO_TX_ON*2'/>
        <entry name='enable_IQ_DAC' value='TCO_TX_ON*2+1'/>
        <entry name='disable_IQ_ADC' value='TCO_RX_ON*2'><comment>disable IQ ADC</comment></entry>
        <entry name='enable_IQ_ADC' value='TCO_RX_ON*2+1'><comment>enable IQ ADC</comment></entry>
        <entry name='stop_RFin_record' value='TCO_RX_DEC_ON*2'><comment>stop recording IQ samples</comment></entry>
        <entry name='start_RFin_record' value='TCO_RX_DEC_ON*2+1'><comment>start recording IQ samples</comment></entry>
        
        <entry name='SEND_SPI_CMD' value='NB_TCO*2'><comment>Send RF spi command</comment></entry>
        <entry name='NEXT_GAIN'/>
        <entry name='FIRST_GAIN'/>
        
        <entry name='NEXT_FC'/>
        
        <entry name='PA_RAMP0'><comment>Start Ramp 0</comment></entry>
        <entry name='PA_RAMP1'><comment>Start Ramp 1</comment></entry>
        <entry name='PA_RAMP2'><comment>Start Ramp 2</comment></entry>
        <entry name='PA_RAMP3'><comment>Start Ramp 3</comment></entry>
        <entry name='PA_RAMP4'><comment>Start Ramp 4</comment></entry>
        <entry name='RX_SOC'/>
        <entry name='DIGRF_STB'/>
        
        <entry name='BCPU_TCU_IRQ0'><comment>Trigger BCPU TCU irq 0</comment></entry>
        <entry name='BCPU_TCU_IRQ1'><comment>Trigger BCPU TCU irq 1</comment></entry>
        
        <entry name='XCPU_TCU_IRQ0'><comment>Trigger XCPU TCU irq 0</comment></entry>
        <entry name='XCPU_TCU_IRQ1'><comment>Trigger XCPU TCU irq 1</comment></entry>
        
        <entry name='WAKEUP_DONE'><comment>End of the WakeUp Mode</comment></entry>
        <entry name='NO_EVENT' value='63'/> 
    </enum>

    
    
	<var name='LP_FRAC_NB_BITS' value='16'/>
	<var name='LP_COUNT_INT_NB_BITS' value='19'/>
	<var name='LP_COUNT_NB_BITS' value='LP_COUNT_INT_NB_BITS + LP_FRAC_NB_BITS'/>
	<var name='LP_RATE_INT_NB_BITS' value='12'/>
	<var name='LP_RATE_NB_BITS' value='LP_RATE_INT_NB_BITS + LP_FRAC_NB_BITS'/>
	<var name='SYS_COUNT_NB_BITS' value='29'/>
	<var name='FRAME_COUNT_NB_BITS' value='10'/>
    
	<var name='PU_COUNT_NB_BITS' value='12'/>


    
    
    <reg name='Ctrl' protect='rw'>
        <bits name='Load_Val' display='hex' access='rw' rst='all1' pos='13:0'>
            <comment>Value loaded into the TCU counter when the Load bit is set to 1
            </comment>
        </bits>
        <bits name='Enable' access='rw' rst='0' pos='16'>
            <options>
                <option name='Disabled' value='0'/>
                <option name='Enabled' value='1'/>
            </options>
        </bits>
        <bits name='Load' access='w' rst='0' pos='20'>
            <comment>Writing a 1 to this bit will load the TCU with the TCU loadval value
                <br/>Writing a 0 has no effect
            </comment>
        </bits>
        <bits name='NoLatch' access='rw' rst='0' pos='28'>
            <options>
                <option name='Normal' value='0'><comment>Normal Behavior, The programmation area is copied to the active area when the tcu wraps</comment></option>
                <option name='Force_Only' value='1'><comment>The programmation area is copied into the active area only when force latch is used</comment></option>
            </options>
        </bits>
    </reg>
    <reg name='Wrap_Val' protect='rw'>
        <bits name='Wrap_Val' display='hex' access='rw' rst='all1' pos='13:0'>
            <comment>TCU counter wrap value.
                <br/>The TCU counter returns to 0 when this value is reached
            </comment>
        </bits>
    </reg>
    <reg name='Cur_Val' protect='rw'>
        <bits name='Cur_Val' display='hex' access='r' pos='13:0'>
            <comment>TCU counter current value
            </comment>
        </bits>
    </reg>
    <reg name='Latch' protect='rw'>
        <bits name='ForceLatch' cut='1' cutprefix='ForceLatch_Area' access='w' pos='7:0'>
            <comment>Writing 1 transfer the programmed events to the active area.
            </comment>
        </bits>
        <bits name='Force_NoEvent' access='w' pos='16'>
            <comment>Writing 1 to this bit with one of the ForceLatch bit will force the corresponding Active Area to receive no events (i.e. clear it) instead of transfering the programmed area.
            </comment>
        </bits>
        <bits name='ClearProgArea' access='w' pos='31'>
            <comment>Writing 1 clears the Program Area
            </comment>
        </bits>
    </reg>
    <reg name='Setup' protect='rw'>
        <bits name='TCO_Polarity' cut='1' cutprefix='POL_TCO' access='rw' rst='0' pos='NB_TCO-1:0'>
            <comment>Configure the TCO polarity
            </comment>
            <options>
                <option name='Active High' value='0'/>
                <option name='Active Low' value='1'/>
            </options>
        </bits>
        <bits name='Write_Error' access='rc' rst='0' pos='28'>
            <comment>Error Status: become 1 when writing to Program Area while the TCU is coping the Program Area to the Active Area. In this case the write is ignored.
                <br/>Write 1 to clear it.
            </comment>
        </bits>
        <bits name='Debug_Active' access='rw' rst='0' pos='31'>
            <comment>This bit allows to access directly the active area for debug purposes
            </comment>
            <options>
                <option name='Normal' value='0'/>
                <option name='Debug' value='1'><comment>the active area is directly mapped instead of the program area.</comment></option>
            </options>
        </bits>
    </reg>
    <reg name='Disable_Event' protect='rw'>
        <bits name='Disable_TCO' cut='1' cutprefix='Disable_TCO' access='rc' rst='all1' pos='9:0'>
            <comment>Writing 1 disable the events that affect corresponding TCO.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name='Disable_Internal_TCO' cut='1' cutprefix='Disable' cutenum='Internal_TCO_mapping' access='rc' rst='all1' pos='14:10'>
            <comment>Writing 1 disable the events that affect corresponding TCO.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name='Disable_Send_Spi_Cmd' access='rc' rst='1' pos='15'>
            <comment>Writing 1 disable the events SEND_SPI_CMD.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name='Disable_Next_Gain' access='rc' rst='1' pos='16'>
            <comment>Writing 1 disable the events NEXT_GAIN.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name='Disable_First_Gain' access='rc' rst='1' pos='17'>
            <comment>Writing 1 disable the events FIRST_GAIN.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name='Disable_Next_Fc' access='rc' rst='1' pos='18'>
            <comment>Writing 1 disable the events NEXT_FC.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name='Disable_Ramp' cut='1' cutprefix='Disable_Ramp' access='rc' rst='all1' pos='23:19'>
            <comment>Writing 1 disable the corresponding Ramp event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name='Disable_Rx_SOC' access='rc' rst='1' pos='24'>
            <comment>Writing 1 disable the events RX_SOC.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name='Disable_DigRF_Strobe' access='rc' rst='1' pos='25'>
            <comment>Writing 1 disable the events DIGRF_STB.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name='Disable_Bcpu_Irq' cut='1' cutprefix='Disable_Bcpu_Irq' access='rc' rst='all1' pos='27:26'>
            <comment>Writing 1 disable the corresponding BCPU TCU irq event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name='Disable_Xcpu_Irq' cut='1' cutprefix='Disable_Xcpu_Irq' access='rc' rst='all1' pos='29:28'>
            <comment>Writing 1 disable the corresponding XCPU TCU irq event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name='Disable_Rf_Spi_Marked_Cmd' access='rc' rst='1' pos='31'>
            <comment>Writing 1 disable the marked rf spi commands (cf RF SPI).
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
    </reg>
    <reg name='Enable_Event' protect='rw'>
        <bits name='Enable_TCO' cut='1' cutprefix='Enable_TCO' access='rs' rst='all1' pos='9:0'>
            <comment>Writing 1 enable the events that affect corresponding TCO.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name='Enable_Internal_TCO' cut='1' cutprefix='Enable' cutenum='Internal_TCO_mapping' access='rs' rst='all1' pos='14:10'>
            <comment>Writing 1 enable the events that affect corresponding TCO.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name='Enable_Send_Spi_Cmd' access='rs' rst='1' pos='15'>
            <comment>Writing 1 enable the events SEND_SPI_CMD.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name='Enable_Next_Gain' access='rs' rst='1' pos='16'>
            <comment>Writing 1 enable the events NEXT_GAIN.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name='Enable_First_Gain' access='rs' rst='1' pos='17'>
            <comment>Writing 1 enable the events FIRST_GAIN.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name='Enable_Next_Fc' access='rs' rst='1' pos='18'>
            <comment>Writing 1 enable the events NEXT_FC.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name='Enable_Ramp' cut='1' cutprefix='Enable_Ramp' access='rs' rst='all1' pos='23:19'>
            <comment>Writing 1 enable the corresponding Ramp event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name='Enable_Rx_SOC' access='rs' rst='1' pos='24'>
            <comment>Writing 1 enable the events RX_SOC.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name='Enable_DigRF_Strobe' access='rs' rst='1' pos='25'>
            <comment>Writing 1 enable the events DIGRF_STB.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name='Enable_Bcpu_Irq' cut='1' cutprefix='Enable_Bcpu_Irq' access='rs' rst='all1' pos='27:26'>
            <comment>Writing 1 enable the corresponding BCPU TCU irq event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name='Enable_Xcpu_Irq' cut='1' cutprefix='Enable_Xcpu_Irq' access='rs' rst='all1' pos='29:28'>
            <comment>Writing 1 enable the corresponding XCPU TCU irq event.
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
        <bits name='Enable_Rf_Spi_Marked_Cmd' access='rs' rst='1' pos='31'>
            <comment>Writing 1 enable the marked rf spi commands (cf RF SPI).
                <br/>Reading return the actual enable state.
            </comment>
        </bits>
    </reg>
    <reg name='Set_TCO' protect='rw'>
        <bits name='Set_TCO' cut='1' cutprefix='Set_TCO' access='s' pos='NB_TCO-1:0'>
            <comment>Writing 1 set corresponding TCO to the active state (The actual line state also depends on TCO_Polarity).
                <br/>Reading returns the actual state of all TCOs.
            </comment>
        </bits>
    </reg>
    <reg name='Clr_TCO' protect='rw'>
        <bits name='Clr_TCO' cut='1' cutprefix='Clr_TCO' access='c' pos='NB_TCO-1:0'>
            <comment>Writing 1 set corresponding TCO to the inactive state (The actual line state also depends on TCO_Polarity).
                <br/>Reading returns the actual state of all TCOs.
            </comment>
        </bits>
    </reg>

    <reg name='Cfg_Clk_Div' protect='rw'>
        <bits name='Enable_Qbit' access='rw' rst='0' pos='31'>
            <comment>Enable the Quarter bit generation (required for normal TCU operation)
            </comment>
            <options>
                <option name='Disabled' value='0'/>
                <option name='Enabled' value='1'/>
            </options>
        </bits>
        <bits name='Enable_DAI_Simple_208K' access='rw' rst='0' pos='30'>
            <comment>Enable the 208kHz pulse generation for DAI Simple. (!) When enabling the clock field Enable_Qbit should also be enabled.
            </comment>
            <options>
                <option name='Disabled' value='0'/>
                <option name='Enabled' value='1'/>
            </options>
        </bits>
    </reg>
    <reg name='LPS_SF_Ctrl' protect='rw'>
        <bits name='LPS_SF_Enable' access='rw' rst='0' pos='0'>
            <comment>Lps Skip Frame Enable.
                <br/>When enabled the frame interrupt are masked until the programmed number of frames are elapsed.
                <br/>This is done by masking the frame interrupt line from the regular TCU counter, and counting the frames. Also when activating the LowPower SkipFrame the frame counter is tranfered to the low power counter that will update it based on the 32kHz Clock.
            </comment>
        </bits>
        <bits name='LPS_SF_LowPower' access='rw' rst='0' pos='5:4'>
            <comment>Controls the Lps Low Power Counters (counters at 32kHz) usage.
            </comment>
            <options>
                <option name='Stop' value='0'><comment>Disable the Low Power Counters.</comment></option>
                <option name='SkipFrame' value='1'><comment>The Low Power Counters are started in Skip Frame Mode. In this mode the Low Power Counter are used to maintain the Time base, The Skip Frame Must be enabled as this is the Low Power extention of the Skip Frame feature.</comment></option>
                <option name='Calib' value='3'><comment>Start the calibration. The Low Power Counters are used to Calibrate the 32kHz clock against the System Clock, The Calibration is required to compensate from temperature variation. Note that the Skip Frame can also be enabled during calibration (but not with low power).</comment></option>
                <mask/>
                <shift/>
                <default/>
            </options>
        </bits>
    </reg>
    <reg name='LPS_SF_Status' protect='rw'>
        <bits name='LPS_SF_Ready' access='r' rst='0' pos='0'>
            <comment>Lps Skip Frame Ready, status of the state machines to keep valid state between system clock and 32Khz clock.
                <br/>Must read as '1' before entering Low Power Skip Frame or Calibration mode.
            </comment>
        </bits>
        <bits name='LPS_SF_SlowRunning' access='r' rst='0' pos='4'>
            <comment>'1' when Lps Skip Frame Low Power Counters are Running.
                <br/>When entering Low Power Skip Frame, the counters are not immediately started, they wait for the nextFrame interrupt. Reading this status allow to know if the counters are running, and the System Clock can be safely disabled.
            </comment>
        </bits>
        <bits name='LPS_SF_CalibrationDone' access='r' rst='0' pos='8'>
            <comment>'1' when the Lps Skip Frame Calibration is Done.
            </comment>
        </bits>
        <bits name='LPS_SF_PU_Reached' access='r' rst='0' pos='31'>
            <comment>'1' when the Lps Skip Frame Power-up sequence frame is reached.
            </comment>
        </bits>
    </reg>
    <reg name='LPS_SF_Frames' protect='rw'>
        <bits name='LPS_SF_Frame' access='rw' pos='FRAME_COUNT_NB_BITS-1:0'>
            <comment>Number of frames to Skip.
                <br/>If the power up sequence is enabled, frames are skipped until both this number is reached and the powerup sequence has finished.
                <br/>Note: The power up sequence must be <b>Done</b> before the the frame LPS_SF_Frame ends.
            </comment>
        </bits>
        <bits name='LPS_SF_PU_Frame' access='rw' pos='FRAME_COUNT_NB_BITS+15:16'>
            <comment>Number of frames before activating the Power-up sequence.
            </comment>
        </bits>
    </reg>
    <reg name='LPS_SF_Restart_Time' protect='rw'>
        <bits name='LPS_SF_Restart_Time' access='rw' pos='LP_COUNT_INT_NB_BITS-1:0'>
            <comment>For LowPower SkipFrame mode: Value to restart TCU (and frame interrupt generation) on the system clock counter after a low power phase.
                <br/>For Calibration mode: number of 32k cycles for the calibration.
            </comment>
        </bits>
    </reg>
    <reg name='LPS_SF_Frame_Period' protect='rw'>
        <bits name='LPS_SF_Frame_Period' access='rw' pos='LP_COUNT_INT_NB_BITS-1:0'>
            <comment>Value of the frame period in system clock count.
            </comment>
        </bits>
    </reg>
    <reg name='LPS_SF_Rate' protect='rw'>
        <comment>The rate is the number of System Clocks per 32kHz Clocks.
        </comment>
        <bits name='LPS_SF_Rate_Int' access='rw' pos='LP_RATE_NB_BITS-1:LP_FRAC_NB_BITS'>
            <comment>Integer part of the rate.
            </comment>
        </bits>
        <bits name='LPS_SF_Rate_Frac' access='rw' pos='LP_FRAC_NB_BITS-1:0'>
            <comment>Fractional part of the rate.
            </comment>
        </bits>
    </reg>
    <reg name='LPS_SF_Elapsed_Frames' protect='rw'>
        <bits name='LPS_SF_Elapsed_Frames' access='r' rst='0' pos='FRAME_COUNT_NB_BITS-1:0'>
            <comment>Current number of elapsed frames.
                <br/>Valid when Skip Frame is Enabled.
            </comment>
        </bits>
    </reg>
    <reg name='LPS_SF_Sys_Count' protect='rw'>
        <bits name='LPS_SF_Sys_Count' access='r' rst='0' pos='SYS_COUNT_NB_BITS-1:0'>
            <comment>Value of the system clock counter at the end of calibration (when CalibrationDone is '1' in LPS_SF_Status register).
                <br/>The hardware behind it is reused during other operation, reading that register at any other time will return an undefined value.
            </comment>
        </bits>
    </reg>
    <reg name='LPS_PU_Ctrl' protect='rw'>
        <bits name='LPS_PU_Enable' access='rw' rst='0' pos='0'>
            <comment>Enable the Power-Up Sequence.
                <br/>This bit is automatically cleared when the sequence is <b>Done</b>.
            </comment>
        </bits>
        <bits name='LPS_PU_ForceStart' access='rw' rst='0' pos='4'>
            <comment>When '1' forces the Power-up sequence to start.
                <br/>This bit is automatically cleared when the sequence is <b>Done</b>.
            </comment>
        </bits>
        <bits name='LPS_PU_CO0_On' access='rw' rst='0' pos='8'>
            <comment>This force the Controlled Output 0 (LPSCO[0]) to be Active (See polarity for actual line state).
            </comment>
        </bits>
        <bits name='LPS_PU_CO1_On' access='rw' rst='0' pos='9'>
            <comment>This force the Controlled Output 1 (LPSCO[1]) to be Active (See polarity for actual line state).
            </comment>
        </bits>
        <bitgroup name='LPS_PU_CO_On'>
            <entry ref='LPS_PU_CO0_On'/>
            <entry ref='LPS_PU_CO1_On'/>
        </bitgroup>
        <bits name='LPS_PU_CLK_RF_On' access='rw' rst='0' pos='10'>
            <comment>This force the Clock RF control line (CLK_RF_26M_EN) to be on.
            </comment>
        </bits>
        <bits name='LPS_PU_SPI_On' access='rw' rst='0' pos='11'>
            <comment>This force the SPI to be on.
            </comment>
        </bits>
        <bits name='LPS_PU_CO0_Pol' access='rw' rst='0' pos='12'>
            <comment>This sets the Controlled Output 0 (LPSCO[0]) polarity.
                <br/>Set to '1' if the line is active low.
            </comment>
        </bits>
        <bits name='LPS_PU_CO1_Pol' access='rw' rst='0' pos='13'>
            <comment>This sets the Controlled Output 1 (LPSCO[1]) polarity.
                <br/>Set to '1' if the line is active low.
            </comment>
        </bits>
        <bitgroup name='LPS_PU_CO_Pol'>
            <entry ref='LPS_PU_CO0_Pol'/>
            <entry ref='LPS_PU_CO1_Pol'/>
        </bitgroup>
        <bits name='LPS_PU_CLK_RF_Pol' access='rw' rst='0' pos='14'>
            <comment>This sets the Clock RF control line (CLK_RF_26M_EN) polarity.
                <br/>Set to '1' if the line is active low.
            </comment>
        </bits>
        <bits name='LPS_PU_SPI_Step' access='rw' rst='0' pos='18:16'>
            <comment>This selects the step where the SPI is switched on during the power up sequence.
            </comment>
            <options>
                <option name='CO_S1' value='0'><comment>The SPI is switched on at state <b>Controlled Output step 1</b>.</comment></option>
                <option name='RFClkReady' value='1'><comment>The SPI is switched on at state <b>RF Clock Ready</b>.</comment></option>
                <option name='Ready' value='2'><comment>The Analog SPI is switched on at state <b>Ready</b>.</comment></option>
                <option name='Done' value='3'><comment>The Analog SPI is switched on at state <b>Done</b>.</comment></option>
            </options>
        </bits>
        <bits name='LPS_PU_Mask_CO0_S1' access='rw' rst='0' pos='20'>
            <comment>This selects the action to take on Controlled Output 0 (LPSCO[0]) during the state <b>Controlled Output step 1</b>.
            </comment>
            <options>
                <option name='Enable' value='1'><comment>The Controlled Output 0 (LPSCO[0]) is switched on during the state <b>Controlled Output step 1</b>.</comment></option>
                <option name='Ignore' value='0'><comment>The Controlled Output 0 (LPSCO[0]) is not changed during the state <b>Controlled Output step 1</b>.</comment></option>
            </options>
        </bits>
        <bits name='LPS_PU_Mask_CO1_S1' access='rw' rst='0' pos='21'>
            <comment>This selects the action to take on Controlled Output 1 (LPSCO[1]) during the state <b>Controlled Output step 1</b>.
            </comment>
            <options>
                <option name='Enable' value='1'><comment>The Controlled Output 1 (LPSCO[1]) is switched on during the state <b>Controlled Output step 1</b>.</comment></option>
                <option name='Ignore' value='0'><comment>The Controlled Output 1 (LPSCO[1]) is not changed during the state <b>Controlled Output step 1</b>.</comment></option>
            </options>
        </bits>
        <bitgroup name='LPS_PU_Mask_CO_S1'>
            <entry ref='LPS_PU_Mask_CO0_S1'/>
            <entry ref='LPS_PU_Mask_CO1_S1'/>
        </bitgroup>
        <bits name='LPS_PU_Mask_CO0_S2' access='rw' rst='0' pos='22'>
            <comment>This selects the action to take on Controlled Output 0 (LPSCO[0]) during the state <b>Controlled Output step 2</b>.
            </comment>
            <options>
                <option name='Enable' value='1'><comment>The Controlled Output 0 (LPSCO[0]) is switched on during the state <b>Controlled Output step 2</b>.</comment></option>
                <option name='Ignore' value='0'><comment>The Controlled Output 0 (LPSCO[0]) is not changed during the state <b>Controlled Output step 2</b>.</comment></option>
            </options>
        </bits>
        <bits name='LPS_PU_Mask_CO1_S2' access='rw' rst='0' pos='23'>
            <comment>This selects the action to take on Controlled Output 1 (LPSCO[1]) during the state <b>Controlled Output step 2</b>.
            </comment>
            <options>
                <option name='Enable' value='1'><comment>The Controlled Output 1 (LPSCO[1]) is switched on during the state <b>Controlled Output step 2</b>.</comment></option>
                <option name='Ignore' value='0'><comment>The Controlled Output 1 (LPSCO[1]) is not changed during the state <b>Controlled Output step 2</b>.</comment></option>
            </options>
        </bits>
        <bitgroup name='LPS_PU_Mask_CO_S2'>
            <entry ref='LPS_PU_Mask_CO0_S2'/>
            <entry ref='LPS_PU_Mask_CO1_S2'/>
        </bitgroup>
        
        <bits name='LPS_PU_Mask_CLK_RF' access='rw' rst='0' pos='24'>
            <comment>Mask Start Clock RF: When set to '1' the Clock RF is not started during the power up sequence.
            </comment>
            <options>
                <option name='Enable' value='1'><comment>The Clock RF is started during the state <b>RF Clock Enable</b>.</comment></option>
                <option name='Ignore' value='0'><comment>The Clock RF is not started.</comment></option>
            </options>
        </bits>

        <bits name='LPS_PU_Mask_St_PLL' access='rw' rst='0' pos='25'>
            <comment>Mask Start Pll: When set to '1' the Pll is not started during the power up sequence.
            </comment>
            <options>
                <option name='Enable' value='1'><comment>The Pll is started during the state <b>RF Clock Ready</b>.</comment></option>
                <option name='Ignore' value='0'><comment>The Pll is not started.</comment></option>
            </options>
        </bits>
        <bits name='LPS_PU_Mask_Sw_RF' access='rw' rst='0' pos='26'>
            <comment>Mask Switch to RF clock: When set to '1' the slow clock is not switched to the RF clock during the power up sequence.
            </comment>
            <options>
                <option name='Switch' value='1'><comment>The System Clock is switched to Clock RF during the state <b>RF Clock Ready</b>.</comment></option>
                <option name='Ignore' value='0'><comment>The System Clock is not switched.</comment></option>
            </options>
        </bits>
        <bits name='LPS_PU_Mask_Sw_Fast' access='rw' rst='0' pos='27'>
            <comment>Mask Switch to Fast clock: When set to '1' the system clock is not switched to the Fast clock during the power up sequence.
            </comment>
            <options>
                <option name='Switch' value='1'><comment>The System Clock is switched to Clock Pll during the state <b>Pll Clock Ready</b>.</comment></option>
                <option name='Ignore' value='0'><comment>The System Clock is not switched.</comment></option>
            </options>
        </bits>
        <bits name='LPS_PU_CPU_Done' access='rw' rst='0' pos='28'>
            <comment>When set to '1' Ready step is done for the CPU.
                <br/>When both the CPU and the TCU are done, the state <b>Ready</b> ends and the state machine goes to state <b>Done</b>.
                <br/>This bit is automatically cleared when the sequence is <b>Done</b>.
            </comment>
        </bits>
        <bits name='LPS_PU_Run_TCU_WakeUp' access='rw' rst='0' pos='29'>
            <comment>Run the TCU in WakeUp mode:
                <br/>In WakeUp mode, the TCU is started at time 0, process the TCU events until it reaches the Event WAKEUP_DONE.
                <br/>The WakeUp mode is started during the state <b>Ready</b>, the state <b>Ready</b> ends when both the CPU and the TCU are done.
                <br/>If the TCU is not started in WakeUp mode, it is considered Done for the <b>Ready</b> end.
            </comment>
        </bits>
    </reg>
    <reg name='LPS_PU_Status' protect='rw'>
        <bits name='LPS_PU_Done' access='r' rst='0' pos='0'>
            <comment>The Power-Up Sequence is done (or idle).
            </comment>
        </bits>
        <bits name='LPS_PU_Ready' access='r' rst='0' pos='4'>
            <comment>The Power-Up Sequence is in state <b>Ready</b>.
            </comment>
        </bits>
    </reg>
    <reg name='LPS_PU_Times' protect='rw'>
        <bits name='LPS_PU_tCO_S2' access='rw' rst='0' pos='4:0'>
            <comment>Time in 32Khz clocks to wait between the states <b>Controlled Output step 1</b> and <b>Controlled Output step 2</b>.
            </comment>
        </bits>
        <bits name='LPS_PU_tCLK_RF_EN' access='rw' rst='0' pos='10:6'>
            <comment>Time in 32Khz clocks to wait between the states <b>Controlled Output step 2</b> and <b>RF Clock Enable</b>.
            </comment>
        </bits>
        <bits name='LPS_PU_tCLK_RF' access='rw' rst='all1' pos='23:12'>
            <comment>Time in 32Khz clocks to wait between the states <b>RF Clock Enable</b> and <b>RF Clock Ready</b>.
                <br/>This is the time to wait after VCO enable before switching to RF and starting the PLL.
            </comment>
        </bits>
        <bits name='LPS_PU_tCLK_PLL' access='rw' rst='0' pos='28:24'>
            <comment>Time in 32Khz clocks to wait between the states <b>RF Clock Ready</b> and <b>Pll Clock Ready</b>.
                <br/>This is the time to wait after starting the PLL before switching to the Fast clock or checking if the PLL is locked.
            </comment>
        </bits>
        <bits name='LPS_PU_PLL_Lock' access='rw' rst='0' pos='31'>
            <comment>If set waits for the lock status of the PLL after the LPS_PU_PLL time is elapsed before switching to the Fast Clock (in Fast step), else switch immediately after the expiration of the time.
            </comment>
            <options>
                <option name='Bypass' value='0'><comment>After expiration of the time LPS_PU_tClk_PLL go directly to the state <b>Pll Clock Ready</b>.</comment></option>
                <option name='Check' value='1'><comment>After expiration of the time LPS_PU_tClk_PLL, wait for the PLL to be locked before going to the state <b>Pll Clock Ready</b>.</comment></option>
            </options>
        </bits>
    </reg>
    <reg name='LPS_PU_IRQ' protect='rw'>
        <bits name='LPS_IRQ_Calibration_Done_Cause' access='rc' rst='0' pos='0'>
            <comment>1 when the IRQ was triggered because the calibration is done.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name='LPS_IRQ_Slow_Running_Cause' access='rc' rst='0' pos='1'>
            <comment>1 when the IRQ was triggered because the Slow Counter started.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name='LPS_IRQ_PU_Done_Cause' access='rc' rst='0' pos='2'>
            <comment>1 when the IRQ was triggered because the Power-Up sequence is done.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name='LPS_IRQ_PU_Ready_Cause' access='rc' rst='0' pos='3'>
            <comment>1 when the IRQ was triggered because the Power-Up sequence reached the state <b>Ready</b>.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name='LPS_IRQ_PU_Reached_Cause' access='rc' rst='0' pos='4'>
            <comment>1 when the IRQ was triggered because the Power-Up frame was reached.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bitgroup name='LPS_PU_IRQ_Cause'>
            <entry ref='LPS_IRQ_Calibration_Done_Cause'/>
            <entry ref='LPS_IRQ_Slow_Running_Cause'/>
            <entry ref='LPS_IRQ_PU_Done_Cause'/>
            <entry ref='LPS_IRQ_PU_Ready_Cause'/>
            <entry ref='LPS_IRQ_PU_Reached_Cause'/>
        </bitgroup>

        <bits name='LPS_IRQ_Calibration_Done_Status' access='rc' rst='0' pos='16'>
            <comment>1 when the calibration is done.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name='LPS_IRQ_Slow_Running_Status' access='rc' rst='0' pos='17'>
            <comment>1 when the Slow Counter started.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name='LPS_IRQ_PU_Done_Status' access='rc' rst='0' pos='18'>
            <comment>1 when the Power-Up sequence is done.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name='LPS_IRQ_PU_Ready_Status' access='rc' rst='0' pos='19'>
            <comment>1 when the Power-Up sequence reached the state <b>Ready</b>.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bits name='LPS_IRQ_PU_Reached_Status' access='rc' rst='0' pos='20'>
            <comment>1 when the Power-Up frame was reached.
                <br/>Write 1 in cause or status bit to clear.
            </comment>
        </bits>
        <bitgroup name='LPS_PU_IRQ_Status'>
            <entry ref='LPS_IRQ_Calibration_Done_Status'/>
            <entry ref='LPS_IRQ_Slow_Running_Status'/>
            <entry ref='LPS_IRQ_PU_Done_Status'/>
            <entry ref='LPS_IRQ_PU_Ready_Status'/>
            <entry ref='LPS_IRQ_PU_Reached_Status'/>
        </bitgroup>
    </reg>
    <reg name='LPS_PU_IRQ_Mask' protect='rw'>
        <bits name='LPS_IRQ_Calibration_Done_Mask' access='rw' rst='0' pos='0'>
            <comment>when 1 the LPS_IRQ_Calibration_Done is enabled.
            </comment>
        </bits>
        <bits name='LPS_IRQ_Slow_Running_Mask' access='rw' rst='0' pos='1'>
            <comment>when 1 the LPS_IRQ_Slow_Running is enabled.
            </comment>
        </bits>
        <bits name='LPS_IRQ_PU_Done_Mask' access='rw' rst='0' pos='2'>
            <comment>when 1 the LPS_IRQ_PU_Done is enabled.
            </comment>
        </bits>
        <bits name='LPS_IRQ_PU_Ready_Mask' access='rw' rst='0' pos='3'>
            <comment>when 1 the LPS_IRQ_PU_Ready is enabled.
            </comment>
        </bits>
        <bits name='LPS_IRQ_PU_Reached_Mask' access='rw' rst='0' pos='4'>
            <comment>when 1 the LPS_IRQ_PU_Reached is enabled.
            </comment>
        </bits>
        <bitgroup name='LPS_PU_IRQ_Mask'>
            <entry ref='LPS_IRQ_Calibration_Done_Mask'/>
            <entry ref='LPS_IRQ_Slow_Running_Mask'/>
            <entry ref='LPS_IRQ_PU_Done_Mask'/>
            <entry ref='LPS_IRQ_PU_Ready_Mask'/>
            <entry ref='LPS_IRQ_PU_Reached_Mask'/>
        </bitgroup>
    </reg>
    <hole size='1312'/>
    <reg name='Event' protect='rw' count='NB_TCU_PROG_EVENTS'>
        <bits name='Event_Time' access='rw' rst='all1' pos='13:0'>
            <comment>The event Id will be executed when the TCU counter reaches the value programmed in Event time field of this register.
            </comment>
        </bits>
        <bits name='Event_Id' access='rw' rst='all1' pos='21:16'>
            <comment>Event to be executed when the TCU counter reaches the programmed event time.
                <br/>
            </comment>
            <options linkenum='TCU_Event'>
                <default/>
            </options>
        </bits>
    </reg>

</module>

</archive>
<archive relative='timer.xml'>


<module name='timer' category='System'>
    <var name='NB_INTERVAL' value='1'/>
    <var name='INT_TIMER_NB_BITS' value='24'/>
    <var name='WD_TIMER_NB_BITS' value='24'/>
    <var name='HW_TIMER_NB_BITS' value='32'/>
    <var name='TIM_MAXVAL' value='0xffffff'/>

    <reg name='OSTimer_Ctrl' protect='rw'>
        <bits name='LoadVal' access='rw' rst='0' pos='23:0'>
            <comment>Value loaded to OS timer.
            </comment>
        </bits>
        <bits name='Enable' access='rw' rst='0' pos='24'>
            <comment>Write '1' to this bit will enable OS timer.
                <br/>When read, the value is what we have written to this bit, it changes immediately  after been written.
            </comment>
        </bits>
        <bits name='Enabled' access='r' rst='0' pos='25'>
            <comment>Read this bit will get the information if OS timer is really enabled or not. This bit will change only after the next front of 16 KHz system clock.
                <br/>
                <br/>'1' indicates OS timer enabled.
                <br/>'0' indicates OS timer not enabled.
            </comment>
        </bits>
        <bits name='Cleared' access='r' rst='0' pos='26'>
            <comment>Read this bit will get the information if OS timer interruption clear operation is finished or not.
                <br/>
                <br/>'1' indicates OS timer interruption clear operation is on going.
                <br/>'0' indicates no OS timer interruption clear operation is on going.
            </comment>
        </bits>
        <bits name='Repeat' access='rw' rst='0' pos='28'>
            <comment>Write '1' to this bit will set OS timer to repeat mode.
                <br/>When read, get the information if OS timer is in repeat mode.
                <br/>
                <br/>'1' indicates OS timer in repeat mode.
                <br/>'0' indicates OS timer not in repeat mode.
            </comment>
        </bits>
        <bits name='Wrap' access='rw' rst='0' pos='29'>
            <comment>Write '1' to this bit will set OS timer to wrap mode.
                <br/>When read, get the information if OS timer is in wrap mode.
                <br/>
                <br/>'1' indicates OS timer in wrap mode.
                <br/>'0' indicates OS timer not in wrap mode.
            </comment>
        </bits>
        <bits name='Load' access='rw' rst='0' pos='30'>
            <comment>Write '1' to this bit will load the initial value to OS timer.
            </comment>
        </bits>
    </reg>
    <reg name='OSTimer_CurVal' protect='rw'>
        <bits name='CurVal' access='r' rst='-' pos='31:0'>
            <comment>Current value of OS timer. The value is 24 bits and the first 8 bits are sign extension of the most important bit. A negative value indicates that the timer has wraped.
            </comment>
        </bits>
    </reg>
    <reg name='WDTimer_Ctrl' protect='rw'>
        <bits name='Start' access='s' rst='0' pos='0'>
            <comment>Write '1' to this bit will enable watchdog timer and Load it with WDTimer_LoadVal.
            </comment>
        </bits>
        <bits name='Stop' access='c' rst='0' pos='4'>
            <comment>Write '1' to this bit will stop watchdog timer.
            </comment>
        </bits>
        <bits name='ReLoad' access='w' rst='0' pos='16'>
            <comment>Write '1' to this bit will load WDTimer_LoadVal value to watchdog timer.
                <br/>Use this bit to implement the watchog keep alive.
            </comment>
        </bits>

        <bits name='WDEnabled' access='r' rst='0' pos='8'>
            <comment>Read this bit will get the information if watchdog timer is really enabled or not. This bit will change only after the next front of 32 KHz system clock.
                <br/>
                <br/>'1' indicates watchdog timer is enabled, if current watchdog timer value reaches 0, the system will be reseted.
                <br/>'0' indicates watchdog timer is not enabled.
            </comment>
        </bits>
    </reg>
    <reg name='WDTimer_LoadVal' protect='rw'>
        <bits name='LoadVal' access='r' rst='-' pos='WD_TIMER_NB_BITS-1:0'>
            <comment>Load value of watchdog timer. Number of 32kHz Clock before Reset.
                <br/>
            </comment>
        </bits>
    </reg>
    <reg name='HWTimer_Ctrl' protect='rw'>
        <bits name='Interval_En' access='rw' rst='0' pos='8'>
            <comment>This bit enables interval IRQ mode.
                <br/>
                <br/>'0': hw delay timer does not generate interval IRQ.
                <br/>'1': hw delay timer generate an IRQ each interval.
            </comment>
        </bits>
        <bits name='Interval' access='rw' rst='00' pos='1:0'>
            <comment> interval of generating an HwTimer IRQ. 
                <br/>
                <br/>"00": interval of 1/8 second.
                <br/>"01": interval of 1/4 second.
                <br/>"10": interval of 1/2 second.
                <br/>"11": interval of 1 second.
            </comment>
        </bits>
    </reg>
    <reg name='HWTimer_CurVal' protect='rw'>
        <bits name='CurVal' access='r' rst='0' pos='31:0'>
            <comment>Current value of the hardware delay timer. This timer is running all the time and wrap at value 0xFFFFFFFF.
            </comment>
        </bits>
    </reg>
    <reg name='Timer_Irq_Mask_Set' protect='rw'>
        <bits name='OSTimer_Mask' access='rs' rst='0' pos='0'>
            <comment>Set mask for OS timer IRQ.
            </comment>
        </bits>
        <bits name='HWTimer_Wrap_Mask' access='rs' rst='0' pos='1'>
            <comment>Set mask for hardwre delay timer wrap IRQ.
            </comment>
        </bits>
        <bits name='HWTimer_Itv_Mask' access='rs' rst='0' pos='2'>
            <comment>Set mask for hardwre delay timer interval IRQ.
            </comment>
        </bits>
    </reg>
    <reg name='Timer_Irq_Mask_Clr' protect='rw'>
        <bits name='OSTimer_Mask' access='rc' rst='0' pos='0'>
            <comment>Clear mask for OS timer IRQ.
            </comment>
        </bits>
        <bits name='HWTimer_Wrap_Mask' access='rc' rst='0' pos='1'>
            <comment>Clear mask for hardwre delay timer wrap IRQ.
            </comment>
        </bits>
        <bits name='HWTimer_Itv_Mask' access='rc' rst='0' pos='2'>
            <comment>Clear mask for hardwre delay timer interval IRQ.
            </comment>
        </bits>
    </reg>
    <reg name='Timer_Irq_Clr' protect='rw'>
        <bits name='OSTimer_Clr' access='c' pos='0'>
            <comment>Clear OS timer IRQ.
            </comment>
        </bits>
        <bits name='HWTimer_Wrap_Clr' access='c' pos='1'>
            <comment>Clear hardware delay timer wrap IRQ.
            </comment>
        </bits>
        <bits name='HWTimer_Itv_Clr' access='c' pos='2'>
            <comment>Clear hardware delay timer interval IRQ.
            </comment>
        </bits>
    </reg>
    <reg name='Timer_Irq_Cause' protect='rw'>
        <bits name='OSTimer_Cause' access='r' rst='0' pos='0'>
            <comment>OS timer IRQ cause.
            </comment>
        </bits>
        <bits name='HWTimer_Wrap_Cause' access='r' rst='0' pos='1'>
            <comment>hardware delay timer wrap IRQ cause.
            </comment>
        </bits>
        <bits name='HWTimer_Itv_Cause' access='r' rst='0' pos='2'>
            <comment>hardware delay timer interval IRQ cause.
            </comment>
        </bits>
        <bits name='OSTimer_Status' access='r' rst='0' pos='16'>
            <comment>OS timer IRQ status.
            </comment>
        </bits>
        <bits name='HWTimer_Wrap_Status' access='r' rst='0' pos='17'>
            <comment>hardware delay timer wrap IRQ status.
            </comment>
        </bits>
        <bits name='HWTimer_Itv_Status' access='r' rst='0' pos='18'>
            <comment>hardware delay timer interval IRQ status.
            </comment>
        </bits>
        <bitgroup name='Other_Tims_irq'>
            <entry ref='HWTimer_Wrap_Cause'/>
            <entry ref='HWTimer_Itv_Cause'/>
        </bitgroup>
    </reg>
</module>

</archive>

<archive relative='uart.xml'>

<module name='uart' category='Periph'>
  <var name='UART_RX_FIFO_SIZE' value='32'/>
  <var name='UART_TX_FIFO_SIZE' value='16'/>
  <var name='NB_RX_FIFO_BITS' value='5'/>
  <var name='NB_TX_FIFO_BITS' value='4'/>

  
  <reg name='ctrl' protect='rw'>
    <bits name='Enable' access='rw' rst='0' pos='0'>
      <options>
        <option name='DISABLE' value='0'/>

        <option name='ENABLE' value='1'/>

        <default/>
      </options>

      <comment>Allows to turn off the UART:<br/>0 = Disable<br/>1 = Enable
      </comment>
    </bits>

    <bits name='Data Bits' access='rw' rst='0' pos='1'>
      <options>
        <option name='7_BITS' value='0'/>

        <option name='8_BITS' value='1'/>

        <default/>
      </options>

      <comment>Number of data bits per character (least significant bit
      first):<br/>0 = 7 bits<br/>1 = 8 bits </comment>
    </bits>

    <bits name='Tx Stop Bits' access='rw' rst='0' pos='2'>
      <options>
        <option name='1_BIT' value='0'/>

        <option name='2_BITS' value='1'/>

        <default/>
      </options>

      <comment>Stop bits controls the number of stop bits transmitted. Can
      receive with one stop bit (more inaccuracy can be compensated with two
      stop bits when divisor mode is set to 0).<br/>0 = one stop bit is
      transmitted in the serial data.<br/>1 = two stop bits are generated and
      transmitted in the serial data out. </comment>
    </bits>

    <bits name='Parity Enable' access='rw' rst='0' pos='3'>
      <options>
        <option name='NO' value='0'/>

        <option name='YES' value='1'/>

        <default/>
      </options>

      <comment> Parity is enabled when this bit is set. </comment>
    </bits>

    <bits name='Parity Select' access='rw' rst='0' pos='5:4'>
      <options>
        <option name='ODD' value='0'/>

        <option name='EVEN' value='1'/>

        <option name='SPACE' value='2'/>

        <option name='MARK' value='3'/>

        <default/>
      </options>

      <comment> Controls the parity format when parity is enabled:<br/>00 =
      an odd number of received 1 bits is checked, or transmitted (the parity
      bit is included).<br/>01 = an even number of received 1 bits is checked
      or transmitted (the parity bit is included).<br/>10 = a space is
      generated and received as parity bit.<br/>11 = a mark is generated and
      received as parity bit. </comment>
    </bits>


    <bits name='Divisor Mode' access='rw' rst='0' pos='20'>
      <comment>Selects the divisor value used to generate the baud rate
      frequency (BCLK) from the SCLK (see UART Operation for details). If IrDA
      is enable, this bit is ignored and the divisor used will be 16.<br/>0 =
      (BCLK = SCLK / 4)<br/>1 = (BCLK = SCLK / 16) </comment>
    </bits>

    <bits name='IrDA Enable' access='rw' rst='0' pos='21'>
      <comment>When set, the UART is in IrDA mode and the baud rate divisor
      used is 16 (see UART Operation for details). </comment>
    </bits>

    <bits name='DMA Mode' access='rw' rst='0' pos='22'>
      <options>
        <option name='DISABLE' value='0'/>

        <option name='ENABLE' value='1'/>

        <default/>
      </options>

      <comment>Enables the DMA signaling for the Uart_Dma_Tx_Req_H and
      Uart_Dma_Rx_Req_H to the IFC. </comment>
    </bits>
    
    <bits name='Auto Flow Control' access='rw' rst='0' pos='23'>
      <options>
        <option name='ENABLE' value='1'/>
        
        <option name='DISABLE' value='0'/>
        
        <default/>
      </options>
      <comment>Enables the auto flow control. Uart_RTS is controlled by the Rx
      RTS bit and the UART Auto Control Flow System. If Uart_CTS
      become inactive high, the Tx data flow is stopped. </comment>
    </bits>

    <bits name='Loop Back Mode' access='rw' rst='0' pos='24'>
      <comment>When set, data on the Uart_Tx line is held high, while the
      serial output is looped back to the serial input line, internally. In
      this mode all the interrupts are fully functional. This feature is used
      for diagnostic purposes. Also, in loop back mode, the modem control
      input Uart_CTS is disconnected and the modem control output Uart_RTS are
      looped back to the inputs, internally. In IrDA mode, Uart_Tx signal is
      inverted (see IrDA SIR Mode Support). </comment>
    </bits>

    <bits name='Rx Lock Err' access='rw' rst='0' pos='25'>
      <comment>Allow to stop the data receiving when an error is detected
      (framing, parity or break). The data in the fifo are kept. </comment>
    </bits>

    <bits name='Rx Break Length' access='rw' rst='0xF' pos='31:28'>
      <comment>Length of a break, in number of bits. </comment>
    </bits>
  </reg>

  <reg name='status' protect='r'>
    <bits name='Rx Fifo Level' access='r' rst='0' pos='NB_RX_FIFO_BITS:0'>
       <options>
            <mask/>
            <shift/>
        </options>
        <comment>Those bits indicate the number of data available in the Rx
      Fifo. Those data can be read. </comment>
    </bits>

    <bits name='Tx Fifo space' access='r' rst='0' pos='NB_TX_FIFO_BITS+8:8'>
        <options>
            <mask/>
            <shift/>
        </options>
        <comment>Those bits indicate the number of space available in the Tx
      Fifo. </comment>
    </bits>

    <bits name='Tx Active' access='r' rst='0' pos='14'>
      <comment>This bit indicates that the UART is sending data. If no data is
      in the fifo, the UART is currently sending the last one through the
      serial interface. </comment>
    </bits>

    <bits name='Rx Active' access='r' rst='0' pos='15'>
      <comment>This bit indicates that the UART is receiving a byte.
      </comment>
    </bits>

    <bits name='Rx Overflow Err' access='r' rst='0' pos='16'>
      <comment>This bit indicates that the receiver received a new character
      when the fifo was already full. The new character is discarded. This bit
      is cleared when the UART_STATUS register is written with any value.
      </comment>
    </bits>

    <bits name='Tx Overflow Err' access='r' rst='0' pos='17'>
      <comment>This bit indicates that the user tried to write a character when fifo was
          already full. The written data will not be kept. This bit is cleared when 
          the UART_STATUS register is written with any value. </comment>
    </bits>

    <bits name='Rx Parity Err' access='r' rst='0' pos='18'>
      <comment>This bit is set if the parity is enabled and a parity error
      occurred in the received data. This bit is cleared when the UART_STATUS
      register is written with any value. </comment>
    </bits>

    <bits name='Rx Framing Err' access='r' rst='0' pos='19'>
      <comment>This bit is set whenever there is a framing error occured. A
      framing error occurs when the receiver does not detect a valid STOP bit
      in the received data. This bit is cleared when the UART_STATUS register
      is written with any value. </comment>
    </bits>

    <bits name='Rx Break Int' access='r' rst='0' pos='20'>
      <comment>This bit is set whenever the serial input is held in a logic 0
      state for longer than the length of x bits, where x is the value
      programmed Rx Break Length. A null word will be written in the Rx Fifo.
      This bit is cleared when the UART_STATUS register is written with any
      value. </comment>
    </bits>

    <bits name='DCTS' access='r' rst='0' pos='24'>
      <comment>This bit is set when the Uart_CTS line changed since the last
      time this register has been written. This bit is cleared when the
      UART_STATUS register is written with any value. </comment>
    </bits>

    <bits name='CTS' access='r' rst='1' pos='25'>
        <comment>current value of the Uart_CTS line. 
            <br/> '1' = Tx not allowed. 
            <br/> '0' = Tx allowed. 
      </comment>
    </bits>

    <bits name='DTR' access='r' rst='0' pos='28'>
      <comment>Current value of the DTR line.
      </comment>
    </bits>
    
    <bits name='Clk Enabled' access='r' rst='0' pos='31'>
      <comment>This bit is set when Uart Clk has been enabled and received by
      UART after Need Uart Clock becomes active. It serves to avoid enabling
      RTS too early.</comment>
    </bits>
  </reg>

  <reg name='rxtx_buffer' protect='--'>
    <bits name='Rx Data' access='r' rst='no' pos='7:0'>
      <comment>The UART_RECEIVE_BUFFER register is a read-only register that
      contains the data byte received on the serial input port. This register
      accesses the head of the receive FIFO. If the receive FIFO is full and
      this register is not read before the next data character arrives, then
      the data already in the FIFO will be preserved but any incoming data
      will be lost. An overflow error will also occur. </comment>
    </bits>

    <bits name='Tx Data' access='w' rst='no' pos='7:0'>
      <comment>The UART_TRANSMIT_HOLDING register is a write-only register
      that contains data to be transmitted on the serial output port. 16
      characters of data may be written to the UART_TRANSMIT_HOLDING register
      before the FIFO is full. Any attempt to write data when the FIFO is full
      results in the write data being lost. </comment>
    </bits>
  </reg>

  <reg name='irq_mask' protect='rw'>
    <bits name='Tx Modem Status' access='rw' rst='0' pos='0'>
      <comment>Clear to send signal change detected. </comment>
    </bits>

    <bits name='Rx Data Available' access='rw' rst='0' pos='1'>
      <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level). </comment>
    </bits>

    <bits name='Tx Data Needed' access='rw' rst='0' pos='2'>
      <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level). </comment>
    </bits>

    <bits name='Rx Timeout' access='rw' rst='0' pos='3'>
      <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time. </comment>
    </bits>

    <bits name='Rx Line Err' access='rw' rst='0' pos='4'>
      <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt. </comment>
    </bits>

    <bits name='Tx Dma Done' access='rw' rst='0' pos='5'>
      <comment>Pulse detected on Uart_Dma_Tx_Done_H signal. </comment>
    </bits>

    <bits name='Rx Dma Done' access='rw' rst='0' pos='6'>
      <comment>Pulse detected on Uart_Dma_Rx_Done_H signal. </comment>
    </bits>

    <bits name='Rx Dma Timeout' access='rw' rst='0' pos='7'>
        <comment>In DMA mode, there is at least 1 character that has been read 
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters
            in or out of the Rx Fifo during the last 4 character times.
        </comment>
    </bits>

    <bits name='DTR RISE' access='rw' rst='0' pos='8'>
      <comment>Rising edge detected on the UART_DTR signal. 
      </comment>
    </bits>

    <bits name='DTR FALL' access='rw' rst='0' pos='9'>
      <comment>Falling edge detected on the UART_DTR signal. 
      </comment>
    </bits>
  
  </reg>

  <reg name='irq_cause' protect='rw'>
    <bits name='Tx Modem Status' access='r' rst='0' pos='0'>
      <comment>Clear to send signal detected. Reset control: This bit is
      cleared when the UART_STATUS register is written with any value.
      </comment>
    </bits>

    <bits name='Rx Data Available' access='r' rst='0' pos='1'>
      <comment>Rx Fifo at or upper threshold level (current level &gt;= Rx
      Fifo trigger level). Reset control: Reading the UART_RECEIVE_BUFFER
      until the Fifo drops below the trigger level. </comment>
    </bits>

    <bits name='Tx Data Needed' access='r' rst='0' pos='2'>
      <comment>Tx Fifo at or below threshold level (current level &lt;= Tx
      Fifo trigger level). Reset control: Writing into UART_TRANSMIT_HOLDING
      register above threshold level. </comment>
    </bits>

    <bits name='Rx Timeout' access='r' rst='0' pos='3'>
      <comment>No characters in or out of the Rx Fifo during the last 4
      character times and there is at least 1 character in it during this
      time. Reset control: Reading from the UART_RECEIVE_BUFFER register.
      </comment>
    </bits>

    <bits name='Rx Line Err' access='r' rst='0' pos='4'>
      <comment>Tx Overflow, Rx Overflow, Parity Error, Framing Error or Break
      Interrupt. Reset control: This bit is cleared when the UART_STATUS
      register is written with any value. </comment>
    </bits>

    <bits name='Tx Dma Done' access='rc' rst='0' pos='5'>
      <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Tx_Done_H signal. Reset control: Write one in this register.
      </comment>
    </bits>

    <bits name='Rx Dma Done' access='rc' rst='0' pos='6'>
      <comment>This interrupt is generated when a pulse is detected on the
      Uart_Dma_Rx_Done_H signal. Reset control: Write one in this register.
      </comment>
    </bits>

    <bits name='Rx Dma Timeout' access='rc' rst='0' pos='7'>
        <comment>In DMA mode, there is at least 1 character that has been read 
            in or out the Rx Fifo. Then before received Rx DMA Done, No characters 
            in or out of the Rx Fifo during the last 4 character times.
        </comment>    
    </bits>

    <bits name='DTR RISE' access='rc' rst='0' pos='8'>
      <comment>This interrupt is generated when a rising edge is detected on the
      UART_DTR signal. Reset control: Write one in this register.
      </comment>
    </bits>

    <bits name='DTR FALL' access='rc' rst='0' pos='9'>
      <comment>This interrupt is generated when a falling edge is detected on the
      UART_DTR signal. Reset control: Write one in this register.
      </comment>
    </bits>
    
    <bits name='Tx Modem Status U' access='r' rst='0' pos='16'>
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits name='Rx Data Available U' access='r' rst='0' pos='17'>
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits name='Tx Data Needed U' access='r' rst='0' pos='18'>
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits name='Rx Timeout U' access='r' rst='0' pos='19'>
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits name='Rx Line Err U' access='r' rst='0' pos='20'>
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits name='Tx Dma Done U' access='r' rst='0' pos='21'>
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits name='Rx Dma Done U' access='r' rst='0' pos='22'>
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits name='Rx Dma Timeout U' access='r' rst='0' pos='23'>
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits name='DTR RISE U' access='r' rst='0' pos='24'>
      <comment>Same as previous, not masked. </comment>
    </bits>

    <bits name='DTR FALL U' access='r' rst='0' pos='25'>
      <comment>Same as previous, not masked. </comment>
    </bits>
    
  </reg>

  <reg name='triggers' protect='rw'>
    <bits name='Rx Trigger' access='rw' rst='0' pos='NB_RX_FIFO_BITS-1:0'>
      <comment>Defines the empty threshold level at which the Data Available
      Interrupt will be generated. <br/>The Data Available interrupt is
      generated when quantity of data in Rx Fifo &gt; Rx Trigger.</comment>
    </bits>

    <bits name='Tx Trigger' access='rw' rst='0' pos='NB_TX_FIFO_BITS-1+8:8'>
      <comment>Defines the empty threshold level at which the Data Needed
      Interrupt will be generated.<br/>The Data Needed Interrupt is generated
      when quantity of data in Tx Fifo &lt;= Tx Trigger.</comment>
    </bits>

    <bits name='AFC Level' access='rw' rst='0' pos='NB_RX_FIFO_BITS-1+16:16'>
      <comment>Controls the Rx Fifo level at which the Uart_RTS Auto Flow
      Control will be set inactive high (see UART Operation for more details
      on AFC).<br/>The Uart_RTS Auto Flow Control will be set inactive high
      when quantity of data in Rx Fifo &gt; AFC Level.</comment>
    </bits>
  </reg>

  <reg name='CMD_Set' protect='rw'>
    <bits name='RI' access='rs' rst='0' pos='0'>
        <comment>Ring indicator. When write '1', set RI bit. When read, get RI bit 
            value.
        </comment>
    </bits>
    
    <bits name='DCD' access='rs' rst='0' pos='1'>
        <comment>Data carrier detect. When write '1', set DCD bit. When read, get DCD
            bit value.
        </comment>
    </bits>
    
    <bits name='DSR' access='rs' rst='0' pos='2'>
        <comment>Data set ready. When write '1', set RI bit. When read, get RI bit 
            value.
        </comment>
    </bits>
    
    <bits name='Tx Break Control' access='rs' rst='0' pos='3'>
      <comment> Sends a break signal by holding the Uart_Tx line low until
      this bit is cleared. </comment>
    </bits>
    
    <bits name='Tx Finish n Wait' access='rs' rst='0' pos='4'>
      <comment>When this bit is set the Tx engine terminates to send the
      current byte and then it stops to send data.</comment>
    </bits>  

    <bits name='RTS' access='rs' rst='0' pos='5'>
        <comment>Controls the Uart_RTS output.
            <br/>0 = the Uart_RTS will be inactive high (Rx not allowed).
            <br/>1 = the Uart_RTS will be active low (Rx allowed).
        </comment>
    </bits>
    
    <bits name='Rx Fifo Reset' access='s' rst='0' pos='6'>
      <comment> Writing a 1 to this bit resets and flushes the Receive Fifo.
      This bit does not need to be cleared. </comment>
    </bits>
    
    <bits name='Tx Fifo Reset' access='s' rst='0' pos='7'>
      <comment> Writing a 1 to this bit resets and flushes the Transmit Fifo.
      This bit does not need to be cleared. </comment>
    </bits>
  </reg>

  <reg name='CMD_Clr' protect='rw'>
    <bits name='RI' access='rc' rst='0' pos='0'>
        <comment>Ring indicator. When write '1', clear RI bit. When read, get RI bit 
            value.
        </comment>
    </bits>

    <bits name='DCD' access='rc' rst='0' pos='1'>
        <comment>Data carrier detect. When write '1', clear DCD bit. When read, get DCD
            bit value.
        </comment>
    </bits>

    <bits name='DSR' access='rc' rst='0' pos='2'>
        <comment>Data set ready. When write '1', clear RI bit. When read, get RI bit 
            value.
        </comment>
    </bits>

    <bits name='Tx Break Control' access='rc' rst='0' pos='3'>
      <comment> Sends a break signal by holding the Uart_Tx line low until
      this bit is cleared. </comment>
    </bits>
    
    <bits name='Tx Finish n Wait' access='rc' rst='0' pos='4'>
      <comment>When this bit is set the Tx engine terminates to send the
      current byte and then it stops to send data.</comment>
    </bits>  

    <bits name='RTS' access='rc' rst='0' pos='5'>
        <comment>Controls the Uart_RTS output.
            <br/>0 = the Uart_RTS will be inactive high.
            <br/>1 = the Uart_RTS will be active low.
        </comment>
    </bits>
    
  </reg>
  
</module>


</archive>


<archive relative='vitac.xml'>


<include file='globals.xml'/>

<module name='vitac' category='Baseband'>
  <reg name='command' protect='rw'>
    <bits name='start_equ' access='rw' rst='0x0' pos='0'>
      <comment>Writing a '1' in this register triggers a Viterbi Equalization
      process. Ignored if any Viterbi process is already ongoing. Auto-reset.
      </comment>
    </bits>

    <bits name='start_dec' access='rw' rst='0x0' pos='1'>
      <comment>Writing a '1' in this register triggers a Viterbi Decoding
      process. Ignored if any Viterbi process is already ongoing. Auto-reset.
      </comment>
    </bits>

    <bits name='start_tb' access='rw' rst='0x0' pos='2'>
      <comment>Writing a '1' in this register triggers the TraceBack process.
      Ignored if any Viterbi process is already ongoing. Auto-reset.
      </comment>
    </bits>

    <bits name='int_mask' access='rw' rst='0x0' pos='3'>
      <comment>When this bit is set, it enables the generation of the
      VITAC_DONE_H interrupt. </comment>
    </bits>

    <bits name='punctured' access='rw' rst='0x0' pos='4'>
      <comment>Indicates whether a puncturing scheme has to be used during
      decoding. If this bit is set to '0', the code is assumed unpunctured and
      no puncturing matrix is needed. </comment>
    </bits>

    <bits name='nb_states' access='rw' rst='0x0' pos='6:5'>
      <comment>This field sets the number of states of the Trellis:
      <br/>"00": 16 states <br/>"01": 32 states <br/>"10": 64 states
      <br/>"11": reserved </comment>
    </bits>

    <bits name='bkwd_trellis' access='rw' rst='0x0' pos='7'>
      <comment>When this bit is set, the channel symbols are treated in the
      reverse order, i.e. CH_SYMB_ADDR represents the end of the buffer and
      the symbols are read out backward. </comment>
    </bits>

    <bits name='code_rate' access='rw' rst='0x0' pos='10:8'>
      <comment>This field sets the convolutional code rate for decoding:
      <br/>"010": 1/2 rate <br/>"011": 1/3 rate <br/>"100": 1/4 rate
      <br/>"101": 1/5 rate <br/>"110": 1/6 rate <br/>others: reserved
      </comment>
    </bits>

    <bits name='bm_shift_lev' access='rw' rst='0x0' pos='14:11'>
      <comment>This field sets the amount of shift right applied at the output
      of the equalizer BM calculation: <br/>"0000": BM = OUT[30:19]
      <br/>"0001": BM = OUT[29:18] <br/>... <br/>"1111": BM = OUT[15:4]
      </comment>
    </bits>

    <bits name='sv_shift_lev' access='rw' rst='0x0' pos='18:15'>
      <comment>This field sets the amount of shift right applied to the
      difference of the two metrics arriving at a node to create a Softvalue:
      <br/>"0000": SoftVal = DELTA[15:9] <br/>"0001": SoftVal =
      DELTA[14:8] <br/>... <br/>"1101": SoftVal = DELTA[2:0]&amp;"0000" <br/>others:
      reserved </comment>
    </bits>

    <bits name='nb_symbols' access='rw' rst='0x0' pos='28:20'>
      <comment>Number of symbols to be Equalized / Decoded. Auto decrement.
      </comment>
    </bits>
  </reg>

  <reg name='status' protect='r'>
    <bits name='equ_pending' access='r' rst='0x0' pos='0'>
      <comment>This bit is high when an equalization process is ongoing. It
      stays high when the module is stalled during operation. </comment>
    </bits>

    <bits name='dec pending' access='r' rst='0x0' pos='1'>
      <comment>This bit is high when an decoding process is ongoing. It stays
      high when the module is stalled during operation. </comment>
    </bits>

    <bits name='tb_pending' access='r' rst='0x0' pos='2'>
      <comment>This bit is high when an traceback process is ongoing. It stays
      high when the module is stalled during operation. </comment>
    </bits>

    <bits name='nb_rescales' access='r' rst='0x0' pos='7:4'>
      <comment>After a Viterbi process, this field reports the number of
      rescaling operations that have been performed along the trellis.
      <br/>This field is reset at every new Viterbi process. </comment>
    </bits>
  </reg>

  <reg name='ch_symb_addr' protect='rw'>
    <bits name='addr' access='rw' rst='0x0' pos='BB_SRAM_ADDR_WIDTH+1:2'>
      <comment>This is the start address of the channel symbols buffer in
      SRAM. For Equalization channel symbols are the sampled RF samples
      (2x12-bits packed complex values), and for Decoding channel symbols are
      a frame of softvalues (4x8-bits packed). <br/>This address must be
      4-bytes aligned, bits[1:0] will be ignored. </comment>
    </bits>
  </reg>

  <reg name='exp_symb_addr' protect='rw'>
    <bits name='addr' access='rw' rst='0x0' pos='BB_SRAM_ADDR_WIDTH+1:2'>
      <comment>For Equalization, this is the base address of the partial sum
      terms buffer in SRAM. (2x12-bits packed complex values) <br/>For
      Decoding, this is the base address of the puncturing matrix. <br/>This
      address must be 4-bytes aligned, bits[1:0] will be ignored. </comment>
    </bits>
  </reg>

  <reg name='pm_base_addr' protect='rw'>
    <bits name='addr' access='rw' rst='0x0' pos='BB_SRAM_ADDR_WIDTH+1:2'>
      <comment>This is the base address in SRAM of the Path Metrics buffer.
      The VITAC will read and update PMs according to the scheme given in
      1.2.1.2. (2x16-bits packed values). <br/>This address must be 4-bytes
      aligned, bits[1:0] will be ignored. </comment>
    </bits>
  </reg>

  <reg name='out_base_addr' protect='rw'>
    <bits name='addr' access='rw' rst='0x0' pos='BB_SRAM_ADDR_WIDTH+1:2'>
      <comment>This is the start address of the output buffer in SRAM. When in
      Equalizer mode, the VITAC will output the calculated Softvalues
      according to the scheme given in 1.2.1.7. When in Decoder mode, the
      VITAC will output the trace words according to the scheme given in
      1.2.2.4. <br/>This address must be 4-bytes aligned, bits[1:0] will be
      ignored. </comment>
    </bits>
  </reg>

  <reg name='H0_param' protect='rw'>
    <bits name='H0_I_part' access='rw' rst='0x0' pos='BB_SYMBOL_SIZE-1:0'>
      <comment>Real part of the h0 parameter of the estimated channel
      response. </comment>
    </bits>

    <bits name='H0_Q_part' access='rw' rst='0x0' pos='BB_SYMBOL_SIZE+15:16'>
      <comment>Imaginary part of the h0 parameter of the estimated channel
      response. </comment>
    </bits>
  </reg>

  <reg name='HL_param' protect='rw'>
    <bits name='HL_I_part' access='rw' rst='0x0' pos='BB_SYMBOL_SIZE-1:0'>
      <comment>Real part of the hL parameter of the estimated channel
      response. </comment>
    </bits>

    <bits name='HL_Q_part' access='rw' rst='0x0' pos='BB_SYMBOL_SIZE+15:16'>
      <comment>Imaginary part of the hL parameter of the estimated channel
      response. </comment>
    </bits>
  </reg>

  <reg name='rescale' protect='rw'>
    <bits name='threshold' access='rw' rst='0x0' pos='15:0'>
      <comment>This field indicates the threshold value to be reach by every
      PMs for triggering a rescale operation. The rescale operation consist in
      subtracting the threshold value to every PMs to avoid overflow during PM
      update. </comment>
    </bits>
  </reg>

  <reg name='res_poly' protect='rw' count='3'>
    <comment>This register bank stores the less significant bit of the output
    from the coder for a particular code (see 1.2.2.1). The kth butterfly uses
    the bit k of this register. </comment>

    <bits name='res_poly' access='rw' rst='0x0' pos='31:0'>
      <comment>This register stores the less significant bit of the output
      from the coder for a particular code (see 1.2.2.1). The kth butterfly
      uses the bit k of this register. </comment>
    </bits>
  </reg>

  <reg name='int_status' protect='r'>
    <bits name='it_cause' access='r' rst='0x0' pos='0'>
      <comment>This bit is set when the VITAC module finishes an ongoing
      operation. It can be masked by setting VITAC_CMD(IT_MASK) to '1'.
      <br/>Resetting this bit is done by writing in IT_CLEAR register.
      <br/>IT_CAUSE is the image of the VITAC_DONE_H interrupt line to the
      CPU. </comment>
    </bits>

    <bits name='it_status' access='r' rst='0x0' pos='16'>
      <comment>This bit is the unmasked version of the IT_CAUSE bit.
      </comment>
    </bits>
  </reg>

  <reg name='int_clear' protect='w'>
    <bits name='it_clear' access='w' rst='0x0' pos='0'>
      <comment>Setting this bit to '1' resets the VITAC interrupt. </comment>
    </bits>
  </reg>
</module>

</archive>


<archive relative='xcor.xml'>


<include file='globals.xml'/>

<module name='xcor' category='Baseband'>
  <var name='XCOR_SYMBOL_SIZE' value='VITAC_MULT_SIZE'/>

  <var name='XCOR_SADDER_SIZE' value='XCOR_SYMBOL_SIZE+1 +6'/>

  <reg name='command' protect='rw'>
    <bits name='biterr_en' access='rw' rst='0x0' pos='0'>
      <comment>Enables the Biterror calculation mode. Auto-reset. </comment>
    </bits>

    <bits name='dco1p_en' access='rw' rst='0x0' pos='1'>
      <comment>Enables the DC Offset Correction (1st pass) mode. Auto-reset.
      </comment>
    </bits>

    <bits name='dco2p_en' access='rw' rst='0x0' pos='2'>
      <comment>Enables the DC Offset Correction (2nd pass) mode. Auto-reset.
      </comment>
    </bits>

    <bits name='dco3p_en' access='rw' rst='0x0' pos='3'>
      <comment>Enables the DC Offset Correction (3rd pass) mode. Auto-reset.
      </comment>
    </bits>

    <bits name='tscxc_en' access='rw' rst='0x0' pos='4'>
      <comment>Enables the Training Sequence Cross-Correlation mode.
      Auto-reset. </comment>
    </bits>

    <bits name='srec_en' access='rw' rst='0x0' pos='5'>
      <comment>Enables the Symbol Re-Construction mode. Auto-reset. </comment>
    </bits>

    <bits name='bext_en' access='rw' rst='0x0' pos='6'>
      <comment>Enables the Bit Extraction mode. Auto-reset. </comment>
    </bits>

    <bits name='sproc_en' access='rw' rst='0x0' pos='7'>
      <comment>Enables the Sum Of PROduCt mode. Auto-reset. </comment>
    </bits>

    <bits name='chest_en' access='rw' rst='0x0' pos='8'>
      <comment>Enables the Channel Estimation mode. Auto-reset. </comment>
    </bits>

    <bits name='fchxc_en' access='rw' rst='0x0' pos='9'>
      <comment>Enables the FCH Xcorrelation mode. Auto-reset. </comment>
    </bits>

    <bits name='it_mask' access='rw' rst='0x0' pos='10'>
      <comment>Mask of the end of processing interrupt.</comment>
    </bits>

    <bits name='pack_IQ' access='rw' rst='0x0' pos='12'>
      <comment>Data path setting. Pack I and Q on a single 32-bits word.
      </comment>
    </bits>

    <bits name='derotation_en' access='rw' rst='0x0' pos='13'>
      <comment>Data path setting. Enables derotation for DCOC 3pass.
      </comment>
    </bits>

    <bits name='nb_iloop' access='rw' rst='0x0' pos='23:16'>
      <comment>Control setting. Number of internal loop iteration. </comment>
    </bits>

    <bits name='nb_symb' access='rw' rst='0x0' pos='31:24'>
      <comment>Control setting. Number of symbols to process. </comment>
    </bits>
  </reg>

  <reg name='status' protect='rw'>
    <bits name='op_pending' access='r' rst='0x0' pos='0'>
      <comment>This bit is high when an operation is ongoing.</comment>
    </bits>
    <bits name='it_cause' access='r' rst='0x0' pos='16'>
      <comment>Masked version of it_status that goes to Interrupt controller.</comment>
    </bits>
    <bits name='it_status' access='rw' rst='0x0' pos='31'>
        <comment>This bit is set high when an operation is finished. It must be reset before lauching a new operation if Xcor interrupt is enabled.</comment>
    </bits>
  </reg>

  <reg name='hv0' protect='rw'>
    <comment>Multipurpose Data Register. <br/> Store Training Sequence in
    TSXC mode. <br/> Store SUM in DCOC 3rd pass mode. <br/> Store bit
    sequence in SREC mode. <br/> Store SUM in SPROC mode. <br/> Store I SUM
    in CHEST mode. <br/> Store R(k-1) in FCHXC mode. </comment>

    <bits name='hv0' access='rw' rst='0x0' pos='31:0'>
      <comment>Multipurpose. </comment>
    </bits>
  </reg>

  <reg name='hv1' protect='rw'>
    <comment>Multipurpose Data Register. <br/> Store Training Sequence in
    TSXC mode. <br/> Store bit sequence in SREC mode. <br/> Store Q SUM in
    CHEST mode. </comment>

    <bits name='hv1' access='rw' rst='0x0' pos='31:0'>
      <comment>Multipurpose. </comment>
    </bits>
  </reg>

  <reg name='data' protect='rw' count='6'>
    <comment>Multipurpose Data Registers. <br/>D0 stores
    symbols/softvalues/channel taps depending on mode. Not readable. <br/>D1
    stores decoded bits/IQ threshols/IQ Offsets/A terms depending on mode. Not
    readable. <br/>D2 (aka A1) serves as Rd address (decoded bits, A or B
    terms) / Wr address register (I or packed IQ results, Symbols) / event
    counter depending on mode. <br/>D3 (aka A2) serves as Wr address (Q
    results) / event counter depending on mode. <br/>D4 stores results from
    VITAC / extracted HardValues depending on mode. Not readable.<br/>D5 (aka
    A3) serves as Wr address (CQ results) Not readable. </comment>

    <bits name='data' access='rw' rst='0x0' pos='31:0'>
      <comment>Multipurpose. </comment>
    </bits>
  </reg>

  <reg name='accuI' protect='r'>
    <bits name='accuI' access='r' rst='0x0' pos='XCOR_SADDER_SIZE-1:0'>
      <comment>I part accumulator register.</comment>
    </bits>
  </reg>

  <reg name='accuQ' protect='r'>
    <bits name='accuQ' access='r' rst='0x0' pos='XCOR_SADDER_SIZE-1:0'>
      <comment>I part accumulator register.</comment>
    </bits>
  </reg>

  <reg name='addr0' protect='rw'>
    <comment>Address 0 Register. <br/>Stores Rd address for symbols /
    SoftValues / A terms depending on mode. <br/> Auto
    increment/decrement/reset. </comment>

    <bits name='addr0' access='rw' rst='0x0' pos='BB_SRAM_ADDR_WIDTH+1:2'>
      <comment>32-bit word address (bits 0 and 1 disregarded). </comment>
    </bits>
  </reg>
</module>

</archive>
<archive relative='cp0.xml' asm='no'>

<cjoker>

/* Cause register exception codes */

#define ExcCode(x)      ((x)&lt;&lt;2)

/* Hardware exception codes */
#define ExcCode_INT     ExcCode(0)      /* interrupt */
#define ExcCode_MOD     ExcCode(1)      /* TLB modification */
#define ExcCode_TLBL    ExcCode(2)      /* TLB miss, load or fetch */
#define ExcCode_TLBS    ExcCode(3)      /* TLB miss, store */
#define ExcCode_AdEL    ExcCode(4)      /* Read Address Error */
#define ExcCode_AdES    ExcCode(5)      /* Write Address Error */
#define ExcCode_IBE     ExcCode(6)      /* Instruction Bus Error */
#define ExcCode_DBE     ExcCode(7)      /* Data Bus Error */
#define ExcCode_SYSCALL ExcCode(8)      /* SYSCALL */
#define ExcCode_BREAK   ExcCode(9)      /* BREAKpoint */
#define ExcCode_RI      ExcCode(10)     /* Illegal Instruction */
#define ExcCode_CpU     ExcCode(11)     /* CoProcessor Unusable */
#define ExcCode_Ovf     ExcCode(12)     /* OVerflow */

/*
 * cp0 registers
 */
#define Index           $0
#define Random          $1
#define EntryLo         $2
#define Context         $4
#define BadVAddr        $8
#define EntryHi         $10
#define Status          $12
#define Cause           $13
#define EPC             $14
#define PRId            $15


/*
 * Mask for Index Register
 */
#define Index_P         0x80000000      /* Probe Failure bit */
#define Index_Index     0x00003f00      /* Index field */

/*
 * Random register 
 */
#define Random_Index    0x00003f00      /* Random field */

/*
 * Entry Low
 */
#define EntryLo_PFN     0xfffff000      /* page frame number field */
#define EntryLo_N       0x00000800      /* non cachable */
#define EntryLo_D       0x00000400      /* dirty */
#define EntryLo_V       0x00000200      /* valid bit */
#define EntryLo_G       0x00000100      /* global bit */

/*
 * Context register 
 */
#define Context_PTEBase 0xffe00000      /* base for page table entry */
#define Context_BadVPN  0x001ffffc      /* failing virtual page number */

/*
 * Entry High Register
 */
#define EntryHi_VPN     0xfffff000      /* virtual page number field */
#define EntryHi_PID     0x00000fc0      /* process ID field */

/*
 * PRId Register
 */
#define PRID_Imp        0x0000ff00      /* implementation ID */
#define PRID_Rev        0x000000ff      /* revision ID */

/*
 * Status register
 */
#define Status_CUMASK   0xf0000000      /* coproc usable bits */
#define Status_RE       0x02000000      /* Bootstrap exception vector */
#define Status_BEV      0x00400000      /* Bootstrap exception vector */
#define Status_TS       0x200000        /* TLB Shutdown bit */
#define Status_IntMASK  0xff00          /* Interrupt mask */
#define Status_KUo      0x0020          /* old kernel/user, 0 =&gt; k, 1 =&gt; u */
#define Status_IEo      0x0010          /* old interrupt enable, 1 =&gt; ena */
#define Status_KUp      0x0008          /* prev kernel/user, 0 =&gt; k, 1 =&gt; u */
#define Status_IEp      0x0004          /* prev interrupt enable, 1 =&gt; ena */
#define Status_KUc      0x0002          /* cur kernel/user, 0 =&gt; k, 1 =&gt; u */
#define Status_IEc      0x0001          /* cur interrupt enable, 1 =&gt; enable*/

/*
 * Cause Register
 */
#define Cause_BD        0x80000000      /* Branch delay slot */
#define Cause_CE        0x30000000      /* coprocessor error */
#define Cause_IP        0xff00          /* Pending interrupt mask */
#define Cause_SIP       0x0300          /* Pending software interrupt mask */
#define Cause_HIP       0xfc00          /* Pending hardware interrupt mask */
#define Cause_ExcCode   0x003C          /* Exception code bits */

#define DRAM_HANDLER    0x80c00200      /* address of exception handler */
#define EPROM_HANDLER   0xa0e00180      /* address of exception handler BEV */

</cjoker>
</archive>
<archive relative='regdef.xml' asm='no'>

<cjoker>
/* Set or not mips16 */
#ifdef CT_ASM_MIPS16
#define SET_P_MIPS16 .set mips16
#else
#define SET_P_MIPS16 .set nomips16
#endif 

#define zero    $0
#define AT      $at
#define v0      $2
#define v1      $3
#define a0      $4
#define a1      $5
#define a2      $6
#define a3      $7
#define t0      $8
#define t1      $9
#define t2      $10
#define t3      $11
#define t4      $12
#define t5      $13
#define t6      $14
#define t7      $15
#define s0      $16
#define s1      $17
#define s2      $18
#define s3      $19
#define s4      $20
#define s5      $21
#define s6      $22
#define s7      $23
#define t8      $24
#define t9      $25
#define k0      $26
#define k1      $27
#define gp      $28
#define sp      $29
#define fp      $30
#define ra      $31

#define r0      $0
#define r1      $1
#define r2      $2
#define r3      $3
#define r4      $4
#define r5      $5
#define r6      $6
#define r7      $7
#define r8      $8
#define r9      $9
#define r10     $10
#define r11     $11
#define r12     $12
#define r13     $13
#define r14     $14
#define r15     $15
#define r16     $16
#define r17     $17
#define r18     $18
#define r19     $19
#define r20     $20
#define r21     $21
#define r22     $22
#define r23     $23
#define r24     $24
#define r25     $25
#define r26     $26
#define r27     $27
#define r28     $28
#define r29     $29
#define r30     $30
#define r31     $31

#define fp0     $f0
#define fp1     $f1
#define fp2     $f2
#define fp3     $f3
#define fp4     $f4
#define fp5     $f5
#define fp6     $f6
#define fp7     $f7
#define fp8     $f8
#define fp9     $f9
#define fp10    $f10
#define fp11    $f11
#define fp12    $f12
#define fp13    $f13
#define fp14    $f14
#define fp15    $f15
#define fp16    $f16
#define fp17    $f17
#define fp18    $f18
#define fp19    $f19
#define fp20    $f20
#define fp21    $f21
#define fp22    $f22
#define fp23    $f23
#define fp24    $f24
#define fp25    $f25
#define fp26    $f26
#define fp27    $f27
#define fp28    $f28
#define fp29    $f29
#define fp30    $f30
#define fp31    $f31

#define fpucntl $31

</cjoker>
</archive>
<archive relative='xcpu_cache.xml'>

<module name='xcpu_cache' category='Debug'>

    <struct name='Line' count='exp2(8)'>
        <reg name='Data' protect='rw' count='4'>
        <comment>The XCpu cache is accessible only when it is disabled or the cpu is stalled.
            <br/>The bits "11:4" of the address select the line.
            <br/>If the Tag at the corresponding line is valid, the bits "24:12" of the tag are the corresponding address bits.
            <br/>The bits "3:0" of the address select the Data in the line.
        </comment>
            <bits name='data' access='rw' pos='31:0'>
            </bits>
        </reg>
    </struct>
</module>
</archive>
<archive relative='xcpu_tag.xml'>

<module name='xcpu_tag' category='Debug'>

    <reg name='Line' protect='rw' count='exp2(8)'>
        <comment>The XCpu tags are accessible only when the corresponding cache is disabled or the cpu is stalled.
            <br/>The bits "11:4" of the address select the line
        </comment>
        <bits name='Tag' access='rw' pos='24:12'>
            <comment>The Tag represents the bits "24:12" of the address present in the corresponding cache Line.
            </comment>
            <options><default/><shift/><mask/></options>
        </bits>
        <bits name='Valid' access='rw' pos='29'>
            <comment>When 1 the Tag is valid
            </comment>
            <options><default/><shift/><mask/></options>
        </bits>
    </reg>
</module>
</archive>
<archive relative='xcpu.xml'>

<module name='xcpu' category='Debug'>
    <hole size='32'/>
    <reg name='rf0_addr' protect='r'>
        <bits name='rf0_addr' access='r' rst='0' pos='31:0'>
            <comment>program counter for the RF stage.
            </comment>
        </bits>
    </reg>
    <hole size='3104'/>
    <reg name='cp0_adr_BadVAddr' protect='r'>
        <bits name='cp0_adr_BadVAddr' access='r' rst='0' pos='31:0'/>
    </reg>
    <reg name='cp0_Cause' protect='r'>
        <bits name='cp0_Cause_ExcCode' access='r' rst='0' pos='5:2'>
            <options>
                <option name='Int' value='0'><comment>Interrupt</comment></option>
                <option name='Mod' value='1'><comment>TLB modification exception</comment></option>
                <option name='TLBL' value='2'><comment>TLB exception (load or instruction fetch)</comment></option>
                <option name='TLBS' value='3'><comment>TLB exception (store)</comment></option>
                <option name='AdEL' value='4'><comment>Address error exception (load or instruction fetch)</comment></option>
                <option name='AdES' value='5'><comment>Address error exception (store)</comment></option>
                <option name='IBE' value='6'><comment>Bus error exception (instruction fetch)</comment></option>
                <option name='DBE' value='7'><comment>Bus error exception (data reference: load or store)</comment></option>
                <option name='Sys' value='8'><comment>Syscall exception</comment></option>
                <option name='Pb' value='9'><comment>Breakpoint exception</comment></option>
                <option name='Ri' value='10'><comment>Reserved instruction exception</comment></option>
                <option name='CpU' value='11'><comment>Coprocessor Unusable exception</comment></option>
                <option name='Ov' value='12'><comment>Arithmetic Overflow exception</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name='cp0_Cause_IP_soft' access='r' rst='0' pos='9:8'>
            <comment>Theses interrupt lines are software interrupts (the cpu can write in the CP0 bits to trigger and clear them).
            </comment>
            <options>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name='cp0_Cause_IP_ext' access='r' rst='0' pos='15:10'>
            <comment>Theses interrupt lines maps to the hardware interrupt lines from the corresponding irq module.
            </comment>
            <options>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bitgroup name='cp0_Cause_IP'>
            <entry ref='cp0_Cause_IP_soft'/>
            <entry ref='cp0_Cause_IP_ext'/>
        </bitgroup>
        <bits name='cp0_Cause_CE' access='r' rst='0' pos='29:28'>
            <comment>The Coprocessor Error (CE) field indicate the coprocessor unit number referenced when a Coprocessor Unusable exception is taken.
            </comment>
            <options>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name='cp0_Cause_BD' access='r' rst='0' pos='31'>
            <comment>The Branch Delay (BD) bit indicate whether the last exception was taken while executing in a branch delay slot.
            </comment>
            <options>
                <option name='Normal' value='0'/>
                <option name='Delay_slot' value='1'/>
                <mask/>
                <shift/>
            </options>
        </bits>
    </reg>
    <reg name='cp0_Status' protect='r'>
        <bits name='cp0_Status_IEc' access='r' rst='0' pos='0'>
            <comment>Current Interrupt Enable
            </comment>
            <options>
                <option name='disable' value='0'/>
                <option name='enable' value='1'/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name='cp0_Status_KUc' access='r' rst='0' pos='1'>
            <comment>Current Kernel/User mode
            </comment>
            <options>
                <option name='kernel' value='0'/>
                <option name='user' value='1'/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name='cp0_Status_IEp' access='r' rst='0' pos='2'>
            <comment>Previous Interrupt Enable
            </comment>
            <options>
                <option name='disable' value='0'/>
                <option name='enable' value='1'/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name='cp0_Status_KUp' access='r' rst='0' pos='3'>
            <comment>Previous Kernel/User mode
            </comment>
            <options>
                <option name='kernel' value='0'/>
                <option name='user' value='1'/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name='cp0_Status_IEo' access='r' rst='0' pos='4'>
            <comment>Old Interrupt Enable
            </comment>
            <options>
                <option name='disable' value='0'/>
                <option name='enable' value='1'/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name='cp0_Status_KUo' access='r' rst='0' pos='5'>
            <comment>Old Kernel/User mode
            </comment>
            <options>
                <option name='kernel' value='0'/>
                <option name='user' value='1'/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name='cp0_Status_KUi' access='r' rst='0' pos='6'>
        </bits>
        <bits name='cp0_Status_IntMask' access='r' rst='0' pos='15:8'>
            <comment>Interrupt Mask control the enabling of each of the external and software interrupts. (See Cause for more information on interruptions).
            </comment>
        </bits>
        <bits name='cp0_Streaming_Disable' access='r' rst='0' pos='16'>
            <comment>This bit control handling of non-cached instruction fetch requests. By default, the system block reads multiple words of data from the AMBA bus in burst transactions and saves them in the Streaming Buffer. Non cached instruction fetch requests get their data directly from the Streaming Buffer.
            When "1" the cpu does not use the streaming buffer and does not ask for burst requests on the AMBA bus for non-cache instruction fetch requests.
            </comment>
        </bits>
        <bits name='cp0_Status_CM' access='r' rst='0' pos='19'>
            <comment>Cache Miss
            <br/>Signals that the most recent access to the cachable space resulted in cache miss.
            </comment>
        </bits>
        <bits name='cp0_Status_TS' access='r' rst='0' pos='21'>
            <comment>Signals that 2 entries in the TLB matched the virtual address. This is an error condition but the processor takes no action other than signalling it via this bit in the Status Register.
            </comment>
        </bits>
        <bits name='cp0_Status_BEV' access='r' rst='1' pos='22'>
            <comment>Select the location of the exception vectors in ROM or in DRAM.
            </comment>
        </bits>
        <bits name='cp0_Status_RE' access='r' rst='0' pos='25'>
            <comment>Reverse Endian in User mode. <font color='red'>(probably unused in xcpu)</font></comment>
        </bits>
        <bits name='cp0_Status_CU_0' cut='1' access='r' rst='0' pos='28'>
            <comment>Control the Usability of the corresponding Coprocessor Unit. (CP0 is always usable when in Kernel mode, regardless of the setting of the CU_0 bit.
            </comment>
        </bits>
        <bits name='cp0_Status_CU_123' cut='1' cutprefix='cp0_Status_CU' cutstart='1' access='r' rst='0' pos='31:29'>
            <comment>Control the Usability of the corresponding Coprocessor Unit.
            </comment>
        </bits>
        <bitgroup name='cp0_Status_CU'>
            <entry ref='cp0_Status_CU_0'/>
            <entry ref='cp0_Status_CU_123'/>
        </bitgroup>
    </reg>
    <reg name='cp0_EPC' protect='r'>
        <bits name='cp0_EPC' access='r' rst='0' pos='31:0'>
            <comment>Exception Program Counter. Saves the value of the program counter for the instruction
                that caused the exception.
            </comment>
        </bits>
    </reg>
    <hole size='160'/>
    <reg name='cp0_BadVAddr' protect='r'>
        <bits name='cp0_BadVAddr' access='r' rst='0' pos='31:0'>
            <comment>Bad virtual address. Saves the address that caused the address exception.
            </comment>
        </bits>
    </reg>
    <hole size='608'/>
    <reg name='rf0_data' protect='r'>
        <bits name='rf0_data' access='r' rst='0' pos='31:0'/>
    </reg>
    <hole size='160'/>
    <reg name='dc0_result' protect='r'>
        <bits name='dc0_result' access='r' rst='0' pos='31:0'/>
    </reg>
    <hole size='2848'/>
    
    <hole size='32'/> 

    <reg name='Regfile_AT' protect='r'>
        <bits name='AT' access='r' rst='no' pos='31:0'>
            <comment>assembler temporary register;
                their values are not preserved across procedure calls.
            </comment>  
        </bits>    
    </reg>
    <reg name='Regfile_V0' protect='r'>
        <bits name='V0' access='r' rst='no' pos='31:0'>
            <comment>Used for expression evaluations and for hold integer function results.
            <br/> Also used to pass the statuc link when calling nested procedure.
            </comment>
        </bits>    
    </reg>
    <reg name='Regfile_V1' protect='r'>
        <bits name='V1' access='r' rst='no' pos='31:0'>
            <comment>Used for expression evaluations and for hold integer function results.
            <br/> Also used to pass the statuc link when calling nested procedure.
            </comment>      
        </bits>    
    </reg>
    <reg name='Regfile_A0' protect='r'>
        <bits name='A0' access='r' rst='no' pos='31:0'>
            <comment>register A0 to A3 is used to pass the first 4 words of integer type actual arguments;
                their values are not preserved across procedure calls.
            </comment>      
        </bits>              
    </reg>
    <reg name='Regfile_A1' protect='r'>
        <bits name='A1' access='r' rst='no' pos='31:0'>
            <comment>register A0 to A3 is used to pass the first 4 words of integer type actual arguments;
                their values are not preserved across procedure calls.
            </comment>             
        </bits>              
    </reg>
    <reg name='Regfile_A2' protect='r'>
        <bits name='A2' access='r' rst='no' pos='31:0'>
            <comment>register A0 to A3 is used to pass the first 4 words of integer type actual arguments;
                their values are not preserved across procedure calls.
            </comment> 
        </bits>              
    </reg>
    <reg name='Regfile_A3' protect='r'>
        <bits name='A3' access='r' rst='no' pos='31:0'>
            <comment>register A0 to A3 is used to pass the first 4 words of integer type actual arguments;
                their values are not preserved across procedure calls.
            </comment>         
        </bits>              
    </reg>
    <reg name='Regfile_T0' protect='r'>
        <bits name='T0' access='r' rst='no' pos='31:0'>
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>             
        </bits>              
    </reg>
    <reg name='Regfile_T1' protect='r'>
        <bits name='T1' access='r' rst='no' pos='31:0'>
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>                   
        </bits>              
    </reg>
    <reg name='Regfile_T2' protect='r'>
        <bits name='T2' access='r' rst='no' pos='31:0'>
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>                   
        </bits>              
    </reg>
    <reg name='Regfile_T3' protect='r'>
        <bits name='T3' access='r' rst='no' pos='31:0'>
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>                   
        </bits>              
    </reg>
    <reg name='Regfile_T4' protect='r'>
        <bits name='T4' access='r' rst='no' pos='31:0'>
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>                   
        </bits>              
    </reg>
    <reg name='Regfile_T5' protect='r'>
        <bits name='T5' access='r' rst='no' pos='31:0'>
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>                   
        </bits>              
    </reg>
    <reg name='Regfile_T6' protect='r'>
        <bits name='T6' access='r' rst='no' pos='31:0'>
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>                   
        </bits>              
    </reg>
    <reg name='Regfile_T7' protect='r'>
        <bits name='T7' access='r' rst='no' pos='31:0'>
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>                   
        </bits>              
    </reg>
    <reg name='Regfile_S0' protect='r'>
        <bits name='S0' access='r' rst='no' pos='31:0'>
            <comment>saved register;
                their values must preserved across procedure calls.
            </comment>                   
        </bits>              
    </reg>
    <reg name='Regfile_S1' protect='r'>
        <bits name='S1' access='r' rst='no' pos='31:0'>
            <comment>saved register;
                their values must preserved across procedure calls.
            </comment>              
        </bits>              
    </reg>
    <reg name='Regfile_S2' protect='r'>
        <bits name='S2' access='r' rst='no' pos='31:0'>
            <comment>saved register;
                their values must preserved across procedure calls.
            </comment>              
        </bits>              
    </reg>
    <reg name='Regfile_S3' protect='r'>
        <bits name='S3' access='r' rst='no' pos='31:0'>
            <comment>saved register;
                their values must preserved across procedure calls.
            </comment>              
        </bits>              
    </reg>
    <reg name='Regfile_S4' protect='r'>
        <bits name='S4' access='r' rst='no' pos='31:0'>
            <comment>saved register;
                their values must preserved across procedure calls.
            </comment>              
        </bits>              
    </reg>
    <reg name='Regfile_S5' protect='r'>
        <bits name='S5' access='r' rst='no' pos='31:0'>
            <comment>saved register;
                their values must preserved across procedure calls.
            </comment>              
        </bits>              
    </reg>
    <reg name='Regfile_S6' protect='r'>
        <bits name='S6' access='r' rst='no' pos='31:0'>
            <comment>saved register;
                their values must preserved across procedure calls.
            </comment>              
        </bits>              
    </reg>
    <reg name='Regfile_S7' protect='r'>
        <bits name='S7' access='r' rst='no' pos='31:0'>
            <comment>saved register;
                their values must preserved across procedure calls.
            </comment>              
        </bits>              
    </reg>
    <reg name='Regfile_T8' protect='r'>
        <bits name='T8' access='r' rst='no' pos='31:0'>
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>             
        </bits>              
    </reg>
    <reg name='Regfile_T9' protect='r'>
        <bits name='T9' access='r' rst='no' pos='31:0'>
            <comment>temporary register, used for expression evaluations;
                their values are not preserved across procedure calls.
            </comment>             
        </bits>              
    </reg>
    <reg name='Regfile_K0' protect='r'>
        <bits name='K0' access='r' rst='no' pos='31:0'>
            <comment>reserved for the operating system kernal.
            </comment>             
        </bits>              
    </reg>
    <reg name='Regfile_K1' protect='r'>
        <bits name='K1' access='r' rst='no' pos='31:0'>
            <comment>reserved for the operating system kernal.
            </comment>         
        </bits>              
    </reg>
    <reg name='Regfile_GP' protect='r'>
        <bits name='GP' access='r' rst='no' pos='31:0'>
            <comment>contains the global pointer.
            </comment>         
        </bits>              
    </reg>
    <reg name='Regfile_SP' protect='r'>
        <bits name='SP' access='r' rst='no' pos='31:0'>
            <comment>contains the stack pointer.
            </comment>             
        </bits>              
    </reg>
    <reg name='Regfile_S8' protect='r'>
        <bits name='S8' access='r' rst='no' pos='31:0'>
            <comment>a saved register (like s0-s7).
            </comment>             
        </bits>              
    </reg>
    <reg name='Regfile_RA' protect='r'>
        <bits name='RA' access='r' rst='no' pos='31:0'>
            <comment>contains the return address; used for expression evaluation.
            </comment>             
        </bits>              
    </reg>
    <hole size='512'/>
    <reg name='Debug_Page_Address' protect='rw'>
        <bits name='Debug_Page_Address' access='rw' rst='0' pos='3:0'>
            <comment>Debug Page Address Register Is a 4 bit register used for extending the address of
the debug to enable full access to the cache RAMs.
                <br/>bit 3 is used when accessing the TAGs to select between Instruction TAG (0) or Data TAG (1).
            </comment>
            <options>
                <option name='ITag' value='0'/>
                <option name='DTag' value='8'/>
                <default/><shift/><mask/>
            </options>
        </bits>
    </reg>
    <reg name='Cache_Control' protect='rw'>
        <bits name='Dcache_Inhibit' access='rw' rst='no' pos='0'>
            <comment>when "ON" all accesses for data are treated as non cache. Data is fetched directly from main memory. The content of the Data Cache is not altered.
            </comment>
        </bits>
        <bits name='Icache_Inhibit' access='rw' rst='no' pos='1'>
            <comment>when "ON" all accesses for instructions are treated as non cache. Data is fetched directly from main memory. The content of the cache is not altered.
            </comment>
        </bits>
        <bits name='Cache Hit Disable' access='rw' rst='no' pos='2'>
            <comment>when "ON" all accesses to either Instruction or data caches result in a cache miss and a cache refill. This is a quick way to initialize the caches.
            </comment>
        </bits>
    </reg>
</module>
</archive>

<archive relative='keypad.xml'>

<module name='keypad' category='Periph'>
  <var name='KEY_NB' value='36'>
    <comment> Number of key in the keypad
    </comment>
  </var>
  <var name='LOW_KEY_NB' value='30'>
    <comment> Number of key in the low data register 
    </comment>
  </var>
  <var name='HIGH_KEY_NB' value='6'>
    <comment> Number of key in the high data register
    </comment>
  </var>

  <reg name='KP_DATA_L' protect='r'>
    <bits name='KP_DATA_L' access='r' rst='0' pos='29:0'>
      <comment>For keys in column Idx_KeyOut(from 0 to 4) and in line Idx_KeyIn(from 0 to 5), the pressing status are stored in KP_DATA_L(Idx_KeyOut*6+Idx_KeyIn) :<br/>0 = Released<br/>1 = Pressed
      </comment>
      <options>
        <mask/>
        <shift/>
      </options>  
    </bits>

    <bits name='KP_ON' access='r' rst='0' pos='31'>
      <comment>Indicate Key ON pressing status :<br/>0 = Release<br/>1 = Pressed
      </comment>
      <options><default/><mask/><shift/></options>
    </bits>
  </reg>

  <reg name='KP_DATA_H' protect='r'>
    <bits name='KP_DATA_H' access='r' rst='0' pos='5:0'>
      <comment>For keys in column Idx_KeyOut=5 and line Idx_KeyIn(from 0 to 5), the pressing status are stored in KP_DATA_H(Idx_KeyIn):<br/>0 = Released<br/>1 = Pressed
      </comment>
      <options>
        <mask/>
        <shift/>
      </options>  
    </bits>

  </reg>

  <reg name='KP_CTRL' protect='rw'>
    <bits name='KP_En' access='rw' rst='0' pos='0'>
        <comment>This bit enables key detection. If this bit is '0', the key detection function 
            is disabled. Key ON is an exception, it can be still detected and generate key interrupt
            even if KP_En = '0', however in this case, the debouncing time configuration in key
            control register is ignored and the key ON state is considerred to be stable if it keeps
            same in consecutive 2 cycles of 16KHz clock.<br/>
        <br/>0 = keypad disable<br/>1 = keypad enable  
      </comment>
    </bits>

    <bits name='KP_EVT0_IRQ_MASK' access='rw' rst='0' pos='1'>
      <comment>This bit mask keypad irq generated by event0 (key press or key release event, not including all keys release event which is event1). 
        <br/>0 = keypad event irq disable<br/>1 = keypad event irq enable  
      </comment>
    </bits>
    
    <bits name='KP_EVT1_IRQ_MASK' access='rw' rst='0' pos='2'>
      <comment>This bit mask keypad irq generated by event1 (all keys release event). 
        <br/>0 = keypad event irq disable<br/>1 = keypad event irq enable  
      </comment>
    </bits>
    
    <bits name='KP_ITV_IRQ_MASK' access='rw' rst='0' pos='3'>
      <comment>This bit mask keypad irq generated by key pressed long time (generated each interval configured in KP_ITV_Time. 
        <br/>0 = keypad interval irq disable<br/>1 = keypad interval irq enable  
      </comment>
    </bits>
    
    <bits name='KP_DBN_Time' access='rw' rst='0' pos='11:4'>
      <comment>De-bounce time = (KP_DBN_TIME + 1) * SCAN_TIME, SCAN_TIME = 0.3125 ms * Number of Enabled KeyOut (determined by KP_OUT_MASK). For example, if KP_DBN_TIME = 7, KP_OUT_MASK = "111111", then De-bounce time = (7+1)*0.3125*6=15 ms. The maximum debounce time is 480 ms.
      </comment>
    </bits>

   <bits name='KP_ITV_Time' access='rw' rst='63' pos='17:12'>
      <comment>Configure interval of generating an IRQ if one key or several keys are pressed long time. Interval of IRQ generation = (KP_ITV_Time + 1) * (KP_DBN_TIME + 1) * SCAN_TIME. SCAN_TIME = 0.3125 ms * Number of Enabled KeyOut (determined by KP_OUT_MASK). For example, if KP_ITV_TIME = 7, KP_DBN_TIME = 7, KP_OUT_MASK = "111111", then De-bounce time = (7+1)*(7+1)*0.3125*6=120 ms. 
      </comment>
    </bits>
    
    <bits name='KP_IN_MASK' access='rw' rst='63' pos='23:18'>
        <comment>each bit masks one input lines.<br/>
            '1' = enabled <br/> '0' = disabled </comment>
    </bits>

    <bits name='KP_OUT_MASK' access='rw' rst='63' pos='29:24'>
        <comment>each bit masks one output lines.<br/>
            '1' = enabled <br/> '0' = disabled </comment>
    </bits>

  </reg>

  <reg name='KP_IRQ_CAUSE' protect='r'>
    <bits name='KP_EVT0_IRQ_CAUSE' access='r' rst='0' pos='0'>
      <comment>keypad event0(key press or key release event, not including all keys release which is event1) IRQ cause. 
      </comment>
    </bits>

    <bits name='KP_EVT1_IRQ_CAUSE' access='r' rst='0' pos='1'>
      <comment>keypad event1(all keys release event) IRQ cause. 
      </comment>
    </bits>

    <bits name='KP_ITV_IRQ_CAUSE' access='r' rst='0' pos='2'>
      <comment>keypad interval irq cause. 
      </comment>
    </bits>
    
    <bits name='KP_EVT0_IRQ_STATUS' access='r' rst='0' pos='16'>
      <comment>keypad event0(key press or key release event, not including all keys release which is event1) irq status. 
      </comment>
    </bits>

    <bits name='KP_EVT1_IRQ_STATUS' access='r' rst='0' pos='17'>
      <comment>keypad event1(all keys release event) irq status. 
      </comment>
    </bits>
  
    <bits name='KP_ITV_IRQ_STATUS' access='r' rst='0' pos='18'>
      <comment>keypad interval irq status. 
      </comment>
    </bits>

  </reg>
  
  <reg name='KP_IRQ_CLR' protect='w'>
    <bits name='KP_IRQ_CLR' access='c' rst='0' pos='0'>
      <comment>Write '1' to this bit clears key IRQ. </comment>
    </bits>
  </reg>

</module>
</archive>
<archive relative='pwm.xml'>

<module name='pwm' category='Periph'>
    <reg name='PWT_Config' protect='rw'>
        <bits name='PWT_Enable' access='rw' rst='0' pos='0'>
            <comment>Enables the Pulse Width Tone output
                <br/>1 = Enable PWT output
                <br/>0 = Disable PWT output
            </comment>            
        </bits>
        <bits name='PWT_Duty' access='rw' rst='all1' pos='13:4'>
            <comment>The PWT_Duty value can be used to set the approximate volume of the tone.
                <br/> The PWT_Duty value must be less than or equal to half the PWT_Period value and must be at least a value of 8, otherwise no tone will be generated.
            </comment>
        </bits>
        <bits name='PWT_Period' access='rw' rst='all1' pos='26:16'>
            <comment>PWT_Period is the divider value to produce a tone of a given frequency.
                <br/> To calculate the PWT_Period value, Use the following formula:
                <br/>  PWT_Period = FBASE/FNOTE
                <br/> where FBASE is the frequency of the PWM module clock (it is based on the system frequency, 26, 39, 52, 78 or 104 MHz divided by 5).  FNOTE is the frequency of the desired tone.
            </comment>
        </bits>        
    </reg>
    <reg name='LPG_Config' protect='rw'>
        <bits name='LPG_Reset_L' access='rw' pos='1'>
            <comment>Setting this bit to '0' will reset the Light Pulse Generator internal counters.
            </comment>
        </bits>
        <bits name='LPG_OnTime' access='rw' rst='0xf' pos='7:4'>
            <comment>Configures the duty cycle for the Light Pulse Generator by setting the ontime for the LPG output. The actual on-time is calculated as: Tick Period * LPG_OnTime * 256 where the Tick Period is nominally 1/16kHz.
            </comment>
            <options>
                <option name='undefined' value='0'/>
                <option name='15_6mS' value='1'/>
                <option name='31_2mS' value='2'/>
                <option name='46_8mS' value='3'/>
                <option name='62mS' value='4'/>
                <option name='78mS' value='5'/>
                <option name='94mS' value='6'/>
                <option name='110mS' value='7'/>
                <option name='125mS' value='8'/>
                <option name='140mS' value='9'/>
                <option name='156mS' value='10'/>
                <option name='172mS' value='11'/>
                <option name='188mS' value='12'/>
                <option name='200mS' value='13'/>
                <option name='218mS' value='14'/>
                <option name='234mS' value='15'/>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name='LPG_Period' access='rw' pos='18:16'>
            <comment>Configures the main period of the light pulse generator. The period is calculated based on the following configurations:
            <br/>with the Tick Period ~ 1/16kHz<br/>
            </comment>
            <options>
                <option name='0_125s' value='0'><comment>Tick Period * 2048</comment></option>
                <option name='0_25s' value='1'><comment>Tick Period * 4096</comment></option>
                <option name='0_5s' value='2'><comment>Tick Period * 8192</comment></option>
                <option name='0_75s' value='3'><comment>Tick Period * 12288</comment></option>
                <option name='1s' value='4'><comment>Tick Period * 16384</comment></option>
                <option name='1_25s' value='5'><comment>Tick Period * 20480</comment></option>
                <option name='1_5s' value='6'><comment>Tick Period * 24576</comment></option>
                <option name='1_75s' value='7'><comment>Tick Period * 28672</comment></option>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
    </reg>
    <reg name='PWL0_Config' protect='rw'>
        <bits name='PWL_Min' access='rw' rst='all1' pos='7:0'>
            <comment>Sets the lower boundary for PWL pulse.  When pulse mode is not used, this is the threshold value for the PWL0.  Reading this value will return the current value used for the threshold.
            </comment>
        </bits>
        <bits name='PWL_Max' access='rw' rst='all1' pos='15:8'>
            <comment>Sets the upper boundary for PWL pulse.  When pulse mode is not used, this value is ignored.  Reading this value will return the LFSR value used for generating the PWL outputs.
            </comment>
        </bits>
        <bits name='PWL0_En_H' access='rs' rst='0' pos='16'>
            <comment>When this bit is written with '1', the PWL 0 is enabled and the output is a PRBS whose average on-time is proportional to PWL_Min.  This bit is cleared when either of the Force bits are written.  Reading this bit will return the current state of the PWL0 enable.
            </comment>
        </bits>
        <bits name='PWL0_Force_L' access='rc' rst='0' pos='17'>
            <comment>Writing a '1' to this bit will force the PWL0 to output a low value.  If the PWL0 was previously enabled, this will clear the bit.
            </comment>
        </bits>
        <bits name='PWL0_Force_H' access='s' rst='no' pos='18'>
            <comment>Writing a '1' to this bit will force the PWL0 to output a high value.  If the PWL0 was previously enabled, this will clear the bit.
            </comment>
        </bits>
        <bits name='PWL_Pulse_En' access='rw' rst='0' pos='19'>
            <comment>This will enable the PWL pulse mode.  The threshold will dynamically sweep between PWL_Min and PWL_Max at a rate depending on PWL_Pulse_Per.
            </comment>
        </bits>
        <bits name='PWL0_Set_OE' access='rs' rst='0' pos='20'>
            <comment>Writing '1' to this bit will set the output enable.  Reading this bit will return the current status.
            </comment>
        </bits>
        <bits name='PWL0_Clr_OE' access='c' rst='no' pos='21'>
            <comment>Writing '1' to this bit will clear the output enable.
            </comment>
        </bits>
        <bits name='PWL_Set_Mux' access='rs' rst='0' pos='22'>
            <comment>Writing a '1' to this bit will swap the PWL0 and PWL1 outputs.  Reading this bit will return the current status.
            </comment>
        </bits>
        <bits name='PWL_Clr_Mux' access='c' rst='no' pos='23'>
            <comment>Writing a '1' to this bit will unswap the PWL0/PWL1 outputs.
            </comment>
        </bits>
        <bits name='PWL_Pulse_Per' access='w' rst='all1' pos='31:24'>
            <comment>This value will adjust the pulse period when pulsing is enabled.
            </comment>
        </bits>
    </reg>
    <reg name='PWL1_Config' protect='rw'>
        <bits name='PWL1_Threshold' access='rw' rst='all1' pos='7:0'>
            <comment>Average duty cycle for the Pulse Width Light 1 output. The average duty cycle is calculated as PWL1_Threshold/256.
            </comment>
        </bits>
        <bits name='LFSR_Reg' access='r' rst='0xa1' pos='15:8'>
            <comment>LFSR value for PWL.
            </comment>
        </bits>
        <bits name='PWL1_En_H' access='rs' rst='0' pos='16'>
            <comment>When this bit is written with '1', the PWL 1 is enabled and the output is a PRBS whose average on-time is proportional to PWL1_Threshold.  This bit is cleared when either of the Force bits are written.  Reading this bit will return the current state of the PWL1 enable.
            </comment>
        </bits>
        <bits name='PWL1_Force_L' access='rc' rst='0' pos='17'>
            <comment>Writing a '1' to this bit will force the PWL1 to output a low value.  If the PWL1 was previously enabled, this will clear the bit.
            </comment>
        </bits>
        <bits name='PWL1_Force_H' access='s' rst='no' pos='18'>
            <comment>Writing a '1' to this bit will force the PWL1 to output a high value.  If the PWL1 was previously enabled, this will clear the bit.
            </comment>
        </bits>
        <bits name='PWL1_Set_OE' access='rs' rst='0' pos='20'>
            <comment>Writing '1' to this bit will set the output enable.  Reading this bit will return the current status.
            </comment>
        </bits>
        <bits name='PWL1_Clr_OE' access='c' rst='no' pos='21'>
            <comment>Writing '1' to this bit will clear the output enable.
            </comment>
        </bits>
    </reg>
</module>
</archive>
<archive relative='calendar.xml'>

<module name='calendar' category='System'>

    <reg name='Ctrl' protect='wr'>

        <bits name='Interval' access='wr' rst='00' pos='1:0'>
            <options>
                <default/>
                <option name='DISABLE' value='00'/>
                <option name='PER SEC' value='01'/>
                <option name='PER MIN' value='10'/>
                <option name='PER HOUR' value='11'/>
            </options>
            <comment>These 2 bits configure the interval of generating an IRQ status.
            </comment>
        </bits>
    </reg>
    
    <reg name='Cmd' protect='rw'>
        <bits name='Calendar_Load' access='rs' rst='0' pos='0'>
            <comment>When write, command to program calendar with a new value (sec, min, hour, day, month, year, day of week) previously written in registers Calendar_LoadVal_H and Calendar_LoadVal_L. This bit is auto cleared.
                <br/>'1' = load calendar timer.  
                <br/>
                <br/>When read, Calendar timer load status.
                <br/>'1' = Calendar load has not finished.
                <br/>'0' = Calendar load has finished.
            </comment>
        </bits>
        <bits name='Alarm_Load' access='rs' rst='0' pos='4'>
            <comment>When write, command to program alarm with a new value (sec, min, hour, day, month, year, day of week) prviously written in registers AlarmVal_H and AlarmVal_L. This bit is auto cleared. 
                <br/>'1' = load alarm.
                <br/>
                <br/>When read, alarm load status.
                <br/>'1' = alarm load has not finished.
                <br/>'0' = alarm load has finished.
            </comment>
        </bits>
        <bits name='Alarm_Enable_Set' access='rs' rst='0' pos='5'>
            <comment>command to enable alarm. When alarm is triggered, it will generate a wakup.
                <br/>'1' = enable alarm.
                <br/>
                <br/>When read, alarm enable status.
                <br/>'1' = alarm enable operation is on going, not finished.
                <br/>'0' = alarm is enabled.                  
            </comment>
        </bits>
        <bits name='Alarm_Enable_Clr' access='rc' rst='0' pos='6'>
            <comment>command to disable alarm.
                <br/>'1' = disable alarm.
                <br/>
                <br/>When read, alarm enable status.
                <br/>'1' = alarm disable operation is on going, not finished.
                <br/>'0' = alarm is disabled.                  
            </comment>
        </bits>
        <bits name='Alarm_Clr' access='rc' rst='0' pos='8'>
            <comment>writing '1', clear Alarm triggered signal (connect to wakeup) and alarm triggered IRQ.
                <br/>
                <br/>When read, get alarm clear status.
                <br/>'1' = alarm clear operation is on going, not finished.
                <br/>'0' = alarm is cleared.                  
            </comment>
        </bits>
        <bits name='Itv_Irq_Clr' access='c' rst='0' pos='9'>
            <comment>writing '1', clear interval IRQ.
            </comment>
        </bits>
        <bits name='Itv_Irq_Mask_Set' access='rs' rst='0' pos='16'>
            <comment>When write '1', Set interval Irq Mask. 
                <br/>When read, get interval Irq mask.
            </comment>
        </bits>        
        <bits name='Itv_Irq_Mask_Clr' access='rc' rst='0' pos='17'>
            <comment>When write '1', Clear interval Irq Mask. 
                <br/>When read, get inteval Irq mask.
            </comment>
        </bits>               
        <bits name='Calendar_Not_Valid' access='rs' rst='0' pos='31'>
            <comment>When write '1', mark calendar value to be not valid.
                <br/>
                <br/>When read, Indicate if the Calendar value is valid or not.
                <br/>The calendar value is not valid in case of mismatch between the calendar counter and the APB register,
                    which is the case of wakeup the phone after shut down. This mismatch disappear after one RTC cycle or 
                    after re-porgramming a new calendar value. 
                <br/>'1' = not valid.
            </comment>
        </bits>        
    </reg>

    <reg name='Status' protect='r'>
        
        <bits name='Itv_Irq_Cause' access='r' rst='0' pos='0'>
            <comment>Interval Irq Cause. 
            </comment>
        </bits>    
        <bits name='Alarm_Irq_Cause' access='r' rst='0' pos='1'>
            <comment>Alarm Irq Cause. 
            </comment>
        </bits> 
        <bits name='Force_Wakeup' access='r' rst='0' pos='8'>
             <comment>Force Wakeup status. After set "Force_Wakeup" to '1' in sys_ctrl, the real
                 force_wakeup is not set immediatly, this bit indicates when the force wakeup is 
                 really set. This bits also indicates if the interface between Calendar domain and
                 Core domain is enabled. 
                <br/>'1': force wakeup set.
            </comment>
        </bits>           
        <bits name='Itv_Irq_Status' access='r' rst='0' pos='16'>
            <comment>Interval Irq Status. 
            </comment>
        </bits>        
        <bits name='Alarm_Enable' access='r' rst='0' pos='20'>
            <comment>Alarm Enable Status. 
                <br/> Note: When calendar is not programmed, Alarm can be enabled or not. 
                <br/> It is suggested to clear Alarm Enable when program RTC. 
            </comment>
        </bits>          
        <bits name='Calendar_Not_Prog' access='r' rst='0' pos='31'>
            <comment>'1' = Calendar has not been programmed. 
                <br/>This bit keep value '0' after the calendar is programmed once.
            </comment>
        </bits>
    </reg>

    <reg name='Calendar_LoadVal_L' protect='rw'>
        <bits name='Sec' access='rw' rst='-' pos='5:0'>
            <comment>Second value loaded to calendar, ranged from 0 to 59. 
            </comment>
        </bits>         
        <bits name='Min' access='rw' rst='-' pos='13:8'>
            <comment>Minute value loaded to calendar, ranged from 0 to 59. 
            </comment>
        </bits>          
        <bits name='Hour' access='rw' rst='-' pos='20:16'>
            <comment>Hour value loaded to calendar, ranged from 0 to 23. 
            </comment>
        </bits>         
    </reg>

    <reg name='Calendar_LoadVal_H' protect='rw'>
        <bits name='Day' access='rw' rst='-' pos='4:0'>
            <comment>Day value loaded to calendar, ranged from 1 to 31. 
            </comment>
        </bits>         
        <bits name='Mon' access='rw' rst='-' pos='11:8'>
            <comment>Month value loaded to calendar, ranged from 1 to 12. 
            </comment>
        </bits>          
        <bits name='Year' access='rw' rst='-' pos='22:16'>
            <comment>Year value loaded to calendar, ranged from 0 to 127. 
                <br/>Represent year 2000 to 2127.
            </comment>
        </bits>
        <bits name='WeekDay' access='rw' rst='-' pos='26:24'>
            <comment>Day of the week value loaded to calendar, ranged from 1 to 7.
                <br/>Represent Monday, Tuesday etc.
            </comment>
        </bits>
    </reg>

    <reg name='Calendar_CurVal_L' protect='r'>
        <bits name='Sec' access='r' rst='-' pos='5:0'>
            <comment>Current Second value of calendar, ranged from 0 to 59. 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name='Min' access='r' rst='-' pos='13:8'>
            <comment>Current Minute value of calendar, ranged from 0 to 59. 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name='Hour' access='r' rst='-' pos='20:16'>
            <comment>Current Hour value of calendar, ranged from 0 to 23. 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>         
    </reg>
    
    <reg name='Calendar_CurVal_H' protect='r'>
        <bits name='Day' access='r' rst='-' pos='4:0'>
            <comment>Current Day value of calendar, ranged from 1 to 31. 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>         
        <bits name='Mon' access='r' rst='-' pos='11:8'>
            <comment>Current Month value of calendar, ranged from 1 to 12. 
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>          
        <bits name='Year' access='r' rst='-' pos='22:16'>
            <comment>Current Year value of calendar, ranged from 0 to 127. 
                <br/>Represent year 2000 to 2127.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name='WeekDay' access='r' rst='-' pos='26:24'>
            <comment>Current Day of the week value of calendar, ranged from 1 to 7.
                <br/>Represent Monday, Tuesday etc.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
    </reg>
     
    <reg name='AlarmVal_L' protect='rw'>
        <bits name='Sec' access='rw' rst='-' pos='5:0'>
            <comment>Second value loaded to alarm, ranged from 0 to 59. 
            </comment>
        </bits>         
        <bits name='Min' access='rw' rst='-' pos='13:8'>
            <comment>Minute value loaded to alarm, ranged from 0 to 59. 
            </comment>
        </bits>          
        <bits name='Hour' access='rw' rst='-' pos='20:16'>
            <comment>Hour value loaded to alarm, ranged from 0 to 23. 
            </comment>
        </bits>         
    </reg>

    <reg name='AlarmVal_H' protect='rw'>
        <bits name='Day' access='rw' rst='-' pos='4:0'>
            <comment>Day value loaded to alarm, ranged from 1 to 31. 
            </comment>
        </bits>         
        <bits name='Mon' access='rw' rst='-' pos='11:8'>
            <comment>Month value loaded to alarm, ranged from 1 to 12. 
            </comment>
        </bits>          
        <bits name='Year' access='rw' rst='-' pos='22:16'>
            <comment>Year value loaded to alarm, ranged from 0 to 127. 
                <br/>Represent year 2000 to 2127.
            </comment>
        </bits>
    </reg>
    
    
</module>



</archive>
<archive relative='ana_acco.xml'>

<module name='ana_acco' category='System'>
    <enum name='Ana_Test_Modes'>
          <entry name='ANA_TEST_NONE'/>
          <entry name='ANA_TEST_TX_DAC'/>
          <entry name='ANA_TEST_RX_ADC'/>
          <entry name='ANA_TEST_AFCDAC'/>
          <entry name='ANA_TEST_PADAC'/>
          <entry name='ANA_TEST_AU_CODEC'/>
          <entry name='ANA_TEST_GPADC'/>
    </enum>
    <reg name='audio_ctrl_set' protect='rw'>
        <bits name='au_reset_release' access='rs' rst='0' pos='0'> 
            <comment>A general asynchronous master reset is applied to all digital gates.
                <br/>Writing a 1 to this bit will release the reset.
                <br/>Reading this register returns the reset state.
                <br/>0 = Reset mode
                <br/>1 = Out of reset mode
            </comment>
        </bits>
        <bits name='au_deep_pd_release' access='rs' rst='0' pos='1'>
            <comment>Audio Codec deep power down. 
                <br/>Writing a 1 to this bit will put the full audio macro out of deep power state.
                <br/>Reading this register returns the deep power state.
                <br/>0 = Deep Power down
                <br/>1 = Out of Deep Power down
            </comment>
        </bits>
        <bits name='au_sd_enable' access='rs' rst='0' pos='2'>
            <comment>Sigma Delta ADC enable bit. Writing a 1 to this bit will enable the ADC.
                <br/>Reading this register returns the ADC enable state.
                <br/>0 = ADCA disable (power off)
                <br/>1 = ADCA enable (power on) 
            </comment>
        </bits>
        <bits name='au_daca_enable' access='rs' rst='0' pos='3'>
            <comment>DACA enable bit. Writing a 1 to this bit will enable the DAC.
                <br/>Reading this register returns the DAC enable state.  
                <br/>0 = DACA disable (power off)
                <br/>1 = DACA enable (power on) 
            </comment>
        </bits>
        <bits name='au_mic_enable' access='rs' rst='0' pos='4'>
            <comment>Microphone amplifier enable. Writing a 1 to this bit will enable the microphone power amplifier.
                <br/>Reading this register returns the microphone enable state.  
                <br/>0 = Mic disable (power off)
                <br/>1 = Mic enable (power on)
            </comment>
        </bits>
        <bits name='au_spk_enable' access='rs' rst='0' pos='5'>
            <comment>Speaker amplifier enable.  Writing a 1 to this bit will enable the peaker power amplifier.
                <br/>Reading this register returns the speaker enable state.  
                <br/>0 = Speaker disable (power off)
                <br/>1 = Speaker enable (power on)
            </comment>
        </bits>
        <bits name='au_mic_filt_bp_enable' access='rs' rst='0' pos='6'>
            <comment>Bypass the mic (Rx) audio FIR filter. Writing a 1 to this bit will enable the bypass.
                <br/>Reading this register returns the bypass state.  
                <br/>0 = Bypass disable 
                <br/>1 = Bypass enable. The CIC output is connected to the AIF Rx data.
            </comment>
        </bits>
        <bits name='au_spk_filt_bp_enable' access='rs' rst='0' pos='7'>
            <comment>Bypass the audio spk (Tx) FIR filter. Writing a 1 to this bit will enable the bypass.
                <br/>Reading this register returns the bypass state.  
                <br/>0 = Bypass disable 
                <br/>1 = Bypass enable. The AIF Tx data is conencted to the acco audio codec
            </comment>
        </bits>
    </reg>
    <reg name='audio_ctrl_clr' protect='rw'>
        <bits name='au_reset_n' access='rc' rst='0' pos='0'> 
            <comment>A general asynchronous master reset is applied to all digital gates.
                <br/>Writing a 1 to this bit will put audio module in reset state (reset low).
                <br/>Reading this register returns the reset state.
                <br/>0 = Reset mode
                <br/>1 = Out of reset (Normal mode)
            </comment>
        </bits>
        <bits name='au_deep_pd_n' access='rc' rst='0' pos='1'>
            <comment>Audio Codec deep power down. 
                <br/>Writing a 1 to this bit will put the audio macro in the deep power down state.
                <br/>Reading this register returns the deep power state.
                <br/>0 = Deep Power down
                <br/>1 = Out of Deep Power down
            </comment>
        </bits>
        <bits name='au_sd_disable' access='rc' rst='0' pos='2'>
            <comment>Sigma Delta ADC enable bit. Writing a 1 to this bit will disable the ADC.
                <br/>Reading this register returns the ADC enable state.
                <br/>0 = ADCA disable (power off)
                <br/>1 = ADCA enable (power on) 
            </comment>
        </bits>
        <bits name='au_daca_disable' access='rc' rst='0' pos='3'>
            <comment>DACA enable bit. Writing a 1 to this bit will disable the DAC.
                <br/>Reading this register returns the DAC enable state.  
                <br/>0 = DACA disable (power off)
                <br/>1 = DACA enable (power on) 
            </comment>
        </bits>
        <bits name='au_mic_disable' access='rc' rst='0' pos='4'>
            <comment>Microphone amplifier enable. Writing a 1 to this bit will disable the microphone power amplifier.
                <br/>Reading this register returns the microphone enable state.  
                <br/>0 = Mic disable (power off)
                <br/>1 = Mic enable (power on)
            </comment>
        </bits>
        <bits name='au_spk_disable' access='rc' rst='0' pos='5'>
            <comment>Speaker amplifier enable.  Writing a 1 to this bit will disable the speaker power amplifier.
                <br/>Reading this register returns the speaker enable state.  
                <br/>0 = Speaker disable (power off)
                <br/>1 = Speaker enable (power on)
            </comment>
        </bits>
        <bits name='au_mic_filt_bp_disable' access='rc' rst='0' pos='6'>
            <comment>Bypass the mic (Rx) audio FIR filter. Writing a 1 to this bit will disable the bypass.
                <br/>Reading this register returns the bypass state.  
                <br/>0 = Bypass disable 
                <br/>1 = Bypass enable. The CIC output is connected to the AIF Rx data.
            </comment>
        </bits>
        <bits name='au_spk_filt_bp_disable' access='rc' rst='0' pos='7'>
            <comment>Bypass the audio spk (Tx) FIR filter. Writing a 1 to this bit will disable the bypass.
                <br/>Reading this register returns the bypass state.  
                <br/>0 = Bypass disable 
                <br/>1 = Bypass enable. The AIF Tx data is conencted to the acco audio codec
            </comment>
        </bits>
    </reg>
    <reg name='audio_sel' protect='rw'>
        <bits name='au_mic_sel' access='rw' rst='0' pos='0'>
            <comment>Microphone amplifier input selection.
                <br/>0 = Mic0 selected
                <br/>1 = Mic1 selected
            </comment>
            <options><mask/><shift/></options>
        </bits>
        <bits name='au_spk_sel' access='rw' rst='0' pos='4'>
            <comment>Speaker amplifier output selection.
                <br/>0 = Amplifier0 selected.
                <br/>1 = Amplifier1 selected (Auxiliary). 
            </comment>
            <options><mask/><shift/></options>
        </bits>
    </reg>   
    <reg name='audio_mic_gain' protect='rw'>
        <bits name='au_mic_ana_gain' display='hex' access='rw' rst='0x0' pos='3:0'>
            <comment>Microphone amplifier analog gain selection.
                <br/>Range from 0 to 45dB with 3dB steps.
                <br/>
                <br/>0000 = 0 dB
                <br/>0001 = 3 dB
                <br/>0010 = 6 dB
                <br/>0011 = 9 dB
                <br/>0100 = 12 dB
                <br/>0101 = 15 dB
                <br/>0110 = 18 dB
                <br/>0111 = 21 dB
                <br/>1000 = 24 dB
                <br/>1001 = 27 dB
                <br/>1010 = 30 dB
                <br/>1011 = 33 dB
                <br/>1100 = 36 dB
                <br/>1101 = 39 dB
                <br/>1110 = 42 dB
                <br/>1111 = 45 dB
            </comment>
        </bits>
        <bits name='au_mic_dig_gain' display='hex' access='rw' rst='0x0' pos='5:4'>
            <comment>Microphone amplifier digital gain selection.
                <br/>Range from 0dB to +18dB with 6dB steps.
                <br/>
                <br/>00 = 0 dB
                <br/>01 = +6 dB
                <br/>10 = +12 dB
                <br/>11 = +18 dB
            </comment>
        </bits>
<bits name='au_mic_mute' access='rw' rst='0' pos='16'> 
            <comment>Mute Signal. This signal is used to set all the au_micxx inputs to High Impedance. At the same time the output of the input selector is forced to AGND. In this way the receive section of the Audio Codec is forced in Mute mode. This signal is independent from au_deep_pd.
                <br/>
                <br/>0 = Mute mode            
                <br/>1 = Active mode
            </comment>
            <options>
                <option name='MUTE' value='0'/>
                <option name='UNMUTE' value='1'/>
                <default/>
            </options>
        </bits>
    </reg>
    <reg name='audio_spk_gain' protect='rw'>
        <bits name='au_spk_ana_gain' display='hex' access='rw' rst='0x0' pos='2:0'>
            <comment>Speaker power amplifier analog gain selection.
                <br/>Range from -15dB to 6dB with 3dB steps.
                <br/>
                <br/>000 = -15 dB
                <br/>001 = -12 dB
                <br/>010 = -9 dB
                <br/>011 = -6 dB
                <br/>100 = -3 dB
                <br/>101 = 0 dB
                <br/>110 = 3 dB
                <br/>111 = 6 dB
            </comment>
        </bits>
        <bits name='au_spk_dig_gain' display='hex' access='rw' rst='0x0' pos='5:4'>
            <comment>Speaker power amplifier digital gain selection.
                <br/>Range from 0dB to +18dB with 6dB steps.
                <br/>
                <br/>00 = 0 dB
                <br/>01 = +6 dB
                <br/>10 = +12 dB
                <br/>11 = +18 dB
            </comment>
        </bits>
        <bits name='au_spk_mute' access='rw' rst='0' pos='16'>
            <comment>Mute Signal.
                <br/>
                <br/>0 = Mute mode
                <br/>1 = Active mode
            </comment>
            <options>
                <option name='MUTE' value='0'/>
                <option name='UNMUTE' value='1'/>
                <default/>
            </options>
        </bits>
    </reg>
    <reg name='audio_calib' protect='rw'>
        <bits name='au_bg_enable' access='rw' rst='0' pos='0'>
            <comment>Au_bg_enable is the Bandgap enable bit.
                <br/>0 = Disable (power off)
                <br/>1 = Enable (power on)
            </comment>
        </bits>
        <bits name='au_bg_startup' access='rw' rst='0' pos='1'>
            <comment>This digital signal is used to speed up the recover of the bandgap from a PD mode or at the start up. It has to be used with the au_bg_ok signal. if au_bg_ok is not set within T0=100 ms the micro controller will set the au_bg_startup for T1=100 ms.
            <br/><center><img src='ana_ctrl_au_bg_startup.gif'/></center>
            </comment>
        </bits>
        <bits name='au_bg_ok' access='r' pos='2'>
            <comment>This signal is set by the bandgap after the startup when the output voltage is stable.
            </comment>
        </bits>
        <bits name='au_bg_ctrl' display='hex' access='rw' rst='0x0' pos='9:4'>
            <comment>au_bg_ctrl[3:0]: BANDGAP TRIMMING These bits are used for the bandgap trimming according to the table below:
                <br/>
                <br/>0000 649.8mV
                <br/>0001 659.5mV
                <br/>0010 669.1mV
                <br/>0011 678.7mV
                <br/>0100 688.1mV
                <br/>0101 697.9mV (normal value)
                <br/>0110 707.5mV
                <br/>0111 717.1mV
                <br/>1000 726.8mV
                <br/>1001 736.4mV
                <br/>1010 746mV
                <br/>1011 755.6mV
                <br/>1100 765.2mV
                <br/>1101 774.8mV
                <br/>1110 784.4mV
                <br/>1111 794mV
                <br/>
                <br/>au_bg_ctrl[5:4]: REFERENCE CURRENT TRIMMING
                <br/>The control bits allow the trimming of the current reference according to the table below:
                <br/>
                <br/>00 0 uA
                <br/>01 9.36 uA (75%)
                <br/>10 12.48 uA (100%) (normal value)
                <br/>11 15.6 uA (125%)
            </comment>
        </bits>
        <bits name='au_ref_enable' access='rw' rst='0' pos='12'>
            <comment>Current Mirror enable bit (power down mode selection).
                <br/>0 = Disable (power off)
                <br/>1 = Enable (power on)
            </comment>
        </bits>
        <bits name='au_ref_cal' display='hex' access='rw' rst='0x0' pos='18:16'>
            <comment>Calibration signals for AGND trimming. During the calibration phase the AGND is measured through the general purpose ADC and compared with VDDA/2. A calibration up to +/-100mV with steps of 25mV is possible. The typical configuration is au_ref_cal[2:0]=011. The calibration table is as below:
                <br/>
                <br/>000 -75 mV
                <br/>001 -50 mV
                <br/>010 -25 mV
                <br/>011   0 mV (normal value)
                <br/>100 +25 mV
                <br/>101 +50 mV
                <br/>110 +75 mV
                <br/>111 +100 mV
            </comment>
        </bits>
    </reg>
    <reg name='rf_ctrl_set' protect='rw'>
        <bits name='rf_reset_release' access='rs' rst='0' pos='0'> 
            <comment>A general asynchronous master reset is applied to all digital gates.
                <br/>Writing a 1 to this bit will release the reset out the the RF macro.
                <br/>Reading this register returns the reset state.
                <br/>0 = Reset mode
                <br/>1 = Out of reset mode
            </comment>
        </bits>
        <bits name='rf_deep_pd_release' access='rs' rst='0' pos='1'>
            <comment>RF macro deep power down. 
                <br/>Writing a 1 to this bit will put the full RF macro out of deep power state.
                <br/>Reading this register returns the deep power state.
                <br/>0 = Deep Power down
                <br/>1 = Out of Deep Power down
            </comment>
        </bits>
        <bits name='rx_AAF_bypass' access='rs' rst='0' pos='4'>
            <comment>Writing a 1 to this bit will bypass the AAF. 
                <br/>When rf_rx_AAF_bypass signal is HIGH, the analog filters are bypassed and both I and Q inputs drive the ADCs directly. The AAF is in power down mode and the resulting power consumption is reduced.
                <br/>Reading this register returns the state of the bypass bit 
                <br/>0 = Normal mode, Anti-aliasing filters ON
                <br/>1 = Bypass mode, Anti-aliasing filters bypassed and cut-off
            </comment>
        </bits>
        <bits name='tx_dac_enable' access='rs' rst='0' pos='16'>
            <comment>Writing a 1 to this bit will enable the Tx DAC
                <br/>
                <br/>Reading this register returns the state of the DAC enable bit 
                <br/>0 = Disable (power off)
                <br/>1 = Enable (power on)
            </comment>
        </bits>
    </reg>
    <reg name='rf_ctrl_clr' protect='rw'>
        <bits name='rf_reset_n' access='rc' rst='0' pos='0'> 
            <comment>A general asynchronous master reset is applied to all digital gates.
                <br/>Writing a 1 to this bit will put RF macro in reset state.
                <br/>Reading this register returns the reset state.
                <br/>0 = Reset mode
                <br/>1 = Out of reset mode
            </comment>
        </bits>
        <bits name='rf_deep_pd_n' access='rc' rst='0' pos='1'>
            <comment>RF macro deep power down. 
                <br/>Writing a 1 to this bit will put the RF macro in deep power down state.
                <br/>Reading this register returns the deep power state.
                <br/>0 = Deep Power down
                <br/>1 = Out of Deep Power down
            </comment>
        </bits>
        <bits name='rx_AAF_use' access='rc' rst='0' pos='4'>
            <comment>When rf_rx_AAF_bypass signal is HIGH. 
                <br/>Writing a 1 to this bit will enable the AAF (no bypass).
                <br/>Reading this register returns the state of the bypass bit 
                <br/>0 = Normal mode, Anti-aliasing filters ON
                <br/>1 = Bypass mode, Anti-aliasing filters bypassed and cut-off
            </comment>
        </bits>
        <bits name='tx_dac_disable' access='rc' rst='0' pos='16'>
            <comment>Writing a 1 to this bit will disable the Tx DAC
                <br/>
                <br/>Reading this register returns the state of the DAC enable bit 
                <br/>0 = Disable (power off)
                <br/>1 = Enable (power on)
            </comment>
        </bits>
    </reg>
    <reg name='rf_tx_calib' protect='rw'>
        <bits name='tx_bg_enable' access='rw' rst='0' pos='0'>
            <comment>tx_bg_enable is the Bandgap enable bit.
                <br/>0 = Disable (power off)
                <br/>1 = Enable (power on)
            </comment>
        </bits>
        <bits name='tx_bg_startup' access='rw' rst='0' pos='1'>
            <comment>This digital signal is used to speed up the recover of the bandgap from a PD mode or at the start up. It has to be used with the tx_bg_ok signal. if tx_bg_ok is not set within T0=100 ms the micro controller will set the tx_bg_startup for T1=100 ms.
            <br/><center><img src='./ana_ctrl_au_bg_startup.gif'/></center>
            </comment>
        </bits>
        <bits name='tx_bg_ok' access='r' pos='2'>
            <comment>This signal is set by the bandgap after the startup when the output voltage is stable.
            </comment>
        </bits>
        <bits name='tx_bg_ctrl' display='hex' access='rw' rst='0x0' pos='9:4'>
            <comment>tx_bg_ctrl[3:0]: BANDGAP TRIMMING These bits are used for the bandgap trimming according to the table below:
                <br/>
                <br/>0000 649.8mV
                <br/>0001 659.5mV
                <br/>0010 669.1mV
                <br/>0011 678.7mV
                <br/>0100 688.1mV
                <br/>0101 697.9mV (normal value)
                <br/>0110 707.5mV
                <br/>0111 717.1mV
                <br/>1000 726.8mV
                <br/>1001 736.4mV
                <br/>1010 746mV
                <br/>1011 755.6mV
                <br/>1100 765.2mV
                <br/>1101 774.8mV
                <br/>1110 784.4mV
                <br/>1111 794mV
                <br/>
                <br/>tx_bg_ctrl[5:4]: REFERENCE CURRENT TRIMMING
                <br/>The control bits allow the trimming of the current reference according to the table below:
                <br/>
                <br/>00 0 uA
                <br/>01 9.36 uA (75%)
                <br/>10 12.48 uA (100%) (normal value)
                <br/>11 15.6 uA (125%)
            </comment>
        </bits>
        <bits name='tx_dac_current_cali' display='hex' access='rw' rst='0x0' pos='14:12'>
            <comment>Calibration signals for DAC I2V conversion and compensation I channel.
                <br/>
                <br/>tx_dac_current_cali[2]: select active or passive I to V conversion
                <br/>according to the table below.
                <br/>
                <br/>0 Active I2V mode
                <br/>1 Passive I2V mode
                <br/>
                <br/>tx_dac_current_cali[1:0]: current calibration I channel. The control bits allow the trimming of the dac unit current (IUNIT) according to the table below.
                <br/>
                <br/>00 1.68 uA (84%)
                <br/>01 2 uA (100%) (normal value)
                <br/>10 2.43 uA (116%)
                <br/>11 2.64 uA (132%)
            </comment>
        </bits>
        <bits name='tx_dac_current_calq' display='hex' access='rw' rst='0x0' pos='18:16'>
            <comment>Calibration signals for DAC I2V conversion and compensation Q channel.
                <br/>
                <br/>tx_dac_current_calq[2]: select active or passive I to V conversion
                <br/>according to the table below.
                <br/>
                <br/>0 Active I2V mode
                <br/>1 Passive I2V mode
                <br/>
                <br/>tx_dac_current_calq[1:0]: current calibration Q channel. The control bits allow the trimming of the dac unit current (IUNIT) according to the table below.
                <br/>
                <br/>00 1.68 uA (84%)
                <br/>01 2 uA (100%) (normal value)
                <br/>10 2.43 uA (116%)
                <br/>11 2.64 uA (132%)
            </comment>
        </bits>
        <bits name='tx_ref_voltage_cal' display='hex' access='rw' rst='0x0' pos='23:20'>
                <comment>tx_ref_voltage_cal[3:2]: calibrate the reference voltage and amplitude value of the filter output channel Q signals. The control bits allow the calibration according to the table below.
                <br/>
                <br/>00 560 mV
                <br/>01 580 mV
                <br/>10 600 mV
                <br/>11 620 mV
                <br/>
                <br/>tx_ref_voltage_cal[1:0]: calibrate the reference voltage and amplitude value of the filter output channel I signals. The control bits allow the calibration according to the table below.
                <br/>
                <br/>00 560 mV
                <br/>01 580 mV
                <br/>10 600 mV
                <br/>11 620 mV
            </comment>
        </bits>
        <bits name='tx_filter_tuning' display='hex' access='rw' rst='0x0' pos='25:24'>
            <comment>Tx filter tuning. These bits allow the control of the filter bandwidth (Cutoff freq @ -3dB) according to the table below.
                <br/>
                <br/>00 350 Hz
                <br/>01 250 Hz
                <br/>10 200 Hz
                <br/>11 150 Hz
                <br/>
            </comment>
        </bits>
    </reg>
    <reg name='rf_tx_gmsk_calib' protect='rw'>
        <bits name='tx_gmsk_reduce_i' display='hex' access='rw' rst='0' pos='3:0'>
            <comment>Tx gmsk gain reduction on channel I. Adjust the reduction factor by steps of 0.8% of full scale (unsigned value):
                <br/>
                <br/>0000 =  0.0% (default full scale, gain factor 100%)
                <br/>0001 =  0.8%
                <br/>0010 =  1.6%
                <br/>0011 =  2.3%
                <br/>0100 =  3.1%
                <br/>0101 =  3.9%
                <br/>0110 =  4.7%
                <br/>0111 =  5.5%
                <br/>1000 =  6.3%
                <br/>1001 =  7.0%
                <br/>1010 =  7.8%
                <br/>1011 =  8.6%
                <br/>1100 =  9.4%
                <br/>1101 = 10.2%
                <br/>1110 = 10.9%
                <br/>1111 = 11.7% (minimal scale, gain factor 88.3%) 
           </comment>
        </bits>
        <bits name='tx_gmsk_offset_i' display='hex' access='rw' rst='0' pos='7:4'>
            <comment>Tx gmsk DC offset on channel I. Adjust the DC offset by step of 0.8% of full scale (signed value):
                <br/>
                <br/>0111 = +5.5%
                <br/>0110 = +4.7%
                <br/>0101 = +3.9%
                <br/>0100 = +3.1%
                <br/>0011 = +2.3%
                <br/>0010 = +1.6%
                <br/>0001 = +0.8%
                <br/>0000 =  0.0% (default, no DC offset)
                <br/>1111 = -0.8%
                <br/>1110 = -1.6%
                <br/>1101 = -2.3%
                <br/>1100 = -3.1%
                <br/>1011 = -3.9%
                <br/>1010 = -4.7%
                <br/>1001 = -5.5%
                <br/>1000 = -6.3%
           </comment>
        </bits>
        <bits name='tx_gmsk_reduce_q' display='hex' access='rw' rst='0' pos='19:16'>
            <comment>Tx gmsk gain reduction on channel Q. Adjust the reduction factor by steps of 0.8% of full scale (unsigned value):
                <br/>
                <br/>0000 =  0.0% (default full scale, gain factor 100%)
                <br/>0001 =  0.8%
                <br/>0010 =  1.6%
                <br/>0011 =  2.3%
                <br/>0100 =  3.1%
                <br/>0101 =  3.9%
                <br/>0110 =  4.7%
                <br/>0111 =  5.5%
                <br/>1000 =  6.3%
                <br/>1001 =  7.0%
                <br/>1010 =  7.8%
                <br/>1011 =  8.6%
                <br/>1100 =  9.4%
                <br/>1101 = 10.2%
                <br/>1110 = 10.9%
                <br/>1111 = 11.7% (minimal scale, gain factor 88.3%) 
           </comment>
        </bits>
        <bits name='tx_gmsk_offset_q' display='hex' access='rw' rst='0' pos='23:20'>
            <comment>Tx gmsk DC offset on channel Q. Adjust the DC offset by step of 0.8% of full scale (signed value):
                <br/>
                <br/>0111 = +5.5%
                <br/>0110 = +4.7%
                <br/>0101 = +3.9%
                <br/>0100 = +3.1%
                <br/>0011 = +2.3%
                <br/>0010 = +1.6%
                <br/>0001 = +0.8%
                <br/>0000 =  0.0% (default, no DC offset)
                <br/>1111 = -0.8%
                <br/>1110 = -1.6%
                <br/>1101 = -2.3%
                <br/>1100 = -3.1%
                <br/>1011 = -3.9%
                <br/>1010 = -4.7%
                <br/>1001 = -5.5%
                <br/>1000 = -6.3%
           </comment>
        </bits>
    </reg>
    <reg name='rf_tx_data_dac' protect='rw'>
        <bits name='rf_tx_data_dac_i' display='hex' access='rw' rst='0x3ff' pos='9:0'>
            <comment>data directly applied to the rf DAC I when the GMSK_on input signal is set to '0'.
            </comment>
        </bits>
        <bits name='rf_tx_data_dac_q' display='hex' access='rw' rst='0x3ff' pos='25:16'>
            <comment>data directly applied to the rf DAC Q when the GMSK_on input signal is set to '0'.
            </comment>
        </bits>
    </reg>
    <reg name='rf_rx_calib' protect='rw'>
        <bits name='rx_bg_enable' access='rw' rst='0' pos='0'>
            <comment>rx_bg_enable is the Bandgap enable bit.
                <br/>0 = Disable (power off)
                <br/>1 = Enable (power on)
            </comment>
        </bits>
        <bits name='rx_bg_startup' access='rw' rst='0' pos='1'>
            <comment>This digital signal is used to speed up the recover of the bandgap from a PD mode or at the start up. It has to be used with the rx_bg_ok signal. if rx_bg_ok is not set within T0=100 ms the micro controller will set the rx_bg_startup for T1=100 ms.
            <br/><center><img src='./ana_ctrl_au_bg_startup.gif'/></center>
            </comment>
        </bits>
        <bits name='rx_bg_ok' access='r' pos='2'>
            <comment>This signal is set by the bandgap after the startup when the output voltage is stable.
            </comment>
        </bits>
        <bits name='rx_bg_ctrl' display='hex' access='rw' rst='0x0' pos='9:4'>
            <comment>rx_bg_ctrl[3:0]: BANDGAP TRIMMING These bits are used for the bandgap trimming according to the table below:
                <br/>
                <br/>0000 649.8mV
                <br/>0001 659.5mV
                <br/>0010 669.1mV
                <br/>0011 678.7mV
                <br/>0100 688.1mV
                <br/>0101 697.9mV (normal value)
                <br/>0110 707.5mV
                <br/>0111 717.1mV
                <br/>1000 726.8mV
                <br/>1001 736.4mV
                <br/>1010 746mV
                <br/>1011 755.6mV
                <br/>1100 765.2mV
                <br/>1101 774.8mV
                <br/>1110 784.4mV
                <br/>1111 794mV
                <br/>
                <br/>rx_bg_ctrl[5:4]: REFERENCE CURRENT TRIMMING
                <br/>The control bits allow the trimming of the current reference according to the table below:
                <br/>
                <br/>00 0 uA
                <br/>01 9.36 uA (75%)
                <br/>10 12.48 uA (100%) (normal value)
                <br/>11 15.6 uA (125%)

                <br/>
                <br/> This bandgap is also used by the PLL.
            </comment>
        </bits>
        <bits name='rx_ref_cal' display='hex' access='rw' rst='0x0' pos='14:12'>
            <comment>Calibration signals for AGND trimming. During the calibration phase the AGND are measured through the general purpose ADC and compared with VDDA/2. A calibration up to +/-100mV with steps of 25mV is possible. The typical configuration is rx_ref_cal[2:0]=011. The calibration table is as below:
                <br/>
                <br/>000 -75 mV
                <br/>001 -50 mV
                <br/>010 -25 mV
                <br/>011 0 mV (normal value)
                <br/>100 +25 mV
                <br/>101 +50 mV
                <br/>110 +75 mV
                <br/>111 +100 mV
            </comment>
        </bits>
        <bits name='rx_dig_gain' access='rw' rst='0x0' pos='16'>
            <comment>Rx gain at the output of the digital filter. As the output of ACCO's reference design is on 12 bits and the actual output is on 13-bits, it can also be seen as a mux selecting either one extra MSB or LSB at the filter output.
                <br/>0 = 0 db (compared to the ACCO reference design, extend MSB)
                <br/>1 = 6 db (signal level multiplied by 2, one extra LSB)
            </comment>
        </bits>
    </reg>
    <reg name='pll_ctrl' protect='rw'>
        <comment>This register is protected. (see sys_ctrl)
        </comment>
        <bits name='pll_pd_n' access='rw' rst='0' pos='0'>
            
            <options>
                <default/>
                <option name='ENABLE' value='1'><comment>power on</comment></option>

                <option name='DISABLE' value='0'><comment>power off</comment></option>
            </options>
        
            <comment>PLL power down, active low. This field is r/w and not set/clr. A wake up pulse from LPS will automatically set the bit to '1'.
             </comment>
        </bits>
        <bits name='pll_locked' access='r' rst='0' pos='1'>
            <comment>PLL lock status.
                <br/>Reading this register returns the PLL lock status.
                <br/>0 = Unlocked
                <br/>1 = Locked
            </comment>
        </bits>
        <bits name='pll_bypass' access='rw' rst='0' pos='2'>
            <comment>PLL bypass.
                <br/>0 = Disable (use PLL clock)
                <br/>1 = Enable (use RF clock)
            </comment>
        </bits>
        <bits name='pll_div2_disable' access='rw' rst='0' pos='3'>
            <comment>Disable the division by 2 on the PLL input clock.
                <br/>0 = Disable OFF (division applied on the PLL input clock) 
                <br/>1 = Disable ON (division NOT applied on the PLL input clock)
            </comment>
        </bits>
        <bits name='pll_cp_tune' display='bin' access='rw' rst='0x0' pos='5:4'>
            <comment>PLL Charge Pump Tuning. 
                <br/>The control bits allow the trimming of the CP current reference according to the table below.
            </comment>
            <options>
                <default/>
                <option name='0_PERCENT' value='0b00'>
                    <comment>
                        0 uA
                    </comment>
                </option>
                <option name='75_PERCENT' value='0b01'>
                    <comment>
                        9.37 uA
                    </comment>
                </option>
                <option name='100_PERCENT' value='0b10'>
                    <comment>
                        12.5 uA
                    </comment>
                </option>
                <option name='125_PERCENT' value='0b11'>
                    <comment>
                        15.62 uA
                    </comment>
                </option>
            </options>
        </bits>
        <bits name='pll_rst_lock' access='rw' rst='0' pos='6'>
            <comment>Reset PLL lock status.
                <br/>Writing a 1 to this bit will reset the PLL lock status.
            </comment>
        </bits>
        
        <bits name='pll_in_source' access='rw' rst='0' pos='8'>
            <options>
                <default/>
                <option name='ClockSquarer' value='0'/>
                <option name='Ext' value='1'/>
            </options>
            <comment>The pll clock input.
                <br/>Note: the divider by 2 in only on the ClockSquarer input path. So pll_div2_disable is ignored when selecting clock Ext input.
            </comment>
        </bits>
        <bits name='pll_sys_eon' access='rw' rst='0' pos='9'>
            <options>
                <default/>
                <option name='ENABLE' value='0'/>
                <option name='No_Clock' value='1'/>
            </options>
        
            <comment>PLL output enable to system clock, active low. This field is r/w and not set/clr. A wake up pulse from LPS will automatically set the bit to '0'.
            </comment>
        </bits>

        <bits name='pll_ext_eon' access='rw' rst='0' pos='10'>
            <options>
                <default/>
                <option name='ENABLE' value='0'/>
                <option name='No_Clock' value='1'/>
            </options>
        
            <comment>PLL output enable to ext clock, active low.
            </comment>
        </bits>
        
    </reg>
    <reg name='pa_afc_gp_ctrl_set' protect='rw'>
        <bits name='padac_reset_release' access='rs' rst='0' pos='0'> 
            <comment>A general asynchronous master reset is applied to all digital gates.
                <br/>Writing a 1 to this bit will release the reset of the PA_DAC macro.
                <br/>Reading this register returns the reset state.
                <br/>0 = Reset mode
                <br/>1 = Out of reset mode
            </comment>
        </bits>
        <bits name='afc_reset_release' access='rs' rst='0' pos='1'> 
            <comment>A general asynchronous master reset is applied to all digital gates.
                <br/>Writing a 1 to this bit will release the reset of the AFC_DAC macro.
                <br/>Reading this register returns the reset state.
                <br/>0 = Reset mode
                <br/>1 = Out of reset mode
            </comment>
        </bits>
        <bits name='gpadc_reset_release' access='rs' rst='0' pos='2'> 
            <comment>A general asynchronous master reset is applied to all digital gates.
                <br/>Writing a 1 to this bit will release the reset of the GP_ADC macro.
                <br/>Reading this register returns the reset state.
                <br/>0 = Reset mode
                <br/>1 = Out of reset mode
            </comment>
        </bits>
        <bits name='padac_enable' access='rs' rst='0' pos='16'>
            <comment>Writing a 1 to this bit will enable the PA_DAC
                <br/>
                <br/>Reading this register returns the state of the PA_DAC enable bit 
                <br/>0 = Disable (power off)
                <br/>1 = Enable (power on)
            </comment>
        </bits>
        <bits name='afc_enable' access='rs' rst='0' pos='17'>
            <comment>Writing a 1 to this bit will enable the AFC_DAC
                <br/>
                <br/>Reading this register returns the state of the AFC_DAC enable bit 
                <br/>0 = Disable (power off)
                <br/>1 = Enable (power on)
            </comment>
        </bits>
        <bits name='gpadc_enable' access='rs' rst='0' pos='18'>
            <comment>Writing a 1 to this bit will enable the GP_ADC
                <br/>
                <br/>Reading this register returns the state of the GP_ADC enable bit 
                <br/>0 = Disable (power off)
                <br/>1 = Enable (power on)
            </comment>
        </bits>
    </reg>
    <reg name='pa_afc_gp_ctrl_clr' protect='rw'>
        <bits name='padac_reset_n' access='rc' rst='0' pos='0'> 
            <comment>A general asynchronous master reset is applied to all digital gates.
                <br/>Writing a 1 to this bit will put PA_DAC macro in reset state.
                <br/>Reading this register returns the reset state.
                <br/>0 = Reset mode
                <br/>1 = Out of reset mode
            </comment>
        </bits>
        <bits name='afc_reset_n' access='rc' rst='0' pos='1'> 
            <comment>A general asynchronous master reset is applied to all digital gates.
                <br/>Writing a 1 to this bit will put AFC_DAC macro in reset state.
                <br/>Reading this register returns the reset state.
                <br/>0 = Reset mode
                <br/>1 = Out of reset mode
            </comment>
        </bits>
        <bits name='gpadc_reset_n' access='rc' rst='0' pos='2'> 
            <comment>A general asynchronous master reset is applied to all digital gates.
                <br/>Writing a 1 to this bit will put GP_ADC_DAC macro in reset state.
                <br/>Reading this register returns the reset state.
                <br/>0 = Reset mode
                <br/>1 = Out of reset mode
            </comment>
        </bits>
        <bits name='padac_disable' access='rc' rst='0' pos='16'>
            <comment>Writing a 1 to this bit will disable the PA_DAC
                <br/>
                <br/>Reading this register returns the state of the PA_DAC enable bit 
                <br/>0 = Disable (power off)
                <br/>1 = Enable (power on)
            </comment>
        </bits>
        <bits name='afc_disable' access='rc' rst='0' pos='17'>
            <comment>Writing a 1 to this bit will disable the AFC_DAC
                <br/>
                <br/>Reading this register returns the state of the AFC_DAC enable bit 
                <br/>0 = Disable (power off)
                <br/>1 = Enable (power on)
            </comment>
        </bits>
        <bits name='gpadc_disable' access='rc' rst='0' pos='18'>
            <comment>Writing a 1 to this bit will disable the GP_ADC
                <br/>
                <br/>Reading this register returns the state of the GP_ADC enable bit 
                <br/>0 = Disable (power off)
                <br/>1 = Enable (power on)
            </comment>
        </bits>
    </reg>
    <reg name='pa_afc_gp_calib' protect='rw'>
        <bits name='comm_bg_enable' access='rw' rst='0' pos='0'>
            <comment>comm_bg_enable is the Bandgap enable bit. 
                <br/>This bandgap is used by the PA_DAC, the AFC_DAC and the GP_ADC
                <br/>0 = Disable (power off)
                <br/>1 = Enable (power on)
            </comment>
        </bits>
        <bits name='comm_bg_startup' access='rw' rst='0' pos='1'>
            <comment>This digital signal is used to speed up the recover of the bandgap from a PD mode or at the start up. It has to be used with the comm_bg_ok signal. if comm_bg_ok is not set within T0=100 ms the micro controller will set the comm_bg_startup for T1=100 ms.
            <br/><center><img src='./ana_ctrl_au_bg_startup.gif'/></center>
            </comment>
        </bits>
        <bits name='comm_bg_ok' access='r' pos='2'>
            <comment>This signal is set by the bandgap after the startup when the output voltage is stable.
            </comment>
        </bits>
        <bits name='comm_bg_ctrl' display='hex' access='rw' rst='0x0' pos='9:4'>
            <comment>comm_bg_ctrl[3:0]: BANDGAP TRIMMING These bits are used for the bandgap trimming according to the table below:
                <br/>
                <br/>0000 649.8mV
                <br/>0001 659.5mV
                <br/>0010 669.1mV
                <br/>0011 678.7mV
                <br/>0100 688.1mV
                <br/>0101 697.9mV (normal value)
                <br/>0110 707.5mV
                <br/>0111 717.1mV
                <br/>1000 726.8mV
                <br/>1001 736.4mV
                <br/>1010 746mV
                <br/>1011 755.6mV
                <br/>1100 765.2mV
                <br/>1101 774.8mV
                <br/>1110 784.4mV
                <br/>1111 794mV
                <br/>
                <br/>comm_bg_ctrl[5:4]: REFERENCE CURRENT TRIMMING
                <br/>The control bits allow the trimming of the current reference according to the table below:
                <br/>
                <br/>00 0 uA
                <br/>01 9.36 uA (75%)
                <br/>10 12.48 uA (100%) (normal value)
                <br/>11 15.6 uA (125%)
            </comment>
        </bits>
    </reg>
    <reg name='ana_clk_ctrl' protect='rw'>
        <bits name='rf_rx_clk_6m5_pol' access='rw' rst='0x1' pos='0'>
            <comment>Clock Polarity for RF_Rx Clock (6,5 MHz)
                <br/>1 = Inverted
            </comment>
        </bits>
        <bits name='rf_rx_clk_6m5_en_mode' access='rw' rst='0x1' pos='1'>
            <comment>Enable mode for RF_Rx Clock (6,5 MHz)
                <br/>0 = Auto
                <br/>1 = Manual
            </comment>
        </bits>
        <bits name='rf_tx_clk_4m33_pol' access='rw' rst='0x1' pos='2'>
            <comment>Clock Polarity for RF_Tx Clock (4,33 MHz)
                <br/>1 = Inverted
            </comment>
        </bits>
        <bits name='rf_tx_clk_4m33_en_mode' access='rw' rst='0x1' pos='3'>
            <comment>Enable mode for RF_Tx Clock (4,33 MHz)
                <br/>0 = Auto
                <br/>1 = Manual
            </comment>
        </bits>
        <bits name='au_clk_520k_pol' access='rw' rst='0x1' pos='4'>
            <comment>Clock Polarity for AU_Rx Clock (520 KHz)
                <br/>1 = Inverted
            </comment>
        </bits>
        <bits name='au_clk_40k_pol' access='rw' rst='0x1' pos='6'>
            <comment>Clock Polarity for AU_Tx Clock (40 KHz)
                <br/>1 = Inverted
            </comment>
        </bits>
        <bits name='au_clk_520k_40k_en_mode' access='rw' rst='0x1' pos='7'>
            <comment>Enable mode for AU_Rx Clock (520 KHz)
                <br/>0 = Auto
                <br/>1 = Manual
            </comment>
        </bits>
        <bits name='gpadc_clk_div' display='hex' access='rw' rst='0x1f' pos='12:8'>
            <comment>Clock divider for GPADC Clock. The clock is divided by 2*(n+1) from the 26 MHz clock. The maximum frequency is 1,625 MHz, so the minimum register value is 7: 2*(7+1) = 16; 26/16 = 1,625.
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name='gpadc_clk_pol' access='rw' rst='0x1' pos='14'>
            <comment>Clock Polarity for GPADC Clock
                <br/>1 = Inverted
            </comment>
        </bits>
        <bits name='gpadc_clk_en_mode' access='rw' rst='0x1' pos='15'>
            <comment>Enable mode for GPADC Clock
                <br/>0 = Auto
                <br/>1 = Manual
            </comment>
        </bits>
        <bits name='afc_clk_div' display='hex' access='rw' rst='0xff' pos='23:16'>
            <comment>Clock divider for AFC Clock. The clock is divided by 2*(n+1) from the 26 MHz clock
            </comment>
            <options><mask/><shift/><default/></options>
        </bits>
        <bits name='afc_clk_pol' access='rw' rst='0x1' pos='24'>
            <comment>Clock Polarity for AFC Clock
                <br/>1 = Inverted
            </comment>
        </bits>
        <bits name='afc_clk_en_mode' access='rw' rst='0x1' pos='25'>
            <comment>Enable mode for AFC Clock
                <br/>0 = Auto
                <br/>1 = Manual
            </comment>
        </bits>
        <bits name='pa_clk_1m08_pol' access='rw' rst='0x1' pos='28'>
            <comment>Clock Polarity for PA Clock (1.08 Mhz)
                <br/>1 = Inverted
            </comment>
        </bits>
        <bits name='pa_clk_1m08_en_mode' access='rw' rst='0x1' pos='29'>
            <comment>Enable mode for PA Clock (1.08 Mhz)
                <br/>0 = Auto
                <br/>1 = Manual
            </comment>
        </bits>
    </reg>
    <reg name='ana_clk_man_en_set' protect='rw'>
       <bits name='rf_rx_clk_6m5_enable' access='rs' rst='0x1' pos='1'>
           <comment>Writing a 1 to this bit will enable the RF ADC analog clock if the enable mode is manual.
                <br/>Reading this register returns the enable state (discarded in auto gating mode). 
                <br/>0 = clock off
                <br/>1 = clock on
            </comment>
        </bits>
        <bits name='rf_tx_clk_4m33_enable' access='rs' rst='0x1' pos='3'>
           <comment>Writing a 1 to this bit will enable the RF DAC analog clock and the RFIF_Tx clock if the enable mode is manual.
                <br/>Reading this register returns the enable state (discarded in auto gating mode). 
                <br/>0 = clock off
                <br/>1 = clock on
            </comment>
        </bits>
        <bits name='au_clk_520k_40k_enable' access='rs' rst='0x1' pos='7'>
           <comment>Writing a 1 to this bit will enable the AU DAC and ADC analog clocks if the enable mode is manual.
                <br/>Reading this register returns the enable state (discarded in auto gating mode). 
                <br/>0 = clock off
                <br/>1 = clock on
            </comment>
        </bits>
        <bits name='gpadc_clk_enable' access='rs' rst='0x1' pos='15'>
            <comment>Writing a 1 to this bit will enable the GPADC analog clock and the GPADC_IF clock if the enable mode is manual.
                <br/>Reading this register returns the enable state (discarded in auto gating mode). 
                <br/>0 = clock off
                <br/>1 = clock on
             </comment>
        </bits>
        <bits name='afc_clk_enable' access='rs' rst='0x1' pos='25'>
            <comment>Writing a 1 to this bit will enable the AFCDAC analog clock and the AFC_IF clock if the enable mode is manual.
                <br/>Reading this register returns the enable state (discarded in auto gating mode). 
                <br/>0 = clock off
                <br/>1 = clock on
             </comment>
        </bits>
        <bits name='pa_clk_1m08_enable' access='rs' rst='0x1' pos='29'>
            <comment>Writing a 1 to this bit will enable the PADAC analog clock and the PA_IF clock if the enable mode is manual.
                <br/>Reading this register returns the enable state (discarded in auto gating mode). 
                <br/>0 = clock off
                <br/>1 = clock on
             </comment>
        </bits>
        <bits name='soft_reset_release' access='rs' rst='0x1' pos='31'>
            <comment>Writing a 1 to this bit will release the soft reset to the analog acco frontend.
                <br/>Reading this register returns the soft reset state. 
                <br/>0 = Reset mode
                <br/>1 = Out of reset mode
             </comment>
        </bits>
    </reg>
    <reg name='ana_clk_man_en_clr' protect='rw'>
       <bits name='rf_rx_clk_6m5_disable' access='rc' rst='0x1' pos='1'>
           <comment>Writing a 1 to this bit will disable the RF ADC analog clock if the enable mode is manual.
                <br/>Reading this register returns the enable state (discarded in auto gating mode). 
                <br/>0 = clock off
                <br/>1 = clock on
            </comment>
        </bits>
        <bits name='rf_tx_clk_4m33_disable' access='rc' rst='0x1' pos='3'>
           <comment>Writing a 1 to this bit will disable the RF DAC analog clock and the RFIF_Tx clock if the enable mode is manual.
                <br/>Reading this register returns the enable state (discarded in auto gating mode). 
                <br/>0 = clock off
                <br/>1 = clock on
            </comment>
        </bits>
        <bits name='au_clk_520k_40k_disable' access='rc' rst='0x1' pos='7'>
           <comment>Writing a 1 to this bit will disable the AU DAC and ADC analog clocks if the enable mode is manual.
                <br/>Reading this register returns the enable state (discarded in auto gating mode). 
                <br/>0 = clock off
                <br/>1 = clock on
            </comment>
        </bits>
        <bits name='gpadc_clk_disable' access='rc' rst='0x1' pos='15'>
            <comment>Writing a 1 to this bit will disable the GPADC analog clock and the GPADC_IF clock if the enable mode is manual.
                <br/>Reading this register returns the enable state (discarded in auto gating mode). 
                <br/>0 = clock off
                <br/>1 = clock on
             </comment>
        </bits>
        <bits name='afc_clk_disable' access='rc' rst='0x1' pos='25'>
            <comment>Writing a 1 to this bit will disable the AFCDAC analog clock and the AFC_IF clock if the enable mode is manual.
                <br/>Reading this register returns the enable state (discarded in auto gating mode). 
                <br/>0 = clock off
                <br/>1 = clock on
             </comment>
        </bits>
        <bits name='pa_clk_1m08_disable' access='rc' rst='0x1' pos='29'>
            <comment>Writing a 1 to this bit will disable the PADAC analog clock and the PA_IF clock if the enable mode is manual.
                <br/>Reading this register returns the enable state (discarded in auto gating mode). 
                <br/>0 = clock off
                <br/>1 = clock on
             </comment>
        </bits>
        <bits name='soft_reset_n' access='rc' rst='0x1' pos='31'>
            <comment>Writing a 1 to this bit will put the analog acco frontend in reset.
                <br/>Reading this register returns the soft reset state. 
                <br/>0 = Reset mode
                <br/>1 = Out of reset mode
             </comment>
        </bits>
    </reg>
    <reg name='ana_prod_test_mode' protect='rw'>
        <bits name='test_mode_sel' display='hex' access='rw' rst='0x0' pos='2:0'>
            <comment>Analog test selection, only used for production test. Allows accessing the selected macro through external pads.
             </comment>
            <options linkenum='Ana_Test_Modes'>
                <default/>
                <mask/>
                <shift/>
            </options>
        </bits>
        <bits name='gpadc_sel_test' display='hex' access='rw' rst='0x0' pos='13:8'>
            <comment>GP ADC MUX selector; This field is used only when GP_ADC test mode bit is selected in test_mode_select register.
                <br/>The GP ADC input is muxed by gpadc_sel and can come from:
                <br/>gpadc_mux_in[00]; From GP_ADC_IN_0 PAD
                <br/>gpadc_mux_in[01]; From GP_ADC_IN_1 PAD
                <br/>gpadc_mux_in[02]; From GP_ADC_IN_2 PAD
                <br/>gpadc_mux_in[03]; From GP_ADC_IN_3 PAD
                <br/>gpadc_mux_in[04]; From test_daca_outp PIN
                <br/>gpadc_mux_in[05]; From test_daca_outn PIN
                <br/>gpadc_mux_in[06]; From test_au_vbg PIN
                <br/>gpadc_mux_in[07]; From test_sd_inpa PIN
                <br/>gpadc_mux_in[08]; From test_sd_inna PIN
                <br/>gpadc_mux_in[09]; From testAAI_P PIN
                <br/>gpadc_mux_in[10]; From testAAI_N PIN
                <br/>gpadc_mux_in[11]; From testAAQ_P PIN
                <br/>gpadc_mux_in[12]; From testAAQ_N PIN
                <br/>gpadc_mux_in[13]; From testAGND_I PIN
                <br/>gpadc_mux_in[14]; From testADCP_I PIN
                <br/>gpadc_mux_in[15]; From testADCN_I PIN
                <br/>gpadc_mux_in[16]; From testDACP_I PIN
                <br/>gpadc_mux_in[17]; From testDACN_I PIN
                <br/>gpadc_mux_in[18]; From testAGND_Q PIN
                <br/>gpadc_mux_in[19]; From testADCP_Q PIN
                <br/>gpadc_mux_in[20]; From testADCN_Q PIN
                <br/>gpadc_mux_in[21]; From testDACP_Q PIN
                <br/>gpadc_mux_in[22]; From testDACN_Q PIN
                <br/>gpadc_mux_in[23]; From testVBG PIN
                <br/>gpadc_mux_in[24]; From tst_dac_outip PIN
                <br/>gpadc_mux_in[25]; From tst_dac_outin PIN
                <br/>gpadc_mux_in[26]; From tst_lp_outpi PIN
                <br/>gpadc_mux_in[27]; From tst_lp_outni PIN
                <br/>gpadc_mux_in[28]; From tst_agndi PIN
                <br/>gpadc_mux_in[29]; From tst_vrefi PIN
                <br/>gpadc_mux_in[30]; From tst_dac_outqp PIN
                <br/>gpadc_mux_in[31]; From tst_dac_outqn PIN
                <br/>gpadc_mux_in[32]; From tst_lp_outpq PIN
                <br/>gpadc_mux_in[33]; From tst_lp_outnq PIN
                <br/>gpadc_mux_in[34]; From tst_agndq PIN
                <br/>gpadc_mux_in[35]; From tst_vrefq PIN
                <br/>gpadc_mux_in[36]; From tst_caprr PIN
                <br/>gpadc_mux_in[37]; From tst_refch PIN
                <br/>gpadc_mux_in[38]; From tst_refc PIN
                <br/>gpadc_mux_in[39]; From tst_vbg PIN
                <br/>gpadc_mux_in[40]; From afc_vrefp signal
                <br/>gpadc_mux_in[41]; From padac_vrefp signal
                <br/>gpadc_mux_in[42]; From AFC_OUT PAD
                <br/>gpadc_mux_in[43]; From TX_PWR PAD
                <br/>gpadc_mux_in[44]; From vbg signal
                <br/>gpadc_mux_in[45]; From vref_int signal
                <br/>gpadc_mux_in[46]; From tst_cmi2vi PIN
                <br/>gpadc_mux_in[47]; From tst_feedbki2vi PIN
                <br/>gpadc_mux_in[48]; From tst_cmi2vq PIN
                <br/>gpadc_mux_in[49]; From tst_feedbki2vq PIN
                <br/>gpadc_mux_in[50]; From tst_trimcap[1]; PIN
                <br/>gpadc_mux_in[51]; From tst_trimcap[2]; PIN
                <br/>gpadc_mux_in[52]; From tst_trimcap[3]; PIN
                <br/>gpadc_mux_in[53]; From tst_trimcap[4]; PIN
                <br/>gpadc_mux_in[54]; From tst_trimcap[5]; PIN
                <br/>gpadc_mux_in[55]; From tst_trimcap[6]; PIN
                <br/>gpadc_mux_in[56]; From tst_trimcap[7]; PIN
                <br/>gpadc_mux_in[57]; From tst_trimcap[8]; PIN
                <br/>gpadc_mux_in[58]; From test_au_agnd PIN
                <br/>gpadc_mux_in[59]; Not Connected
                <br/>gpadc_mux_in[60]; Not Connected
                <br/>gpadc_mux_in[61]; Not Connected
                <br/>gpadc_mux_in[63]; Not Connected
            </comment>
        </bits>
        <bits name='gpadc_eoc' access='r' pos='15'>
            <comment>GPADC End Of Convertion. 
                <br/>0 = conversion not finished
                <br/>1 = conversion finished
            </comment>
        </bits>
        <bits name='tx_on_test' access='rw' rst='0x0' pos='16'>
            <comment>Transmit power on control pin Active HIGH. This field is used only when Tx_DAC test mode is selected in test_mode_select register. 
            <br/>Hi -> 1 = ON, used in combination with the rx_on and the tx_deep_pd, see table POWER MANAGEMENT. 
            </comment>
        </bits>
        <bits name='tx_oen_test' access='rw' rst='0x0' pos='17'>
            <comment>Transmit Output Enable. This field is used only when Tx_DAC test mode is selected in test_mode_select register.
                <br/>Used in combination with tx_lp_pd, when HI analog Outputs are in Hi Impedance mode, see table below:
                <br/>
                <br/><table>
                <tr><td>tx_oen</td><td>tx_lp_pd</td><td>Mode</td></tr>
                <tr><td>0<td/>1<td/>Normal Mode</td></tr>
                <tr><td>0<td/>0<td/>LP in Power Down</td></tr>
                <tr><td>1<td/>0<td/>High Impedance</td></tr>
                <tr><td>1<td/>1<td/>Not used</td></tr>
                </table>
            </comment>
        </bits>
        <bits name='tx_lp_pd_test' access='rw' rst='0x0' pos='18'>
            <comment>LP filter enable bit in test mode. 
                <br/>0 = Disable
                <br/>1 = Enable
            </comment>
        </bits>
        <bits name='rx_on_test' access='rw' rst='0x0' pos='24'>
            <comment>Receive power on control pin; Active HIGH 
                <br/>This field is used only when Rx_ADC test mode is selected in test_mode_select register.
            </comment>
        </bits>
    </reg>
    <reg name='ana_test_ctrl' protect='rw'>
        <bits name='pa_test1' access='rw' rst='0x0' pos='0'>
            <comment>Control the pa_test1 signal.
            </comment>
        </bits>
        <bits name='pa_test2' access='rw' rst='0x0' pos='1'>
            <comment>Control the pa_test2 signal.
            </comment>
        </bits>
        <bits name='afc_test1' access='rw' rst='0x0' pos='4'>
            <comment>Control the afc_test1 signal.
            </comment>
        </bits>
        <bits name='afc_test2' access='rw' rst='0x0' pos='5'>
            <comment>Control the afc_test2 signal.
            </comment>
        </bits>
        <bits name='gp_test1' access='rw' rst='0x0' pos='8'>
            <comment>Control the gp_test1 signal.
            </comment>
        </bits>
        <bits name='gp_test2' access='rw' rst='0x0' pos='9'>
            <comment>Control the gp_test2 signal.
            </comment>
        </bits>
        <bits name='audio_test1' access='rw' rst='0x0' pos='12'>
            <comment>Control the audio_test1 signal.
            </comment>
        </bits>
        <bits name='audio_test2' access='rw' rst='0x0' pos='13'>
            <comment>Control the audio_test2 signal.
            </comment>
        </bits>
        <bits name='audio_test3' access='rw' rst='0x0' pos='14'>
            <comment>Control the audio_test3 signal.
            </comment>
        </bits>
        <bits name='tx_test1' access='rw' rst='0x0' pos='16'>
            <comment>Control the Tx Test1 signal.
            </comment>
        </bits>
        <bits name='tx_test2' access='rw' rst='0x0' pos='17'>
            <comment>Control the Tx Test2 signal.
            </comment>
        </bits>
        <bits name='tx_test3' access='rw' rst='0x0' pos='18'>
            <comment>Control the Tx Test3 signal.
            </comment>
        </bits>
        <bits name='tx_test4' access='rw' rst='0x0' pos='19'>
            <comment>Control the Tx Test4 signal.
            </comment>
        </bits>
        <bits name='rx_test1' access='rw' rst='0x0' pos='20'>
            <comment>Control the Rx Test1 signal.
            </comment>
        </bits>
        <bits name='rx_test2' access='rw' rst='0x0' pos='21'>
            <comment>Control the Rx Test2 signal.
            </comment>
        </bits>
        <bits name='rx_test3' access='rw' rst='0x0' pos='22'>
            <comment>Control the Rx Test3 signal.
            </comment>
        </bits>
        <bits name='rx_test4' access='rw' rst='0x0' pos='23'>
            <comment>Control the Rx Test4 signal.
            </comment>
        </bits>
            <comment>This register is used only for debug purpose or production, should not be used in functional mode.
            </comment>
    </reg>
</module>
</archive>

<archive relative='pa_ctrl.xml'>

<module name='pa_ctrl' category='Modem'>
    <reg name='ctrl' protect='rw'>
        <bits name='Enable' access='rw' rst='0' pos='0'>
            <comment>Enable PA Controller.
            </comment>
            <options>
                <option name='Enable' value='1'><comment>The PA is enabled.</comment></option>
                <option name='Disable' value='0'><comment>The PA is disabled.</comment></option>
            </options>
        </bits>
        <bits name='Ramp_Duration' access='rw' rst='1' pos='4'>
            <options>
                <option name='16QBits' value='1'><comment>The ramp duration is set  to 16 quarter bits (one new value every quarter bit).</comment></option>
                <option name='32QBits' value='0'><comment>The ramp will be outputted during 32 quarter bits (one new value every other quarter bit).</comment></option>
            </options>
        </bits>
        <bits name='Forced_Val' access='rw' rst='0' pos='25:16'>
            <comment>Value which could be forced to PA DAC
            </comment>
        </bits>
        <bits name='Force_H' access='rw' rst='0' pos='31'>
            <comment>When 1 the DAC is force to the forced value
            </comment>
        </bits>
    </reg>
    <reg name='Ramp' protect='rw' count='30'>
        <comment>The 5 available ramps are programmed thanks to 30 registers (6 registers per ramp).
            <br/>For ramp N
            <br/>Ramp[6*N+0] : Value index 0, 1, 2
            <br/>Ramp[6*N+1] : Value index 3, 4, 5
            <br/>Ramp[6*N+2] : Value index 6, 7, 8
            <br/>Ramp[6*N+3] : Value index 9, 10, 11
            <br/>Ramp[6*N+4] : Value index 12, 13, 14
            <br/>Ramp[6*N+5] : Value index 15 only
        </comment>
        <bits name='Value_0' access='rw' rst='0' pos='9:0'>
            <comment>Ramp Value for index 0, 3, 6, 9, 12, 15
            </comment>
        </bits>
        <bits name='Value_1' access='rw' rst='0' pos='19:10'>
            <comment>Ramp Value for index 1, 4, 7, 10, 13
            </comment>
        </bits>
        <bits name='Value_2' access='rw' rst='0' pos='29:20'>
            <comment>Ramp Value for index 2, 5, 8, 11, 14
            </comment>
        </bits>
    </reg>

</module>
</archive>

<archive relative='afc.xml'>

<module name='afc' category='Modem'>

    <var name='NB_AFC_DATA' value='12'/>
    
    <reg name='AFC_Ctrl' protect='rw'>
        <bits name='AFC_Remove' access='w' pos='0'>
            <comment>Writing a '1' to this bit will remove a single value from the tail of the FIFO,
                <br/>i.e. the last value written. It has no effect if the FIFO is empty. 
            </comment>
        </bits>
        <bits name='AFC_Flush_Fifo' access='w' pos='4'>
            <comment>Writing a '1' will flush the 8-words FIFO.
            </comment>
        </bits>
        <bits name='AFC_Fifo_Space' access='r' rst='0x0' pos='11:8'>
            <comment>Those bits indicate the number of space available in the Fifo.
            </comment>
        </bits>

        <bits name='AFC_Force_Data' access='rw' rst='0x0' pos='NB_AFC_DATA-1+16:16'>
            <comment>Data forced to the DAC when AFC_Force_Update is set to one. 
            </comment>
        </bits>
        <bits name='AFC_Force_Update' access='rw' rst='0x0' pos='31'>
            <comment>When '1' the AFC_Force_Data register is forced continuously on the AFC DAC and not require programming of TCU.
                <br/>0 disables the force update and '1' enables the force update.
            </comment>
        </bits>
    </reg>
    <reg name='AFC_Data' protect='rw'>
        <bits name='AFC_DATA' access='rw' rst='0x000' pos='NB_AFC_DATA-1:0'>
            <comment>Data to be written to the FIFO for the AFC DAC. Updated on the next TCU event. 
                <br/>A write in this register clear automatically the force Update mode.
            </comment>
        </bits>
    </reg>
</module>
</archive>

<archive relative='gpadc.xml'>

<module name='gpadc' category='Modem'>
  

  

  

  <reg name='gpadc_ch_ctrl' protect='rw'>
    <bits name='ch0_en' display='hex' access='rw' rst='0' pos='0'>
        <comment>Enable Analog GPADC channel 0.  
            <br/>0 = disable<br/>1 =enable
        </comment>
    </bits>
    <bits name='ch1_en' display='hex' access='rw' rst='0' pos='1'>
        <comment>Enable Analog GPADC channel 1.  
            <br/>0 = disable<br/>1 =enable
        </comment>
    </bits>
    <bits name='ch2_en' display='hex' access='rw' rst='0' pos='2'>
        <comment>Enable Analog GPADC channel 2.  
            <br/>0 = disable<br/>1 =enable
        </comment>
    </bits>
    <bits name='ch3_en' display='hex' access='rw' rst='0' pos='3'>
        <comment>Enable Analog GPADC channel 3.  
            <br/>0 = disable<br/>1 =enable
        </comment>
    </bits>
    <bitgroup name='ch_en'>
        <entry ref='ch0_en'/>
        <entry ref='ch1_en'/>
        <entry ref='ch2_en'/>
        <entry ref='ch3_en'/>
    </bitgroup>
    <bits name='ATP' display='hex' access='rw' rst='000' pos='10:8'>
        <options>
            <option name='122us' value='0'/>
            <option name='100ms' value='1'/>
            <option name='10ms' value='2'/>
            <option name='1ms' value='3'/>
            <option name='250ms' value='4'/>
            <option name='500ms' value='5'/>
            <option name='1s' value='6'/>
            <option name='2s' value='7'/>
            <default/>
        </options>
        <comment>GPADC active period. GPADC measures the enabled channels once during each period.
        </comment>
    </bits>
    <bits name='eoc' display='hex' access='r' rst='0' pos='16'>
      <comment>GPADC End of Conversion status bit.
            <br/>0 = GPADC not ready
            <br/>1 = GPADC conversion finish.
            <br/>in functional mode, this bit goes high when the first conversion of all enabled channels are done.
            <br/>in manual mode, this bit goes high when the channel selected by bits "manual_ch" is done.
            <br/>This bit stay always high and is reset when writing to GPADC_CH_CTRL register.
            <br/>Note: Wait until eoc='1' to write to GPADC ctrl register if one of the GPADC channels is on-going.  
        </comment>
    </bits>
    <bits name='busy' display='hex' access='r' rst='0' pos='20'>
      <comment>GPADC ctrl busy status.
            <br/>1 = not ready for a new write to GPADC ctrl register 
            <br/>0 = ready for a new write to GPADC ctrl register.
            <br/>This bit should be used to check if GPADC is well closed. 
        </comment>
    </bits>
    <bits name='manual_ch' display='hex' access='rw' rst='0x0' pos='29:24'>
        <comment>GP ADC MUX selector; This field is used only in GP_ADC manual mode, which requires ch0_en, ch1_en, ch2_en, ch3_en are all 0.
        <br/>    
        <br/>The GP ADC input is muxed by gpadc_sel and can come from:
        <br/>gpadc_mux_in[00]; From GP_ADC_IN_0 PAD
        <br/>gpadc_mux_in[01]; From GP_ADC_IN_1 PAD
        <br/>gpadc_mux_in[02]; From GP_ADC_IN_2 PAD
        <br/>gpadc_mux_in[03]; From GP_ADC_IN_3 PAD
        <br/>gpadc_mux_in[04]; From test_daca_outp PIN
        <br/>gpadc_mux_in[05]; From test_daca_outn PIN
        <br/>gpadc_mux_in[06]; From test_au_vbg PIN
        <br/>gpadc_mux_in[07]; From test_sd_inpa PIN
        <br/>gpadc_mux_in[08]; From test_sd_inna PIN
        <br/>gpadc_mux_in[09]; From testAAI_P PIN
        <br/>gpadc_mux_in[10]; From testAAI_N PIN
        <br/>gpadc_mux_in[11]; From testAAQ_P PIN
        <br/>gpadc_mux_in[12]; From testAAQ_N PIN
        <br/>gpadc_mux_in[13]; From testAGND_I PIN
        <br/>gpadc_mux_in[14]; From testADCP_I PIN
        <br/>gpadc_mux_in[15]; From testADCN_I PIN
        <br/>gpadc_mux_in[16]; From testDACP_I PIN
        <br/>gpadc_mux_in[17]; From testDACN_I PIN
        <br/>gpadc_mux_in[18]; From testAGND_Q PIN
        <br/>gpadc_mux_in[19]; From testADCP_Q PIN
        <br/>gpadc_mux_in[20]; From testADCN_Q PIN
        <br/>gpadc_mux_in[21]; From testDACP_Q PIN
        <br/>gpadc_mux_in[22]; From testDACN_Q PIN
        <br/>gpadc_mux_in[23]; From testVBG PIN
        <br/>gpadc_mux_in[24]; From tst_dac_outip PIN
        <br/>gpadc_mux_in[25]; From tst_dac_outin PIN
        <br/>gpadc_mux_in[26]; From tst_lp_outpi PIN
        <br/>gpadc_mux_in[27]; From tst_lp_outni PIN
        <br/>gpadc_mux_in[28]; From tst_agndi PIN
        <br/>gpadc_mux_in[29]; From tst_vrefi PIN
        <br/>gpadc_mux_in[30]; From tst_dac_outqp PIN
        <br/>gpadc_mux_in[31]; From tst_dac_outqn PIN
        <br/>gpadc_mux_in[32]; From tst_lp_outpq PIN
        <br/>gpadc_mux_in[33]; From tst_lp_outnq PIN
        <br/>gpadc_mux_in[34]; From tst_agndq PIN
        <br/>gpadc_mux_in[35]; From tst_vrefq PIN
        <br/>gpadc_mux_in[36]; From tst_caprr PIN
        <br/>gpadc_mux_in[37]; From tst_refch PIN
        <br/>gpadc_mux_in[38]; From tst_refc PIN
        <br/>gpadc_mux_in[39]; From tst_vbg PIN
        <br/>gpadc_mux_in[40]; From afc_vrefp signal
        <br/>gpadc_mux_in[41]; From padac_vrefp signal
        <br/>gpadc_mux_in[42]; From AFC_OUT PAD
        <br/>gpadc_mux_in[43]; From TX_PWR PAD
        <br/>gpadc_mux_in[44]; From vbg signal
        <br/>gpadc_mux_in[45]; From vref_int signal
        <br/>gpadc_mux_in[46]; From tst_cmi2vi PIN
        <br/>gpadc_mux_in[47]; From tst_feedbki2vi PIN
        <br/>gpadc_mux_in[48]; From tst_cmi2vq PIN
        <br/>gpadc_mux_in[49]; From tst_feedbki2vq PIN
        <br/>gpadc_mux_in[50]; From tst_trimcap[1]; PIN
        <br/>gpadc_mux_in[51]; From tst_trimcap[2]; PIN
        <br/>gpadc_mux_in[52]; From tst_trimcap[3]; PIN
        <br/>gpadc_mux_in[53]; From tst_trimcap[4]; PIN
        <br/>gpadc_mux_in[54]; From tst_trimcap[5]; PIN
        <br/>gpadc_mux_in[55]; From tst_trimcap[6]; PIN
        <br/>gpadc_mux_in[56]; From tst_trimcap[7]; PIN
        <br/>gpadc_mux_in[57]; From tst_trimcap[8]; PIN
        <br/>gpadc_mux_in[58]; From test_au_agnd PIN
        <br/>gpadc_mux_in[59]; Not Connected
        <br/>gpadc_mux_in[60]; Not Connected
        <br/>gpadc_mux_in[61]; Not Connected
        <br/>gpadc_mux_in[63]; Not Connected
      </comment>
    </bits>
    <bits name='manual_start' display='hex' access='w' rst='0' pos='31'>
        <comment>GPADC start measurement (only used in manual mode, which requires ch0_en, ch1_en, ch2_en, ch3_en are all 0), This bit is auto clear.
            <br/>Note: If GPADC is working in automatic mode, close GPADC before switching to manual GPADC measurement. This helps avoid on-going automatic measurement. 
        </comment>
    </bits>   
  </reg>

  <reg name='gpadc_ch0' protect='r'>
    <bits name='data' display='hex' access='r' rst='-' pos='9:0'>
      <comment>Data of GPADC channel 0 in functional mode. In manual mode,
          Data of GPADC test channel (selected from 0 to 63).
      </comment>
    </bits>
  </reg>

  <reg name='gpadc_ch1' protect='r'>
    <bits name='data' display='hex' access='r' rst='-' pos='9:0'>
      <comment>Data of GPADC channel 1.
      </comment>
    </bits>
  </reg>

  <reg name='gpadc_ch2' protect='r'>
    <bits name='data' display='hex' access='r' rst='-' pos='9:0'>
      <comment>Data of GPADC channel 2.
      </comment>
    </bits>
  </reg>
  
  <reg name='gpadc_ch3' protect='r'>
    <bits name='data' display='hex' access='r' rst='-' pos='9:0'>
      <comment>Data of GPADC channel 3.
      </comment>
    </bits>
  </reg>
  
  <reg name='gpadc_data' protect='r'>
    <bits name='data' display='hex' access='r' rst='-' pos='9:0'>
      <comment>Data of GPADC directly from Acco Analog Macro.
      </comment>
    </bits>
  </reg>

  
</module>
</archive>

<archive relative='aif.xml'>

<module name='aif' category='Baseband'>

  <enum name='AIF_Sampling_Rate'>
      <entry name='AIF_8k'/>
      <entry name='AIF_11k025'/>
      <entry name='AIF_12k'/>
      <entry name='AIF_16k'/>
      <entry name='AIF_22k05'/>
      <entry name='AIF_24k'/>
      <entry name='AIF_32k'/>
      <entry name='AIF_44k1'/>
      <entry name='AIF_48k'/>
  </enum>
    
  <var name='AIF_RX_FIFO_SIZE' value='4'/>
  <var name='AIF_TX_FIFO_SIZE' value='4'/>

  <reg name='data' protect='w'>
    <bits name='data0' access='rw' rst='-' pos='15:0'>
        <comment> This reg contains data to be read or written by IFC. 
            In mono mode, data0 is before data1.
            In stereo mode, data0 is in left channel.  
        </comment> 
    </bits>
    <bits name='data1' access='rw' rst='-' pos='31:16'>
        <comment> This reg contains data to be read or written by IFC. 
            In mono mode, data1 is after data0.
            In stereo mode, data1 is in right channel.  
      </comment> 
    </bits>
  </reg>

  <reg name='ctrl' protect='rw'>
    <bits name='Enable' access='rw' rst='0' pos='0'>
        <options>
            <default/>
            <option name='ENABLE' value='1'/>
            <option name='DISABLE' value='0'/>
        </options>
        
        <comment> Audio Interface Enable. 
            <br/> 0: if AIF_Tone[0] is also 0, AIF is disabled. 
            <br/> 1 = AIF Enabled. If AIF_Tone[0] is also '1', Tx fifo continue to fetch and distribute data 
                   from IFC when tone is enable. However, these data are not used.
        </comment> 
    </bits>

    <bits name='Tx Off' access='rw' rst='0' pos='4'>
        <options>
            <default/>
            <option name='Tx On' value='0'/>
            <option name='Tx Off' value='1'/>
        </options>
        
        <comment> Disable AIF Tx functions. 
            <br/> 0 = Both Tx Rx enabled.  
            <br/> 1 = Rx enabled only, Tx disabled. 
        </comment> 
    </bits>  

    <bits name='Parallel Out Set' access='rs' rst='0' pos='8'>
        <options>
            <default/>
            <option name='SERL' value='0'/>            
            <option name='PARA' value='1'/>            
        </options>
        
        <comment> Selects parallel audio interface connected to analog front-end. 
            <br/> 0 = serial output.  
            <br/> 1 = parallel output.  
        </comment> 
    </bits>  
    
    <bits name='Parallel Out Clr' access='rc' rst='0' pos='9'>
        <options>
            <default/>
            <option name='SERL' value='0'/>            
            <option name='PARA' value='1'/>            
        </options>
        
        <comment> Selects parallel audio interface connected to analog front-end. 
            <br/> 0 = serial output.  
            <br/> 1 = parallel output.  
        </comment> 
    </bits>  

    <bits name='Parallel In Set' access='rs' rst='0' pos='10'>
        <options>
            <default/>
            <option name='SERL' value='0'/>            
            <option name='PARA' value='1'/>            
        </options>
        
        <comment> Selects parallel audio interface connected to analog front-end. 
            <br/> 0 = serial input.  
            <br/> 1 = parallel input.  
        </comment> 
    </bits>  
    
    <bits name='Parallel In Clr' access='rc' rst='0' pos='11'>
        <options>
            <default/>
            <option name='SERL' value='0'/>            
            <option name='PARA' value='1'/>            
        </options>
        
        <comment> Selects parallel audio interface connected to analog front-end. 
            <br/> 0 = serial input.  
            <br/> 1 = parallel input.  
        </comment> 
    </bits>  

    <bits name='Tx Parallel EXT' access='rw' rst='0' pos='12'>
        <comment> This bit indicates if the AIF output Tx parallel data to external stereo dac or to internal Acco dac.
            <br/> '0' = Tx Parallel 13-bit Data output to Internal Acco dac. 
            <br/> '1' = Tx Parallel 16-bit Data output to External stereo dac. 
        </comment> 
    </bits>      
    
    <bits name='out underflow' access='rc' rst='0' pos='16'>
        <comment> This bit indicates if the AIF had needed some data while the Out Fifo was empty.
            In case of data famine, the last available data will be sent again.
            <br/> Write one to clear the out_underflow status bit. This bit is auto clear. 
        </comment> 
    </bits>      

    <bits name='in overflow' access='rc' rst='0' pos='17'>
        <comment> This bit indicates if the AIF had received some data while the Input Fifo was full.
            If the Fifo In is full, the newly received data will be lost. 
            <br/> Write one to clear the in_overflow status bit. This bit is auto clear.
        </comment> 
    </bits>       

    <bits name='Loop back' access='rw' rst='0' pos='31'>
        <options>
            <default/>
            <option name='NORMAL' value='0'/>
            <option name='LOOPBACK' value='1'/>
        </options>
     
        <comment> Sets the loop back mode. The feature is for debug only and can not work in DAI mode. 
        </comment> 
    </bits>   
    
  </reg>

  
  <reg name='serial_ctrl' protect='rw'>

    <bits name='SERIAL MODE' access='rw' rst='00' pos='1:0'>
        <options>
            <default/>
            <option name='I2S_PCM' value='0'/>
            <option name='VOICE' value='1'/>
            <option name='DAI' value='2'/>
        </options>
        
        <comment> Configure serial AIF mode. "11" is reserved. 
            <br/> 
            <br/> When mode is set DAI, the bit Master Mode should be set to '1', 
            bit Endian_L set to '0'. Data should be sent out on falling edge, which 
            requires either Bclk_Pol = '0' and Half_Cycle_DLY = '1' or Bclk_Pol = '1'
            and Half_Cycle_DLY = '0'. Bits Tx_DLY and BCKOut_Gate must be configured 
            to '0' and '1'.
            <br/> The DAI mode must NOT be modified after AIF is enabled. 
            <br/>             
        </comment> 

    </bits>      
    <bits name='I2S IN SEL' access='rw' rst='0' pos='2'>
        <options>
            <default/>
            <option name='I2S IN 0' value='0'/>
            <option name='I2S IN 1' value='1'/>
        </options>
        
        <comment> Select AIF I2S input. 
        </comment> 
    </bits>       
    
    <bits name='MASTER MODE' access='rw' rst='1' pos='4'>
        <options>
            <default/>
            <option name='SLAVE' value='0'/>
            <option name='MASTER' value='1'/>
        </options>
        
        <comment> configure AIF works in master mode (LRCLK and BCK timing signals are generated internally)
            or slave mode (LRCLK and BCK timing signals are generated externally). 
        </comment> 
    </bits>  

    <bits name='LSB' access='rw' rst='0' pos='5'>
        <options>
            <default/>
            <option name='MSB' value='0'/>
            <option name='LSB' value='1'/>
        </options>
        
        <comment> When high, the output data format is with the least significant bit first. 
        </comment> 
    </bits>

    <bits name='LRCK Pol' access='rw' rst='0' pos='6'>
        <options>
            <default/>
            <option name='LEFT_H_RIGHT_L' value='0'/>
            <option name='LEFT_L_RIGHT_H' value='1'/>
        </options>
        
        <comment> configure LRCK polarity. 
            <br/> 0 = high level on LRCK means left channel, low level on LRCK means right channel.
            <br/> 1 = high level on LRCK means right channel, low level on LRCK means left channel. 
            <br/>
            <br/> Note: this bit should be set to '0' (LEFT_H_RIGHT_L) in voice mode.
        </comment> 
    </bits>

    <bits name='Rx_DLY' access='rw' rst='0' pos='9:8'>
        <options>
            <default/>
            <option name='ALIGN' value='0'/>
            <option name='DLY_1' value='1'/>
            <option name='DLY_2' value='2'/>
            <option name='DLY_3' value='3'/>
        </options>
        
        <comment> Indicates the delay between serial data in MSB and LRCK edge. 
            <br/> "00" = Digital audio in MSB is aligned with LRCLK edge.  
            <br/> "01" = Digital audio in MSB is 1 cycle delayed to LRCLK edge.
            <br/> "10" = Digital audio in MSB is 2 cycle delayed to LRCLK edge.
            <br/> "11" = Digital audio in MSB is 3 cycle delayed to LRCLK edge.
        </comment> 
    </bits>

    <bits name='Tx_DLY' access='rw' rst='0' pos='10'>
        <options>
            <default/>
            <option name='ALIGN' value='0'/>
            <option name='DLY_1' value='1'/>
        </options>
        
        <comment> configure the delay between serial data out MSB and LRCK edge. 
            <br/> "0" = Digital audio out MSB is aligned with LRCLK edge.  
            <br/> "1" = Digital audio out MSB is 1 cycle delayed to LRCLK edge.
        </comment> 
    </bits>

    <bits name='Tx_DLY_s' access='rw' rst='0' pos='11'>
        <options>
            <default/>
            <option name='NO DLY' value='0'/>
            <option name='DLY' value='1'/>
        </options>
        
        <comment> ONLY for slave mode: configure 1 cycle supplementary Tx delay. 
            <br/> "0" = No supplementary Tx delay.  
            <br/> "1" = One Cycle supplementary Tx delay.
        </comment> 
    </bits>
    
    <bits name='Tx_Mode' access='rw' rst='0' pos='13:12'>
        <options>
            <default/>
            <option name='STEREO_STEREO' value='0'/>
            <option name='MONO_STEREO_CHAN_L' value='1'/>
            <option name='MONO_STEREO_DUPLI' value='2'/>
        </options>
        <comment> Configure mono or stereo format for Audio data out.
                  This field is used both in serial mode or in parallel EXT mode. 
            <br/> "00" = stereo input from IFC, stereo output to pin.  
            <br/> "01" = mono input from IFC, stereo output in left channel to pin. 
                          This value is reserved in parallel EXT mode.
            <br/> "10" = mono input from IFC, stereo output duplicate in both channels to pin.  
            <br/> reserved.
            <br/>
            <br/> if AIF works in DAI or Voice mode, always select "00" mode STEREO_STEREO.
        </comment> 
    </bits>

    <bits name='Rx Mode' access='rw' rst='0' pos='14'>
        <options>
            <default/>
            <option name='STEREO_STEREO' value='0'/>
            <option name='STEREO_MONO_FROM_L' value='1'/>
        </options>
        <comment> Configure mono or stereo format for Audio data in. 
            <br/> 0 = stereo input from pin, stereo output to IFC. 
            <br/> 1 = stereo input from pin, mono input to IFC selected from left channel.
            <br/>
            <br/> Users can change LRCK polarity to choose mono input from right channel.
        </comment> 
    </bits>
        
    <bits name='BCK LRCK' access='rw' rst='0' pos='19:16'>
        <options>
            <default/>
            <option name='BCK LRCK 16' value='0'/>
            <option name='BCK LRCK 17' value='1'/>
            <option name='BCK LRCK 18' value='2'/>
            <option name='BCK LRCK 19' value='3'/>
            <option name='BCK LRCK 20' value='4'/>
            <option name='BCK LRCK 21' value='5'/>
            <option name='BCK LRCK 22' value='6'/>
            <option name='BCK LRCK 23' value='7'/>
            <option name='BCK LRCK 24' value='8'/>
            <option name='BCK LRCK 25' value='9'/>
            <option name='BCK LRCK 26' value='10'/>
            <option name='BCK LRCK 27' value='11'/>
            <option name='BCK LRCK 28' value='12'/>
            <option name='BCK LRCK 29' value='13'/>
            <option name='BCK LRCK 30' value='14'/>
            <option name='BCK LRCK 31' value='15'/>
        </options>
            
        <comment> configure the ratio of BCK and LRCK cycle from 16 to 31.
            <br/> Voice_Mode: "XXXX": each sample takes 16 + "XXXX" BCLK cycle.  
            <br/> Audio_Mode: "XXXX": each sample takes 2*(16 + "XXXX) BCLK cycle. 2 times than Voice Mode because in audio mode each sample occupies two channels. 
        </comment> 
    </bits>  

    <bits name='Bck Pol' access='rw' rst='0' pos='24'>
        <options>
            <default/>
            <option name='NORMAL' value='0'/>
            <option name='INVERT' value='1'/>
        </options>
        
        <comment> if Master Mode, invert BCLK out. if slave Mode, invert BCLK in.
        </comment> 
    </bits>   

    <bits name='Output Half Cycle DLY' access='rw' rst='0' pos='25'>
        <options>
            <default/>
            <option name='NO DLY' value='0'/>
            <option name='DLY' value='1'/>
        </options>
        
        <comment> delayed Audio output data or LRCK by half cycle.
        </comment> 
    </bits> 

    <bits name='Input Half Cycle DLY' access='rw' rst='0' pos='26'>
        <options>
            <default/>
            <option name='NO DLY' value='0'/>
            <option name='DLY' value='1'/>
        </options>
        
        <comment> delayed Audio input data by half cycle.
        </comment> 
    </bits>     
    
    <bits name='BckOut Gate' access='rw' rst='0' pos='28'>
        <options>
            <default/>
            <option name='NO GATE' value='0'/>
            <option name='GATED' value='1'/>
        </options>
        
        <comment> Sets the BckOut gating. This bit decide if AIF continue to output BCK clock after 16-bit data has been sent.
        </comment> 
    </bits>       
    
  </reg>
  

  <reg name='tone' protect='rw'>
    <bits name='Enable H' access='rw' rst='0' pos='0'>
        <options>
            <default/>
            <option name='DISABLE' value='0'/>
            <option name='ENABLE' value='1'/>
        </options>
        
        <comment>When this bit is set, the audio interface is enabled and a comfort tone or DTMF tone is output 
            on the audio interface instead of the regular data, even if the AIF_CTRL[0] enable bit is 0. 
            <br/> 0 = AIF is disabled if the AIF_CTRL[0] is also 0. 
            <br/> 1 = AIF is enabled and generates a tone.
        </comment>
    </bits>

    <bits name='Tone Select' access='rw' rst='0' pos='1'>
        <options>
            <default/>
            <option name='DTMF' value='0'/>
            <option name='COMFORT TONE' value='1'/>
        </options>
        
        <comment>Select whether a DTMF of a comfort tone is generated. 
        </comment>
    </bits>

    <bits name='DTMF Freq Col' access='rw' rst='0' pos='5:4'>
        <options>
            <default/>
            <option name='1209 Hz' value='0'/>
            <option name='1336 Hz' value='1'/>
            <option name='1477 Hz' value='2'/>
            <option name='1633 Hz' value='3'/>
        </options>  
        
        <comment>Frequency of the first DTMF sine wave.
        </comment>
    </bits>

    <bits name='DTMF Freq Row' access='rw' rst='0' pos='7:6'>
        <options>
            <default/>
            <option name='697 Hz' value='0'/>
            <option name='770 Hz' value='1'/>
            <option name='852 Hz' value='2'/>
            <option name='941 Hz' value='3'/>
        </options>  
        
        <comment>Frequency of the second DTMF sine wave. 
        </comment>
    </bits>
        
    <bits name='Comfort Freq' access='rw' rst='0' pos='9:8'>
        <options>
            <default/>
            <option name='425 Hz' value='0'/>
            <option name='950 Hz' value='1'/>
            <option name='1400 Hz' value='2'/>
            <option name='1800 Hz' value='3'/>
        </options>  
        
        <comment>Frequency of comfort tone. 
        </comment>
    </bits>
    
    
    <bits name='Tone Gain' access='rw' rst='0' pos='13:12'>
        <comment>Tone attenuation. The Comfort Tone or DTMF is attenuated according to this programmable gain. 
        </comment>
        <options>
            <default/>
            <option name='0 dB' value='0'/>
            <option name='m3 dB' value='1'/>
            <option name='m9 dB' value='2'/>
            <option name='m15 dB' value='3'/>
        </options>  
    </bits>
  </reg>

  <reg name='side_tone' protect='rw'>
    <bits name='Side Tone Gain' access='rw' rst='0' pos='3:0'>
        <comment>Side Tone attenuation. The side tone is attenuated according to this programmable gain.
            <br/> 0000 = mute.
            <br/> 0001 = -36 dB.
            <br/> 0010 = -33 dB. 
            <br/> 0011 = -30 dB.
            <br/> 0100 = -27 dB. 
            <br/> 0101 = -24 dB. 
            <br/> 0110 = -21 dB. 
            <br/> 0111 = -18 dB.
            <br/> 1000 = -15 dB.
            <br/> 1001 = -12 dB.
            <br/> 1010 = -9 dB.
            <br/> 1011 = -6 dB. 
            <br/> 1100 = -3 dB.
            <br/> 1101 = 0 dB. 
            <br/> 1110 = +3 dB. 
            <br/> 1111 = +6 dB. 
        </comment>
    </bits>
  </reg>
 
</module>
</archive>













<archive relative='granite_ip.xml'>


  <include file='globals.xml'/>
  <include file='global_macros.xml'/>

  

  <include file='bb_ahb_monitor.xml'/>
  <include file='bb_cp2.xml'/>
  <include file='bb_ifc.xml'/>
  <include file='bb_irq.xml'/>
  <include file='bb_sram.xml'/>
  <include file='comregs.xml'/>
  <include file='bcpu_cache.xml'/>
  <include file='bcpu_tag.xml'/>
  <include file='bist.xml'/>
  <include file='cipher.xml'/>
  <include file='debug_host.xml'/>
  <include file='debug_host_internals.xml'/>
  <include file='debug_uart.xml'/>
  <include file='dma.xml'/>
  <include file='mem_bridge.xml'/>
  <include file='debug_port.xml'/>
  <include file='gpio.xml'/>
  <include file='i2c_master.xml'/>
  <include file='itlv.xml'/>
  <include file='page_spy.xml'/>
  <include file='rf_if.xml'/>
  <include file='rf_spi.xml'/>
  <include file='sci.xml'/>
  <include file='spi.xml'/>
  <include file='sys_ahb_monitor.xml'/>
  <include file='sys_ctrl.xml'/>
  <include file='sys_ifc.xml'/>
  <include file='sys_irq.xml'/>
  <include file='tcu.xml'/>
  <include file='timer.xml'/>
  <include file='uart.xml'/>
  <include file='vitac.xml'/>
  <include file='xcor.xml'/>
  <include file='cp0.xml'/>
  <include file='regdef.xml'/>
  <include file='xcpu_cache.xml'/>
  <include file='xcpu_tag.xml'/>
  <include file='xcpu.xml'/>

  <include file='keypad.xml'/>
  <include file='pwm.xml'/>
  <include file='calendar.xml'/>


  <include file='ana_acco.xml'/>
  <include file='pa_ctrl.xml'/>
  <include file='afc.xml'/>
  <include file='gpadc.xml'/>


  <include file='aif.xml'/>


  <include file='usbc.xml'/>


  <include file='voc_ram.xml'/>
  <include file='voc_ahb.xml'/>
  <include file='voc_cfg.xml'/>



  <include file='lcdc.xml'/>


  <include file='sdmmc.xml'/>


  <include file='camera.xml'/>


  
  <instance name='INT_REG_DBG_HOST' type='debug_host_internal_registers' address='0x00000000'/>

  
  <instance name='CS0' type='ebc_cs0' address='0x01000000'/>
  <instance name='CS1' type='ebc_cs1' address='0x00000000'/>
  <instance name='CS2' type='ebc_cs2' address='0x00800000'/>
  <instance name='CS3' type='ebc_cs3' address='0x00900000'/>
  <instance name='CS4' type='ebc_cs4' address='0x00a00000'/>
  <instance name='MEM_FIFO' type='mem_FIFO' address='0x00a80000'/>

  <instance name='INT_SRAM' type='int_sram' address='0x00c00000'/>
  <instance name='INT_ROM' type='int_rom' address='0x00e00000'/>


  <instance name='USBC' type='usbc' address='0x00b40000'/>


  

  <var name='REG_SYS_APB_BASE' value='0x00b80000'><comment>System APB base</comment></var>

  <instance name='SYS_CTRL' type='sys_ctrl' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_SYS_CTRL'/>

  <instance name='SYS_IRQ' type='sys_irq' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_IRQ'/>

  <instance name='TIMER' type='timer' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_TIMER'/>

  <instance name='GPIO' type='gpio' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_GPIO'/>

  <instance name='MEM_BRIDGE' type='mem_bridge' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_EBC'/>

  <instance name='KEYPAD' type='keypad' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_KEYPAD'/>

  <instance name='PWM' type='pwm' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_PWM'/>

  <instance name='DMA' type='dma' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_DMA'/>

  <instance name='SCI' type='sci' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_SCI'/>

  <instance name='SPI' type='spi' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_SPI'/>

  <instance name='SPI2' type='spi' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_SPI2'/>

  <instance name='DEBUG_UART' type='debug_uart' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_DEBUG_UART'/>

  <instance name='UART' type='uart' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_UART'/>

  <instance name='UART2' type='uart' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_UART2'/>

  <instance name='I2C_MASTER' type='i2c_master' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_I2C'/>

  <instance name='RF_SPI' type='rf_spi' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_RF_SPI'/>

  <instance name='GPADC' type='gpadc' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_GPADC'/>
  
  <instance name='PA_CTRL' type='pa_ctrl' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_PA_AFC'/>
  
  <instance name='AFC' type='afc' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_PA_AFC + 0x800'/>

  <instance name='TCU' type='tcu' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_TCU'/>

  <instance name='SYS_IFC' type='sys_ifc' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_IFC'/>

  <instance name='PAGE_SPY' type='page_spy' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_PAGE_SPY'/>

  <instance name='DEBUG_PORT' type='debug_port' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_DEBUG_PORT'/>

  <instance name='XCPU' type='xcpu' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_XCPU_REG'/>
  
  <instance name='XCPU_TAG' type='xcpu_tag' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_XCPU_TAG'/>
  
  <instance name='XCPU_IDATA' type='xcpu_cache' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_XCPU_IDATA'/>
  
  <instance name='XCPU_DDATA' type='xcpu_cache' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_XCPU_DDATA'/>

  <instance name='SYS_AHB_MONITOR' type='sys_ahb_monitor' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_SYS_AHBC_MON'/>

  <instance name='BB_AHB_MONITOR' type='bb_ahb_monitor' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_BB_AHBC_MON'/>

  <instance name='SYS_BIST' type='bist' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_BIST'/>

  <instance name='SYS_COMREGS' type='comregs' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_COMREGS'/>

  <instance name='CALENDAR' type='calendar' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_CALENDAR'/>


  <instance name='ANA_ACCO_FE' type='ana_acco' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_ANA_FE'/>


  <instance name='LCDC' type='lcdc' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_LCDC'/>


  <instance name='SDMMC' type='sdmmc' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_SDMMC'/>


  <instance name='CAMERA' type='camera' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_CAMERA'/>



  
  <instance name='DEBUG_HOST' type='debug_host' address='REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_DEBUG_HOST'/>

  

  <instance name='BB_SRAM' type='bb_sram' address='0x00aa0000'/>
  
  <var name='REG_BB_APB_BASE' value='0x00ac0000'><comment>Baseband APB base</comment></var>

  <instance name='XCOR' type='xcor' address='REG_BB_APB_BASE + BB_APB_STEP * BB_ID_XCOR'/>

  <instance name='BB_IFC' type='bb_ifc' address='REG_BB_APB_BASE + BB_APB_STEP * BB_ID_IFC'/>
  
  <instance name='BB_IRQ' type='bb_irq' address='REG_BB_APB_BASE + BB_APB_STEP * BB_ID_IRQ'/>

  <instance name='ITLV' type='itlv' address='REG_BB_APB_BASE + BB_APB_STEP * BB_ID_ITLV'/>

  <instance name='VITAC' type='vitac' address='REG_BB_APB_BASE + BB_APB_STEP * BB_ID_VITERBI'/>

  <instance name='CIPHER' type='cipher' address='REG_BB_APB_BASE + BB_APB_STEP * BB_ID_A5'/>
  
  <instance name='RF_IF' type='rf_if' address='REG_BB_APB_BASE + BB_APB_STEP * BB_ID_RF'/>

  <instance name='AIF' type='aif' address='REG_BB_APB_BASE + BB_APB_STEP * BB_ID_AIF'/>

  <instance name='BB_CP2' type='bb_cp2' address='REG_BB_APB_BASE + BB_APB_STEP * BB_ID_CP2'/>

  <instance name='BB_BIST' type='bist' address='REG_BB_APB_BASE + BB_APB_STEP * BB_ID_BIST'/>

  <instance name='BCPU' type='xcpu' address='REG_BB_APB_BASE + BB_APB_STEP * BB_ID_BCPU_REG'/>

  <instance name='BCPU_TAG' type='bcpu_tag' address='REG_BB_APB_BASE + BB_APB_STEP * BB_ID_BCPU_TAG'/>
  
  <instance name='BCPU_IDATA' type='bcpu_cache' address='REG_BB_APB_BASE + BB_APB_STEP * BB_ID_BCPU_IDATA'/>
  
  <instance name='BCPU_DDATA' type='bcpu_cache' address='REG_BB_APB_BASE + BB_APB_STEP * BB_ID_BCPU_DDATA'/>

  <instance name='BB_COMREGS' type='comregs' address='REG_BB_APB_BASE + BB_APB_STEP * BB_ID_COMREGS'/>


  
  
  <var name='REG_VOC_BASE' value='0x00b00000'><comment>VOC AHB base</comment></var>

  <instance name='VOC_RAM' type='voc_ram' address='REG_VOC_BASE+0x00000000'/>
 
  <instance name='VOC_CFG' type='voc_cfg' address='REG_VOC_BASE+0x0001ff80'/>

  <instance name='VOC_AHB' type='voc_ahb' address='REG_VOC_BASE+0x00030000'/>


</archive>




<archive relative='regs.xml' >

<module name="regs">


<var name="GREENSTONE_GPIO_ONLY_NB" value="4"/>
<var name="GREENSTONE_GPIO_NB" value="32"/> 
<var name="GREENSTONE_GPO_NB" value="11"/> 
<var name="PROD_ID" value="0x1208"/>

    
    <enum name="GPIO_mapping">
        <entry name="PIN_CAM_RST" value="4"/>
        <entry name="PIN_CAM_PDN" value="5"/>
        <entry name="PIN_I2S_DI_1" value="6"/>
        <entry name="PIN_SPI_CS_1" value="7"/>
        <entry name="PIN_SLCD_DA" value="8"/>
        <entry name="PIN_SLCD_DC" value="9"/>
        <entry name="PIN_I2C_SDA" value="10"/>
        <entry name="PIN_I2C_SCL" value="11"/>
        <entry name="PIN_SLCD_CL" value="12"/>
        <entry name="PIN_CAM_PCLK" value="13"/>
        <entry name="PIN_CAM_HREF" value="14"/>
        <entry name="PIN_CAM_VSYNC" value="15"/>
        <entry name="PIN_UART2_RTS" value="16"/>
        <entry name="PIN_UART2_CTS" value="17"/>
        <entry name="PIN_UART2_TXD" value="18"/>
        <entry name="PIN_UART2_RXD" value="19"/>
        <entry name="PIN_UART1_CTS" value="20"/>
        <entry name="PIN_UART1_RTS" value="21"/>
        <entry name="PIN_SDMMC_CLK" value="22"/>
        <entry name="PIN_SDMMC_DATA0" value="23"/>
        <entry name="PIN_SDMMC_DATA1" value="24"/>
        <entry name="PIN_SDMMC_DATA2" value="25"/>
        <entry name="PIN_SDMMC_DATA3" value="26"/>
        <entry name="PIN_SDMMC_CMD" value="27"/>
        <entry name="PIN_LPSCO_1" value="28"/>
        <entry name="PIN_KEYOUT_5" value="29"/>
        <entry name="PIN_KEYIN_5" value="30"/>
        <entry name="PIN_TCO6" value="31"/>
    </enum>

    <reg name="CHIP_ID" protect="r">
        <bits name="METAL_ID" pos="9:0" access="r">
            <comment> ECO Identification number.
            </comment>
        </bits>
        <bits name="BOND_ID" pos="14:12" access="r">
            <comment>Bonding Identification number.
            </comment>
        </bits>
        <bits name="PROD_ID" pos="31:16" access="r">
            <comment>Product Identification number.
            </comment>
        </bits>
    </reg>
    
    <reg name="Build_Version" protect="r">
        <comment>This register contain the synthesis date and version
        </comment>
        <bits name="Major" pos="31:28" access="r" rst="no">
        </bits>
        <bits name="Year" pos="27:24" access="r" rst="no">
        </bits>
        <bits name="Month" pos="23:16" access="r" rst="no" display="hex">
        </bits>
        <bits name="Day" pos="15:8" access="r" rst="no" display="hex">
        </bits>
        <bits name="Build_Style" pos="5:4" access="r" rst="no">
            <options>
                <option name="FPGA" value ="0"/>
                <option name="CHIP" value ="1"/>
                <option name="FPGA_USB" value ="2"/>
                <option name="FPGA_GSM" value ="3"/>
            </options>
        </bits>
        <bits name="Build_Revision" pos="3:0" access="r" rst="no">
        </bits>
    </reg>

    <reg name="GPIO_Mode" protect="rw">
        <comment>Setting bit n to '1' selects GPIO Usage for PAD connected to GPIOn. Setting bit n to '0' selects Alt. 
        </comment>
        <bits name="GPIO_Mode" pos="GREENSTONE_GPIO_NB-1:GREENSTONE_GPIO_ONLY_NB" access="rw" rst="all1" cut="1" cutprefix="Mode" cutenum="GPIO_mapping" cutstart="0">
            <options>
                <option name="ALT" value ="0"/>
                <option name="GPIO" value ="1"/>
                <mask/><shift/><default/>
            </options>
        </bits>
    </reg>
    <reg name="Alt_mux_select" protect="rw">
        <bits name="Debug_Port" pos="1:0" access="rw" rst="1">
            <comment>Debug Data Bus setting
            </comment>
            <options>
                <option name="Debug" value="0"><comment>Gives access to Debug Bus features.</comment></option>
                <option name="Camera" value="1"><comment>Puts Camera port on Debug port.</comment></option>
                <option name="DAI" value="2"><comment>Puts DAI port on Debug port LSBs.</comment></option>
                <option name="DAI Simple" value="3"><comment>Puts DAI-Simple port on Debug port LSBs.</comment></option>
                <mask/>
            </options>
        </bits>
        <bits name="TCO_6" pos="2" access="rw" rst="0">
            <comment>TCO_6/RF_SPI_DI pin select
            </comment>
            <options>
                <option name="TCO_6" value="0"><comment>TCO6 selected.</comment></option>
                <option name="RF_SPI DI" value="1"><comment>RF_SPI_DI selected.</comment></option>
                <mask/>
            </options>
        </bits>
        <bits name="Xvr select" pos="3" access="rw" rst="0">
            <comment>Transceiver select for pin DIGRF_RXTX_EN and DIGRF_RXTX_DATA.
            </comment>
            <options>
                <option name="DigRF" value="0"><comment>DigRF selected.</comment></option>
                <option name="TCO" value="1"><comment>Digrf pin are connected to TCO_9 and TCO_7.</comment></option>
                <mask/>
            </options>
        </bits>
        <bits name="Strobe select" pos="4" access="rw" rst="0">
            <comment>DigRf Strobe pin mode select.
            </comment>
            <options>
                <option name="DigRF Strobe" value="0"></option>
                <option name="TCO_8" value="1"></option>
                <mask/>
            </options>
        </bits>

        <bits name="Memory Addess 23" pos="5" access="rw" rst="0">
            <comment>Memory MA[23] pin select
            </comment>
            <options>
                <option name="MA_23" value="0"></option>
                <option name="M_CS4" value="1"></option>
                <mask/>
            </options>
        </bits>
        <bits name="LSB Memory Addr bus" pos="6" access="rw" rst="0">
            <comment>LSB Memory address MA[15:0] bus select
            </comment>
            <options>
                <option name="Memory" value="0"></option>
                <option name="Parallel LCD" value="1"><comment>Select parallel LCD. When this option is selected, the serial LCD is not avalaible.</comment></option>
                <mask/>
            </options>
        </bits>
        <bits name="Memory CS2" pos="8:7" access="rw" rst="0">
            <comment>Memory CS_2 pin select
            </comment>
            <options>
                <option name="M_CS_2" value="0"></option>
                <option name="LCD_CS_0" value="1"></option>
                <option name="SPI_CS_2" value="2"></option>
                <mask/>
            </options>
        </bits>
        <bits name="Serial LCD_CE" pos="10:9" access="rw" rst="0">
            <comment>SLCD_CE pin select.
            </comment>
            <options>
                <option name="SLCD_CE" value="0"></option>
                <option name="LCD_CS_1" value="1"></option>
                <option name="M_CS_3" value="2"></option>
                <mask/>
            </options>
        </bits>
        <bits name="UART2" pos="11" access="rw" rst="0">
            <comment>UART2/UART1 functionality select.
            </comment>
            <options>
                <option name="UART2" value="0"></option>
                <option name="UART1" value="1"></option>
                <mask/>
            </options>
        </bits>
        <bits name="PWL0" pos="12" access="rw" rst="0">
            <comment>PWL0/GPO_7 pin select.
            </comment>
            <options>
                <option name="PWL0" value="0"></option>
                <option name="GPO_7" value="1"></option>
                <mask/>
            </options>
        </bits>
        <bits name="PWL1" pos="13" access="rw" rst="0">
            <comment>PWL1/GPO_6 pin select.
            </comment>
            <options>
                <option name="PWL1" value="0"></option>
                <option name="GPO_6" value="1"></option>
                <mask/>
            </options>
        </bits>

        <bits name="SDMMC" pos="14" access="rw" rst="0">
            <comment>SDMMC/SPI2 functionality select.
            </comment>
            <options>
                <option name="SDMMC" value="0"></option>
                <option name="SPI2" value="1"></option>
                <mask/>
            </options>
        </bits>
        <bits name="GPO" pos="15" access="rw" rst="0">
            <comment>GPO/SPI2 functionality select. SPI2 is available only if SDMMC (bit14 set to zero in alt_mux_select register). 
            </comment>
            <options>
                <option name="GPO" value="0"></option>
                <option name="SPI2" value="1"></option>
                <mask/>
            </options>
        </bits>
        <bits name="GPO_1" pos="16" access="rw" rst="0">
            <comment>GPO_1/SPI2_CS_1 pin select. SPI2 is available only if SDMMC (bit14 set to zero in alt_mux_select register).
            </comment>
            <options>
                <option name="GPO_1" value="0"></option>
                <option name="SPI2_CS_1" value="1"></option>
                <mask/>
            </options>
        </bits>

        <bits name="TCO_5" pos="17" access="rw" rst="0">
            <comment>TCO_5/GPO_10 pin select.
            </comment>
            <options>
                <option name="TCO_5" value="0"></option>
                <option name="GPO_10" value="1"></option>
                <mask/>
            </options>
        </bits>
        <bits name="TCO_4" pos="18" access="rw" rst="0">
            <comment>TCO_4/GPO_9 pin select.
            </comment>
            <options>
                <option name="TCO_4" value="0"></option>
                <option name="GPO_9" value="1"></option>
                <mask/>
            </options>
        </bits>
        <bits name="TCO_3" pos="19" access="rw" rst="0">
            <comment>TCO_3/GPO_8 pin select.
            </comment>
            <options>
                <option name="TCO_3" value="0"></option>
                <option name="GPO_8" value="1"></option>
                <mask/>
            </options>
        </bits>
       <bits name="KEYOUT_5" pos="20" access="rw" rst="0">
            <comment>KEYOUT_5/LPG pin select.
            </comment>
            <options>
                <option name="KEYOUT_5" value="0"></option>
                <option name="LPG" value="1"></option>
                <mask/>
            </options>
        </bits>
       <bits name="KEYIN_5" pos="21" access="rw" rst="0">
            <comment>KEYIN_5/PWT pin select.
            </comment>
            <options>
                <option name="KEYIN_5" value="0"></option>
                <option name="PWT" value="1"></option>
                <mask/>
            </options>
        </bits>
    </reg>
    <reg name="IO_Drive_Select1" protect="rw">
       <bits name="Data" pos="3:0" access="rw" rst="all0">
            <comment>D[15:0] bus drive select</comment>
       </bits>
       <bits name="LSB Memory Address" pos="7:4" access="rw" rst="all0">
            <comment>MA[15:0] bus drive select</comment>
       </bits>
       <bits name="MSB Memory Address" pos="11:8" access="rw" rst="all0">
            <comment>MA[22:16] bus drive select</comment>
       </bits>
       <bits name="MA_23" pos="15:12" access="rw" rst="all0">
            <comment>MA[23] drive select</comment>
       </bits>
       <bits name="M_CS0" pos="19:16" access="rw" rst="all0">
            <comment>M_CS0 drive select</comment>
       </bits>
       <bits name="M_CS1" pos="23:20" access="rw" rst="all0">
            <comment>M_CS1 drive select</comment>
       </bits>
       <bits name="M_CS2" pos="27:24" access="rw" rst="all0">
            <comment>M_CS2 drive select</comment>
       </bits>
       <bits name="M_CTRL" pos="31:28" access="rw" rst="all0">
            <comment>M_CRE, M_BE[1:0], M_ADV  drive select</comment>
       </bits>
    </reg>
    <reg name="IO_Drive_Select2" protect="rw">
       <bits name="M_CTRL_WE" pos="3:0" access="rw" rst="all0">
            <comment>M_WE and M_OE drive select</comment>
       </bits>
       <bits name="M_CLK" pos="7:4" access="rw" rst="all0">
            <comment>M_CLK drive select</comment>
       </bits>
       <bits name="Serial LCD" pos="11:8" access="rw" rst="all0">
            <comment>SLCD_CL, SLCD_CA, SLCD_CC drive select</comment>
       </bits>
       <bits name="Serial LCD_SCE" pos="15:12" access="rw" rst="all0">
            <comment>LCD_SCE/M_CS_3 drive select</comment>
       </bits>
       <bits name="Xvr domain" pos="19:16" access="rw" rst="all0">
            <comment>Transceiver domain drive select</comment>
       </bits>
    </reg>
    <reg name="ExtPll_Ctrl" protect="rw">
        <comment>Register protected by RiskyReg_Write_Unlocked_H (Cf. Sys_Ctrl).</comment>
        <bits name="ExtPll_Enable" pos="0" access="rw" rst="1">
            <comment>Mode of the Pll. This register is set to enable by the LPS_start_ExtPll_pulse_H.</comment>
            <options>
                <option name="Power_Down" value="1"></option>
                <option name="Enable" value="0"></option>
            </options>
        </bits>
        <bits name="ExtPll_Output_Enable" pos="4" access="rw" rst="1">
            <comment>Enables the output of the PLL. This register is set to enable by the LPS_start_ExtPll_pulse_H.</comment>
            <options>
                <option name="Enable" value="0"></option>
                <option name="Disable" value="1"></option>
            </options>
        </bits>
        <bits name="ExtPll_Bypass" pos="8" access="rw" rst="0">
            <options>
                <option name="Pass" value="0"><comment>In this mode the output of the PLL is its input clock divided by the proper dividers</comment></option> 
                <option name="Bypass" value="1"><comment>In this mode the output of the PLL is its input clock</comment></option>
            </options>
        </bits>
        <bits name="ExtPll_Locked" pos="12" access="r" rst="0">
            <comment>Indicates if the Pll managed to lock at 312MHz</comment>
            <options>
                <option name="Not_Locked" value="0"></option>
                <option name="Locked" value="1"></option>
            </options>
        </bits>
        <bits name="ExtPll_Clk_Fast_Enable" pos="16" access="rw" rst="0">
            <comment>Enables the Fast Clock from the ExtPll (Clock Gate Reg Resync).</comment>
            <options>
                <option name="Enable" value="1"></option>
                <option name="Disable" value="0"></option>
            </options>
        </bits>
        <bits name="ExtPll_Lock_Ctrl_Rst" pos="20" access="rw" rst="0">
            <comment>Resets the module which detects if the PLL has locked or not</comment>
            <options>
                <option name="No_Reset" value="0"></option>
                <option name="Reset" value="1"></option>
            </options>
        </bits>
    </reg>

    <reg name="ExtPll_Config" protect="rw">   
            <comment>Configuration of the Pll</comment>        
        <bits name="ExtPll_Input_Divider" pos="4:0" access="rw" rst="0">
            <comment>Input 5-bits divider value. The clock is multiplied by NR=R+2 , R being the actual value in this register.</comment>
        </bits>
        <bits name="ExtPll_Feedback_Divider" pos="16:8" access="rw" rst="0">
            <comment>Feedback 9-bits divider value. The clock is multiplied by NF=F+2 , F being the actual value in this register.</comment>
        </bits>
        <bits name="ExtPll_Output_Divider" pos="25:24" access="rw" rst="0">
            <comment>Ouput 2-bits divider value</comment>
           <options>
               <option name="Div_By_1" value="0"></option>
               <option name="Div_By_2" value="1"></option>
               <option name="Div_By_2_also" value="2"></option>
               <option name="Div_By_4" value="3"></option>
           </options> 
        </bits>
        <comment>PLL Output Clock Frequency Setting
           <br/>FOUT = [FIN * (NF * 2)] / [(NR * 2) * NO]
           <br/>Meanwhile, the following constraints must be followed :
           <ul>
           <li>800KHz &lt; Fref &lt; 8MHz</li>
           <li>200MHz &lt; FVCO &lt; 500MHz, FVCO &gt; 250MHz is preferred</li>
           </ul>
           where
           <br/>PLL's comparison frequency Fref = FIN/(NR*2).
           <br/>PLL's VCO frequency FVCO = FIN*(NF*2)/(NR*2).
        </comment> 
    </reg>

    <reg name="ExtPll_Dbg_Clk" protect="rw">
        <bits name="ExtPll_Dbg_Clk_Sel" pos="2:0" access="rw" rst="0">
            <comment>Configurates which clock is selected as debug_clock</comment>
            <options>
                <option name="Clk_To_PllAcco" value="0"><comment>Clk to PLL_Acco : 12 MHz</comment></option>
                <option name="Clk_USB" value="1"><comment>Clk USB : 48 MHz</comment></option>
                <option name="Clk_Stereo" value="2"><comment>Clk Stereo : 12/13 MHz % 2->16</comment></option>
                <option name="Clk_Camera" value="3"><comment>Clk Camera : 156/144 MHz % 2->12</comment></option>
                <option name="Au_ExtTx_Stb" value="4"><comment>Stereo Strobe</comment></option>
            </options>
        </bits>
    </reg>

    <reg name="CLK_CAMERA_OUT_CTRL" protect="rw">   
        <bits name="CLK_CAMERA_OUT_EN" pos="0" access="rw" rst="0">
            <comment>Clk camera out enable. </comment>
           <options>
               <option name="disable" value="0"></option>
               <option name="enable" value="1"></option>
           </options>
        </bits>    
        <bits name="CLK_CAMERA_DIV_SRC_SEL" pos="5:4" access="rw" rst="0">
            <comment>Selects from which clock the Clk camera is generated.</comment>
           <options>
               <option name="156 MHz" value="0"></option>
               <option name="144 MHz" value="1"></option>
               <option name=" 26 MHz" value="2"></option>
           </options>
        </bits>    
        <bits name="CLK_CAMERA_OUT_DIV" pos="11:8" access="rw" rst="15">
            <comment>Clock camera out divider. clock frequency = selected clock source frequency / (value + 2). See bit 4 CLK_CAMERA_OUT_SRC_SEL for source selection.  
            </comment>
            <options>
                <default/><mask/><shift/>
            </options>
        </bits>  
        <bits name="CLK_CAMERA_OUT_SRC_SEL" pos="13:12" access="rw" rst="0">
            <comment>Selection between the output of the divider, the 32K clock, or the 26M clock.</comment>
            <options>
                <option name="From divider" value="0"></option>
                <option name="From 32K" value="1"></option>
                <option name="From 26M" value="2"></option>
            </options>
        </bits>         
    </reg>
    
    <reg name="STEREO_DAC_CTRL_SET" protect="rw">   
        <bits name="AU_HPLPD" pos="0" access="rs" rst="1">
            <comment>Headphone left channel mixer and driver power down signal.</comment>
            <options>
                <option name="power up" value ="0"/>
                <option name="power down" value ="1"/>
            </options>
        </bits>    
        <bits name="AU_HPRPD" pos="1" access="rs" rst="1">
            <comment>Headphone right channel mixer and driver power down signal.</comment> 
            <options>
                <option name="power up" value ="0"/>
                <option name="power down" value ="1"/>
            </options>
        </bits>    
        <bits name="AU_VREFPD" pos="2" access="rs" rst="1">
            <comment>VREF (necessary for all other functions) generation block power down. </comment>
            <options>
                <option name="power up" value ="0"/>
                <option name="power down" value ="1"/>
            </options>
        </bits>    
        <bits name="AU_VMIDPD" pos="3" access="rs" rst="1">
            <comment>VMID (necessary for all other functions) generation block power down.</comment>
            <options>
                <option name="power up" value ="0"/>
                <option name="power down" value ="1"/>
            </options>
        </bits>    
        <bits name="AU_IBPD" pos="4" access="rs" rst="1">
            <comment>Bias current generation block power down.</comment> 
            <options>
                <option name="power up" value ="0"/>
                <option name="power down" value ="1"/>
            </options>
        </bits>    
        <bits name="AU_DACPDL" pos="5" access="rs" rst="1">
            <comment>DAC left power down. </comment>
            <options>
                <option name="power up" value ="0"/>
                <option name="power down" value ="1"/>
            </options>
        </bits>    
        <bits name="AU_DACPDR" pos="6" access="rs" rst="1">
            <comment>DAC right power down. </comment>
            <options>
                <option name="power up" value ="0"/>
                <option name="power down" value ="1"/>
            </options>
        </bits>    
        <bits name="AU_RST_H" pos="16" access="rs" rst="1">
            <comment>SoftReset for all flops using the audio clock.  </comment>
           <options>
               <option name="No Reset" value="0"></option>
               <option name="Reset" value="1"></option>
           </options>
        </bits>             
        <bits name="AU_CLKENB_L" pos="31" access="rs" rst="1">
            <comment>Clock input disable. </comment>
            <options>
                <option name="enable" value ="0"/>
                <option name="disable" value ="1"/>
            </options>
        </bits>    
    </reg>
    
    <reg name="STEREO_DAC_CTRL_CLR" protect="rw">   
        <bits name="AU_HPLPD" pos="0" access="rc" rst="1">
            <comment>Headphone left channel mixer and driver power down signal.</comment> 
            <options>
                <option name="power up" value ="0"/>
                <option name="power down" value ="1"/>
            </options>
        </bits>    
        <bits name="AU_HPRPD" pos="1" access="rc" rst="1">
            <comment>Headphone right channel mixer and driver power down signal.</comment> 
            <options>
                <option name="power up" value ="0"/>
                <option name="power down" value ="1"/>
            </options>
        </bits>    
        <bits name="AU_VREFPD" pos="2" access="rc" rst="1">
            <comment>VREF (necessary for all other functions) generation block power down.</comment> 
            <options>
                <option name="power up" value ="0"/>
                <option name="power down" value ="1"/>
            </options>
        </bits>    
        <bits name="AU_VMIDPD" pos="3" access="rc" rst="1">
            <comment>VMID (necessary for all other functions) generation block power down.</comment> 
            <options>
                <option name="power up" value ="0"/>
                <option name="power down" value ="1"/>
            </options>
        </bits>    
        <bits name="AU_IBPD" pos="4" access="rc" rst="1">
            <comment>Bias current generation block power down.</comment> 
            <options>
                <option name="power up" value ="0"/>
                <option name="power down" value ="1"/>
            </options>
        </bits>    
        <bits name="AU_DACPDL" pos="5" access="rc" rst="1">
            <comment>DAC left power down.</comment> 
            <options>
                <option name="power up" value ="0"/>
                <option name="power down" value ="1"/>
            </options>
        </bits>    
        <bits name="AU_DACPDR" pos="6" access="rc" rst="1">
            <comment>DAC right power down.</comment> 
            <options>
                <option name="power up" value ="0"/>
                <option name="power down" value ="1"/>
            </options>
        </bits>    
        <bits name="AU_RST_H" pos="16" access="rc" rst="1">
            <comment>SoftReset for all flops using the audio clock.  </comment>
           <options>
               <option name="no Reset" value="0"></option>
               <option name="Reset" value="1"></option>
           </options>
        </bits>          
        <bits name="AU_CLKENB_L" pos="31" access="rc" rst="1">
            <comment>Clock input disable.</comment> 
            <options>
                <option name="enable" value="0"></option>
                <option name="disable" value="1"></option>
            </options>
        </bits>    
    </reg>

    <reg name="STEREO_DAC_DIG_CTRL" protect="rw">   
        <bits name="AU_DACFLT" pos="1:0" access="rw" rst="0">
            <comment>DAC filter type select. </comment>
           <options>
               <option name="OSR 125" value="0"></option>
               <option name="OSR 135" value="1"></option>
               <option name="OSR 145" value="2"></option>
               <option name="reserved" value="3"></option>
           </options>
        </bits>   
        <bits name="AU_AIF_STB_CFG" pos="3" access="rw" rst="0">
            <comment>configure aif strobe toggles on rising or falling edge of stereo dac strobe.</comment>
           <options>
               <option name="rising" value="0"> </option>
               <option name="falling" value="1"> </option>
           </options>
        </bits>   
        <bits name="AU_DACMU_L" pos="4" access="rw" rst="1">
            <comment>Digital soft mute for DAC left channel. </comment>
            <options>
                <option name="no mute" value ="0"/>
                <option name="mute" value ="1"/>
            </options>
        </bits>   
        <bits name="AU_DACMU_R" pos="5" access="rw" rst="1">
            <comment>Digital soft mute for DAC right channel. </comment> 
            <options>
                <option name="no mute" value ="0"/>
                <option name="mute" value ="1"/>
            </options>
        </bits>   
        <bits name="AU_DACINV_L" pos="6" access="rw" rst="0">
            <comment>L Channel DAC phase invert. 
                <options>
                    <option name="no inverted" value ="0"/>
                    <option name="inverted" value ="1"/>
                </options>
            </comment>
        </bits>   
        <bits name="AU_DACINV_R" pos="7" access="rw" rst="0">
            <comment>R Channel DAC phase invert. 
                <options>
                    <option name="no inverted" value ="0"/>
                    <option name="inverted" value ="1"/>
                </options>
            </comment>
        </bits>           
        <bits name="AU_DWAEN" pos="8" access="rw" rst="0">
            <comment>DWA algorithm enable.</comment>
            <options>
                <option name="disable" value ="0"/>
                <option name="enable" value ="1"/>
            </options>
        </bits>   
        <bits name="AU_TSTEN" pos="9" access="rw" rst="0">
            <comment>Test stimulus enable.</comment>
            <options>
                <option name="disable" value ="0"/>
                <option name="enable" value ="1"/>
            </options>
        </bits>   
        <bits name="AU_LDAMUX" pos="12" access="rw" rst="0">
            <comment>Left channel DAC input select.</comment>
            <options>
                <option name="digit input" value ="0"/>
                <option name="test stimu" value ="1"/>
            </options>
        </bits>   
        <bits name="AU_RDAMUX" pos="13" access="rw" rst="0">
            <comment>Right channel DAC input select.</comment>
            <options>
                <option name="digit input" value ="0"/>
                <option name="test stimu" value ="1"/>
            </options>
        </bits>   
        <bits name="AU_DAC_SHIFT_SIGN" pos="14" access="rw" rst="0">
            <comment>config DAC digital input shift.</comment>
            <options>
                <option name="signed" value ="0"/>
                <option name="unsigned" value ="1"/>
            </options>
        </bits>              
        <bits name="AU_DACIL_SHIFT" pos="18:16" access="rw" rst="0">
            <comment>left DAC digital input shift.</comment>
        </bits>   
        <bits name="AU_DACIR_SHIFT" pos="22:20" access="rw" rst="0">
            <comment>right DAC digital input shift.</comment>
        </bits>   
        <bits name="AU_CLK_DIV" pos="27:24" access="rw" rst="15">
            <comment>Stereo dac clock divider for generating over-sampling clock. clock freqency = selected clock source frequency / (value + 2). See bit 28 CLK_SRC_SEL for source selection.  </comment>
        </bits>         
        <bits name="AU_CLK_SRC_SEL" pos="28" access="rw" rst="0">
            <comment>Generate audio clock from 12MHz or 13MHz. </comment>
           <options>
               <option name="12 MHz" value="0"></option>
               <option name="13 MHz" value="1"></option>
           </options>
        </bits>  
    </reg>    
    
    <reg name="STEREO_DAC_ANA_CTRL" protect="rw">   
        <bits name="AU_TOEN" pos="0" access="rw" rst="0">
            <comment>Timeout Enable. </comment>
            <options>
                <option name="disable" value ="0"/>
                <option name="enable" value ="1"/>
            </options>
        </bits>   
        <bits name="AU_TOTM" pos="1" access="rw" rst="0">
            <comment>Detect time for the timeout mode in zero-crossing function. 
                <br/> 0 = (2**18-1)*T (T = oversampling-clock cycle)
                <br/> 1 = (2**17-1)*T (T = oversampling-clock cycle)
            </comment>
        </bits>   
        <bits name="AU_CAPLESS" pos="2" access="w" rst="-">
            <comment>Capless mode enable signal. 
                <br/> 0 = Capless Mode disable.(Output PSUGND is high resistance)
                <br/> 1 = Capless Mode enable.(Vau_psugnd=VMID)
            </comment>
            <options>
                <option name="disable" value ="0"/>
                <option name="enable" value ="1"/>
            </options>
        </bits>          
        <bits name="AU_HPLZC" pos="4" access="rw" rst="0">
            <comment>Left stereo headphone driver zero cross enable. 
                <br/> 0 = change gain immediately
                <br/> 1 = change gain on zero cross only
            </comment>
        </bits>   
        <bits name="AU_HPRZC" pos="5" access="rw" rst="0">
            <comment>Left stereo headphone driver zero cross enable. 
                <br/> 0 = change gain immediately
                <br/> 1 = change gain on zero cross only
            </comment>
        </bits>   
        <bits name="AU_LDA2HPL" pos="16" access="rw" rst="0">
            <comment>Left DAC to headphone stereo mixer L channel.</comment> 
            <options>
                <option name="disable" value ="0"/>
                <option name="enable" value ="1"/>
            </options>
        </bits>   
        <bits name="AU_RDA2HPL" pos="17" access="rw" rst="0">
            <comment>Right DAC to headphone stereo mixer L channel.</comment> 
            <options>
                <option name="disable" value ="0"/>
                <option name="enable" value ="1"/>
            </options>
        </bits>   
        <bits name="AU_LDA2HPR" pos="20" access="rw" rst="0">
            <comment>Left DAC to headphone stereo mixer R channel.</comment> 
            <options>
                <option name="disable" value ="0"/>
                <option name="enable" value ="1"/>
            </options>
        </bits>   
        <bits name="AU_RDA2HPR" pos="21" access="rw" rst="0">
            <comment>Right DAC to headphone stereo mixer R channel.</comment> 
            <options>
                <option name="disable" value ="0"/>
                <option name="enable" value ="1"/>
            </options>
        </bits>   
        <bits name="AU_VOI2HP" pos="24" access="rw" rst="0">
            <comment>Voice input to both headphone stereo mixer L/R channel.</comment>
            <options>
                <option name="disable" value ="0"/>
                <option name="enable" value ="1"/>
            </options>
        </bits>           
        <bits name="AU_TSDEN" pos="28" access="rw" rst="0">
            <comment>Temperature sensor enable signal. </comment>
            <options>
                <option name="disable" value ="0"/>
                <option name="enable" value ="1"/>
            </options>
        </bits>   
        <bits name="AU_DTEMP" pos="31" access="r" rst="0">
            <comment>Over temperature index for the system.</comment>
            <options>
                <option name="normal" value ="0"/>
                <option name="over temp" value ="1"/>
            </options>
        </bits>   
    </reg>    
    
    <reg name="STEREO_DAC_MIXER_HP_GAIN" protect="rw">   
        <bits name="AU_VOI2HPVOL" pos="2:0" access="rw" rst="5">
            <comment>Voice signal to headphone stereo mixer L channel volume control. 
                <br/> 000 = +6dB 
                <br/> 001 = +3dB 
                <br/> ... 3dB steps downto  
                <br/> 110 = -12dB
                <br/> 111 = -15dB
            </comment>
        </bits>   
    </reg>    
    
    <reg name="STEREO_DAC_HP_GAIN_L" protect="rw">   
        <bits name="AU_HPLVU" pos="0" access="rw" rst="0">
            <comment>Left stereo headphone driver volume update. 
                <br/> 0 = store AU_HPLVOL in intermediate latch(no gain change)
                <br/> 1 = update left and right channel gains (left=AU_HPLVOL, right=intermediate latch)
            </comment>
        </bits>   
        <bits name="AU_HPLVOL" pos="12:8" access="rw" rst="23">
            <comment>Left stereo headphone driver volume control. 
                <br/> 00000 to 00010 analog mute
                <br/> 00011 = -30dB
                <br/> 00100 = -28.5dB
                <br/> ... 1.5dB steps up to 
                <br/> 11110 = +10.5dB
                <br/> 11111 = +12dB
            </comment>
        </bits>   
    </reg>     

    <reg name="STEREO_DAC_HP_GAIN_R" protect="rw">   
        <bits name="AU_HPRVU" pos="0" access="rw" rst="0">
            <comment>Left stereo headphone driver volume update. 
                <br/> 0 = store AU_HPLVOL in intermediate latch(no gain change)
                <br/> 1 = update left and right channel gains (left=AU_HPLVOL, right=intermediate latch)
            </comment>
        </bits>   
        <bits name="AU_HPRVOL" pos="12:8" access="rw" rst="23">
            <comment>Left stereo headphone driver volume control. 
                <br/> 00000 to 00010 analog mute
                <br/> 00011 = -30dB
                <br/> 00100 = -28.5dB
                <br/> ... 1.5dB steps up to 
                <br/> 11110 = +10.5dB
                <br/> 11111 = +12dB
            </comment>
        </bits>   
    </reg>     

    <reg name="STEREO_DAC_REF_GEN" protect="rw"> 
        <bits name="AU_VROI" pos="0" access="rw" rst="0">
            <comment>VREF to analog output resistance. 
                <br/> 0 = 1.5K Ohm
                <br/> 1 = 40K Ohm
            </comment>
        </bits>   
        <bits name="AU_VMIDSEL" pos="5:4" access="rw" rst="0">
            <comment>VMID divider enable and select. 
                <br/> 00 = VMID disable (for OFF mode)
                <br/> 01 = 50K Ohm divider enable 
                <br/> 10 = 500K Ohm divider enable (for low power standby) 
                <br/> 11 = 5K Ohm divider enable (for fast startup) 
            </comment>
        </bits>   
        <bits name="AU_VSEL" pos="10:8" access="rw" rst="4">
            <comment>Analog bias current optimisation. 
                <br/> 000 = -50%
                <br/> 001 = -37.5%
                <br/> 010 = -25%
                <br/> 011 = -12.5%
                <br/> 100 = 0 
                <br/> 101 = +12.5%
                <br/> 110 = +25%
                <br/> 111 = +37.5%
            </comment>
        </bits>   
        <bits name="AU_IMFMIX" pos="13:12" access="rw" rst="1">
            <comment>Bias current modify control bit for mixers. 
                <br/> 00 = 2.5u
                <br/> 01 = 5u 
                <br/> 10 = 7.5u 
                <br/> 11 = 10u 
            </comment>
        </bits>   
        <bits name="AU_IMFDR" pos="17:16" access="rw" rst="1">
            <comment>Bias current modify control bit for headphone and loudspeaker. 
                <br/> 00 = 2.5u
                <br/> 01 = 5u 
                <br/> 10 = 7.5u 
                <br/> 11 = 10u 
            </comment>
        </bits>   
        <bits name="AU_IMFDAC" pos="21:20" access="rw" rst="1">
            <comment>Bias current modify control bit for analog filter of DAC. 
                <br/> 00 = 2.5u
                <br/> 01 = 5u 
                <br/> 10 = 7.5u 
                <br/> 11 = 10u 
            </comment>
        </bits>   
        <bits name="AU_DACIT1" pos="24" access="rw" rst="0">
            <comment>Bias current modify bit of stage one in analog filter. 
                <br/> 0 = default 5 uA
                <br/> 1 = 2.5 uA
            </comment>
        </bits>   
    </reg>     
    <reg name="IO_TEST_MODE" protect="rw">
        <comment>Selects I/O muxing for ACCO/STEREO DAC/USB tests and USB Backup port.
                <br/>Note that theses settings can be overidden in TST_H mode by pad driving.
        </comment>
        <bits name="Test_Mode" pos="3:0" access="rw" rst="all0">
            <options>
                <option name="DISABLED" value ="0">
                    <comment>Functional muxing.</comment></option>
                <option name="ACCO_TEST" value ="1">
                    <comment>Gives access to ACCO test buses.</comment></option>
                <option name="USB_TEST" value ="2">
                    <comment>Gives access to USB PHY pins.</comment></option>
                <option name="ST_DAC_TEST" value ="3">
                    <comment>Gives access to Stereo DAC test bus.</comment></option>
                <option name="ST_DAC_BIST" value ="4">
                    <comment>Puts the Stereo DAC in BIST mode.</comment></option>
                <option name="USB_BACKUP" value ="5">
                    <comment>Put the USBC bus on the DBG_BUS to control an external PHY</comment></option>
                <mask/><shift/><default/>
            </options>
        </bits>
    </reg>
                
</module>
</archive>




<archive relative='tester_chip.xml' >



<module name="tester_chip" category="Debug">
    <comment>This module is not inside the Granite chip. It's connected to a Chip select of EBC and placed in the testbench for simulation. It is also partially included in the FPGA.</comment>
    <reg name="Stopper" protect="rw">
        <bits name="Stop Cause" pos="15:0" access="rw" rst="no">
            <comment>Stopper regs, any write to this register will stop the simulation.
            </comment>
            <options>
                <option name="SUCCESS" value="1"/>
                <option name="ERROR" value="2"/>
                <default/>
            </options>
        </bits>
    </reg>
    <reg name="Watch" protect="rw">
        <bits name="Watch" pos="15:0" access="rw" rst="no">
            <comment>Watch regs, any write to this register trigger a display on simulation.
                <br/>On FPGA the 8 lower bits are connected to the LED on the xilinx board.
            </comment>
        </bits>
    </reg>
    <reg name="W0" protect="rw">
        <bits name="W0" pos="31:0" access="rw" rst="no">
            <comment>Watch0 regs, any write to this register trigger a display on simulation.
            </comment>
        </bits>
    </reg>
    <reg name="W1" protect="rw">
        <bits name="W1" pos="31:0" access="rw" rst="no">
            <comment>Watch1 regs, any write to this register trigger a display on simulation.
            </comment>
        </bits>
    </reg>
    <reg name="Test_Mode" protect="rw">
            <comment>Test Mode reg, the bits of this register control some test component or test muxing in the testbench. (some of them are also used on the FPGA).
            </comment>
        <bits name="CLK_SYSTEM_SEL" pos="0" access="rw" rst="0">
            <comment> select CLK_SYSTEM used in testbench for several simulators.
               <br/> '0': DBG_CLK
               <br/> '1': CLK_26M.
           </comment>
        </bits>
        <bits name="CLK_HST_DISABLE" pos="1" access="rw" rst="0">
            <comment> Disable Clk Host in testbench.
               <br/> '0': Clk host on
               <br/> '1': Clk host off
           </comment>
        </bits>
        <bits name="RFSPI_AREO1" pos="2" access="rw" rst="0">
            <comment> rfspi loopback in testbench for areo1 test.
               <br/> '0': normal
               <br/> '1': loopback
           </comment>
        </bits>
        <bits name="RFSPI_AREO2" pos="3" access="rw" rst="0">
            <comment> rfspi loopback in testbench with delay for areo2 test.
               <br/> '0': normal
               <br/> '1': loopback
           </comment>
        </bits>
        <bits name="SPI_LOOP0_EN" pos="4" access="rw" rst="0">
            <comment> spi loopback in testbech.
               <br/> '0': normal
               <br/> '1': loopback
           </comment>
        </bits>
        <bits name="SPI_SIMULATOR_SEL" pos="5" access="rw" rst="0">
            <comment> granite chip connect to spi simulator in testbench.
               <br/> '0': normal
               <br/> '1': spi simulator connected
           </comment>
        </bits>
        <bits name="DAI_MODE" pos="6" access="rw" rst="0">
            <comment> granite chip connect to dai simulator in testbench.
               <br/> '0': normal
               <br/> '1': spi simulator connected
           </comment>
        </bits>
        <bits name="KEYON_VALUE" pos="7" access="rw" rst="0">
            <comment> simulate key ON in testbench.
               <br/> '0': key ON released
               <br/> '1': key ON pressed
           </comment>
        </bits>
        <bits name="UART_DIVIDER" pos="15:8" access="rw" rst="0" display="hex">
            <comment> clock divider for uart in test_chip module.
                <br/> UART FREQ = CLK_SYSTEM / (UART_DIVIDER + 2)
                <br/>
            </comment>
        </bits>
        <bits name="AUDIO_CLK_DIV2_DIS" pos="16:16" access="rw" rst="0" display="hex">
            <comment> select output audio master clock freqency (FPGA Only).
                <br/> '0': 13MHz AUDIO MCLK.
                <br/> '1': 26MHz AUDIO MCLK.
            </comment>
        </bits>
        <bits name="UART_SEL" pos="18:17" access="rw" rst="0" display="hex">
            <comment>select connection between debug_uart,uart and tester_uart in testbench.
                <br/>"00": no connection.
                <br/>"01": debug_uart connect to uart.
                <br/>"10": debug_uart connect to tester_uart.
                <br/>"11": uart connect to tester_uart.
            </comment>
        </bits>
        <bits name="GPIO_SEL" pos="19" access="rw" rst="0">
            <comment> tester chip input reg connect to GPIO in testbench.
               <br/> '0': normal
               <br/> '1': tester chip input reg connected to GPIOs.
           </comment>
        </bits>
        <bits name="GPO_SEL" pos="20" access="rw" rst="0">
            <comment> tester chip input reg connect to GPOs and TCOs in testbench.
               <br/> '0': normal
               <br/> '1': tester chip input reg connected to GPOs and TCOs.
           </comment>
        </bits>
        <bits name="I2C_SEL" pos="21" access="rw" rst="0">
            <comment> granite chip connect to I2C slave simulator in testbench.
               <br/> '0': normal
               <br/> '1': I2C slave simulator connected
            </comment>
        </bits>
        <bits name="DAI_I2S_MODE" pos="22" access="rw" rst="0">
            <comment> granite chip connect to I2S dai simulator in testbench.
               <br/> '0': normal
               <br/> '1': I2S dai simulator connected
            </comment>
        </bits>
        <bits name="I2S_SIMULATOR_SEL" pos="23" access="rw" rst="0">
            <comment> granite chip connect to I2S simulator in testbench.
               <br/> '0': normal
               <br/> '1': I2S simulator connected
            </comment>
        </bits>
        <bits name="ANALOG_TEST_SEL" pos="24" access="rw" rst="0">
            <comment> analog test mode selected in testbench.
               <br/> '0': normal
               <br/> '1': test mode selected
            </comment>
        </bits>
        <bits name="BOOT_MODE_TEST_SEL" pos="25" access="rw" rst="0">
            <comment> W0 reg connected as BOOT MODE pins in testbench.
               <br/> '0': normal
               <br/> '1': W0 reg connected as BOOT MODE pins
            </comment>
        </bits>
        <bits name="DEBUG_PORT_SIMULATOR_SEL" pos="26" access="rw" rst="0">
            <comment> granite chip connect to DEBUG PORT simulator in testbench.
               <br/> '0': normal
               <br/> '1': DEBUG PORT simulator connected
            </comment>
        </bits>
        <bits name="DEBUG_CLOCK_CHECKER_SEL" pos="27" access="rw" rst="0">
            <comment> Clock Debug is checked with a model that count high time and low time, the counter are readable with tester chip input reg
               <br/> '0': DEBUG CLOCK Checker off (and reseted)
               <br/> '1': DEBUG CLOCK Checker enabled
            </comment>
        </bits>
        <bits name="USB_SIMULATOR_SEL" pos="29:28" access="rw" rst="0" display="hex">
            <comment> 00 = SE1. 
                <br/> 01 = SE0.
                <br/> 10 = J.
                <br/> 11 = hiZ.
            </comment>
        </bits>
        <bits name="USB_EXTPHY_SEL" pos="30" access="rw" rst="0" display="hex">
            <comment> 0 = disable. 
                <br/> 1 = usb external phy selected.
            </comment>
        </bits>
        <bits name="ADMUX_MEMORIES" pos="31" access="rw" rst="0" display="hex">
            <comment> 0 = regular memories.
                <br/> 1 = all memories are now ADMUX.
            </comment>
        </bits>
    </reg>
    <reg name="Input" protect="rw">
        <bits name="Input" pos="31:0" access="r" rst="no">
            <comment>Input reg, connected to some lines in the testbench (currently all '1').
                <br/>On the fpga board the 7 lower bits receive the DIP switches of the UI board.
            </comment>
        </bits>
    </reg>

    <reg name="Test_Mode1" protect="rw">
        <comment>Control bits to enable or disable some test components of the testbench.
        </comment>
        <bits name="Camera_Simulator" pos="0" access="rw" rst="0">
            <options>
                <option name="DISABLE" value ="0"/>
                <option name="ENABLE" value ="1"/>
            </options>
        </bits>
        <bits name="SDMMC_Simulator" pos="1" access="rw" rst="0">
            <options>
                <option name="DISABLE" value ="0"/>
                <option name="ENABLE" value ="1"/>
            </options>
        </bits>
        <bits name="DAC_Bist_Simulator" pos="2" access="rw" rst="0">
            <options>
                <option name="DISABLE" value ="0"/>
                <option name="ENABLE" value ="1"/>
            </options>
        </bits>
        <bits name="SPI2_Simulator" pos="3" access="rw" rst="0">
            <options>
                <option name="DISABLE" value ="0"/>
                <option name="ENABLE" value ="1"/>
            </options>
        </bits>
        <bits name="PWM_Checker" pos="4" access="rw" rst="0">
            <options>
                <option name="DISABLE" value ="0"/>
                <option name="ENABLE" value ="1"/>
            </options>
        </bits>
        <bits name="DAI_Simulator" pos="5" access="rw" rst="0">
            <options>
                <option name="DISABLE" value ="0"/>
                <option name="ENABLE" value ="1"/>
            </options>
        </bits>
        <bits name="I2S_Simulator" pos="6" access="rw" rst="0">
            <options>
                <option name="DISABLE" value ="0"/>
                <option name="ENABLE" value ="1"/>
            </options>
        </bits>
        <bits name="DIGRF_Simulator" pos="7" access="rw" rst="0">
            <options>
                <option name="DISABLE" value ="0"/>
                <option name="ENABLE" value ="1"/>
            </options>
        </bits>
        <bits name="SLCD_Simulator" pos="8" access="rw" rst="0">
            <options>
                <option name="DISABLE" value ="0"/>
                <option name="ENABLE" value ="1"/>
            </options>
        </bits>
        <bits name="PLCD_Simulator" pos="9" access="rw" rst="0">
            <options>
                <option name="DISABLE" value ="0"/>
                <option name="ENABLE" value ="1"/>
            </options>
        </bits>
        <bits name="SPI_Simulator" pos="10" access="rw" rst="0">
            <options>
                <option name="DISABLE" value ="0"/>
                <option name="ENABLE" value ="1"/>
            </options>
        </bits>
        <bits name="SPI_Simulator_Mode" pos="11:13" access="rw" rst="0">
            <options>
                <option name="LOOP_CS0" value ="0"/>
                <option name="LOOP_CS1" value ="1"/>
                <option name="LOOP_CS2" value ="2"/>
                <option name="DIO_D0" value ="3"/>
                <option name="DIO_D1" value ="4"/>
            </options>
        </bits>
        <bits name="Tester_Chip_ChipSelect" pos="14" access="rw" rst="0">
            <options>
                <option name="M_CS_3" value ="0"/>
                <option name="M_CS_4" value ="1"/>
            </options>
        </bits>
        <bits name="GPIO_IN" pos="15" access="rw" rst="0">
            <options>
                <option name="DISABLE" value ="0"/>
                <option name="ENABLE" value ="1"/>
            </options>
        </bits>
        <bits name="Drive_BOND_ID" pos="16" access="rw" rst="0">
            <options>
                <option name="DISABLE" value ="0"/>
                <option name="ENABLE" value ="1"/>
            </options>
        </bits>
    </reg>

    <hole size="32"/>

    <reg name="W2_set" protect="rw">
        <bits name="W2_set" pos="31:0" access="rs" rst="no">
            <comment>Watch2 regs, any write to this register trigger a display on simulation.
            </comment>
        </bits>
    </reg>
    <reg name="W2_clr" protect="rw">
        <bits name="W2_clr" pos="31:0" access="rc" rst="no">
            <comment>Watch2 regs, any write to this register trigger a display on simulation.
            </comment>
        </bits>
    </reg>
    <reg name="Key0" protect="rw">
        <bits name="Key0" pos="31:0" access="rw" rst="no">
            <comment>Test reg used to simulate key press in tb.
            </comment>
        </bits>
    </reg>
    <reg name="Key1" protect="rw">
        <bits name="Key1" pos="9:0" access="rw" rst="no">
            <comment>Test reg used to simulate key press in tb.
            </comment>
        </bits>
    </reg>
    <reg16 name="STR_Print" protect="rw">
        <bits name="char" pos="7:0" access="w" rst="no">
            <comment>For simulation only: write string, char by char to this register to display it.
                <br/>write 0 to trigger the ouput of buffered string.
            </comment>
        </bits>
    </reg16>
    <hole size="16"/>
    <reg16 name="TestPrint" protect="rw" count="2">
            <comment>For simulation only.
                <br/>Write test number and state to display it as a string, the tester chip use a file to associate a string to the numbers.
            </comment>
        <bits name="Test_Number" pos="5:0" access="w" rst="no">
            <comment>Write test number
            </comment>
        </bits>
        <bits name="State" pos="7:6" access="w" rst="no">
            <comment>write test state
            </comment>
        </bits>
    </reg16>
    <hole size="64"/>
    <reg name="Led_Ctrl" protect="rw">
        <comment>This register is not in the FPGA but on the Romulator connected to it</comment>
        <bits name="Led_Ctrl" pos="15:0" access="rw" rst="0">
            <comment>Led_Ctrl regs, any write to this register trigger a display on simulation.
                <br/>On FPGA the 8 lower bits are connected to the LED on the Romulator board.
            </comment>
        </bits>
    </reg>
    <reg name="EXL_Ctrl" protect="rw">
        <comment>This register is not in the FPGA but on the Romulator connected to it</comment>
        <bits name="EXL_Ctrl" pos="0" access="rw" rst="0">
            <comment>'1' to enable exl on the Romulator board.
            </comment>
        </bits>
    </reg>
    <reg name="EXL_Trigger_Set" protect="rw">
        <comment>This register is not in the FPGA but on the Romulator connected to it</comment>
        <bits name="EXL_Trigger_Set" pos="15:0" access="rs" rst="0">
            <comment>Set the EXL trigger.
            </comment>
        </bits>
    </reg>
    <reg name="EXL_Trigger_Clr" protect="rw">
        <comment>This register is not in the FPGA but on the Romulator connected to it</comment>
        <bits name="EXL_Trigger_Clr" pos="15:0" access="rc" rst="0">
            <comment>Clear the EXL trigger.
            </comment>
        </bits>
    </reg>
    <reg name="LA_set" protect="rw" count="4">
        <comment>This register is not in the FPGA but on the Romulator connected to it
            <br/>Logic Analyser register
            <br/>the 16 lower bits of register LA(0) and LA(1) are common.
        </comment>
        <bits name="LA_set" pos="31:0" access="rs" rst="no">
            <comment>LA regs, any write to this register trigger a display on simulation.
                <br/>The content of this register is available on the Logic Analyser connector on the romulator board. Select the wanted register with the 2 DIP switch.
            </comment>
        </bits>
    </reg>
    <reg name="LA_clr" protect="rw" count="4">
        <comment>This register is not in the FPGA but on the Romulator connected to it
            <br/>Logic Analizer register
            <br/>the 16 lower bits of register LA(0) and LA(1) are common.
        </comment>
        <bits name="LA_clr" pos="31:0" access="rc" rst="no">
            <comment>LA regs, any write to this register trigger a display on simulation.
                <br/>The content of this register is available on the Logic Analyser connector on the romulator board. Select the wanted register with the 2 DIP switch.
            </comment>
        </bits>
    </reg>
    <reg name="PXTS" protect="rw">
        <comment>This register is not in the FPGA but on the Romulator connected to it</comment>
        <bits name="PXTS" pos="15:0" access="rw" rst="0">
            <comment>When writing to this register the value is recorded by the PXTS mechanism on the Romulator. (used by SA profile or Coolprofile tools).
            </comment>
        </bits>
    </reg>

</module>

</archive>

<archive relative='stereo_dac_test.xml' >

<module name="stereo_dac_test">

    <reg name="STEREO_DAC_RD_REG" protect="w">   
        <bits name="STEREO_DTEMP" pos="0" access="w" rst="-">
            <comment>Over temperature index for the system. 
                <br/> 0 = normal
                <br/> 1 = over temperature
            </comment>
        </bits>   
    </reg>    
        
    <reg name="STEREO_DAC_WR_REG0" protect="r">   
        <bits name="STEREO_HPLPD" pos="0" access="r" rst="-">
            <comment>Headphone left channel mixer and driver power down signal. 
                <br/> 0 = power up
                <br/> 1 = power down
            </comment>
        </bits>    
        <bits name="STEREO_HPRPD" pos="1" access="r" rst="-">
            <comment>Headphone right channel mixer and driver power down signal. 
                <br/> 0 = power up
                <br/> 1 = power down
            </comment>
        </bits>    
        <bits name="STEREO_VREFPD" pos="2" access="r" rst="-">
            <comment>VREF (necessary for all other functions) generation block power down. 
                <br/> 0 = power up
                <br/> 1 = power down
            </comment>
        </bits>    
        <bits name="STEREO_VMIDPD" pos="3" access="r" rst="-">
            <comment>VMID (necessary for all other functions) generation block power down. 
                <br/> 0 = power up
                <br/> 1 = power down
            </comment>
        </bits>    
        <bits name="STEREO_IBPD" pos="4" access="r" rst="-">
            <comment>Bias current generation block power down. 
                <br/> 0 = power up
                <br/> 1 = power down
            </comment>
        </bits>    
        <bits name="STEREO_DACPDL" pos="5" access="r" rst="-">
            <comment>DAC left power down. 
                <br/> 0 = power up
                <br/> 1 = power down
            </comment>
        </bits>    
        <bits name="STEREO_DACPDR" pos="6" access="r" rst="-">
            <comment>DAC right power down. 
                <br/> 0 = power up
                <br/> 1 = power down
            </comment>
        </bits>    
        <bits name="STEREO_CLKENB" pos="7" access="r" rst="-">
            <comment>Clock input disable. 
                <br/> 0 = enable
                <br/> 1 = disable
            </comment>
        </bits>    
        <bits name="STEREO_DACMU_L" pos="8" access="r" rst="-">
            <comment>Digital soft mute for DAC left channel. 
                <br/> 1 = mute
                <br/> 0 = no mute(signal active)
            </comment>
        </bits>   
        <bits name="STEREO_DACMU_R" pos="9" access="r" rst="-">
            <comment>Digital soft mute for DAC right channel. 
                <br/> 1 = mute
                <br/> 0 = no mute(signal active)
            </comment>
        </bits>   
        <bits name="STEREO_TOEN" pos="10" access="r" rst="-">
            <comment>Timeout Enable. 
                <br/> 0 = disable timeout
                <br/> 1 = enable timeout
            </comment>
        </bits>   
        <bits name="STEREO_TOTM" pos="11" access="r" rst="-">
            <comment>Detect time for the timeout mode in zero-crossing function. 
                <br/> 0 = (2**18-1)*T (T = oversampling-clock cycle)
                <br/> 1 = (2**17-1)*T (T = oversampling-clock cycle)
            </comment>
        </bits>   
        <bits name="STEREO_CAPLESS" pos="12" access="r" rst="-">
            <comment>Capless mode enable signal. 
                <br/> 0 = Capless Mode disable.(Output PSUGND is high resistance)
                <br/> 1 = Capless Mode enable.(Vau_psugnd=VMID)
            </comment>
        </bits>         
        <bits name="STEREO_HPLZC" pos="13" access="r" rst="-">
            <comment>Left stereo headphone driver zero cross enable. 
                <br/> 0 = change gain immediately
                <br/> 1 = change gain on zero cross only
            </comment>
        </bits>   
        <bits name="STEREO_HPRZC" pos="14" access="r" rst="-">
            <comment>Left stereo headphone driver zero cross enable. 
                <br/> 0 = change gain immediately
                <br/> 1 = change gain on zero cross only
            </comment>
        </bits>   
        <bits name="STEREO_LDA2HPL" pos="15" access="r" rst="-">
            <comment>Left DAC to headphone stereo mixer L channel. 
                <br/> 0 = disable (mute)
                <br/> 1 = enable path
            </comment>
        </bits>   
        <bits name="STEREO_RDA2HPL" pos="16" access="r" rst="-">
            <comment>Right DAC to headphone stereo mixer L channel. 
                <br/> 0 = disable (mute)
                <br/> 1 = enable path
            </comment>
        </bits>   
        <bits name="STEREO_VOI2HP" pos="17" access="r" rst="-">
            <comment>Voice signal to headphone stereo mixer L channel. 
                <br/> 0 = disable (mute)
                <br/> 1 = enable path
            </comment>
        </bits>   
        <bits name="STEREO_LDA2HPR" pos="18" access="r" rst="-">
            <comment>Left DAC to headphone stereo mixer R channel. 
                <br/> 0 = disable (mute)
                <br/> 1 = enable path
            </comment>
        </bits>   
        <bits name="STEREO_RDA2HPR" pos="19" access="r" rst="-">
            <comment>Right DAC to headphone stereo mixer R channel. 
                <br/> 0 = disable (mute)
                <br/> 1 = enable path
            </comment>
        </bits>   
        <bits name="STEREO_TSDEN" pos="20" access="r" rst="-">
            <comment>Temperature sensor enable signal. 
                <br/> 0 = disable
                <br/> 1 = enable 
            </comment>
        </bits>   
        <bits name="STEREO_VOI2HPVOL" pos="23:21" access="r" rst="-">
            <comment>Voice signal to headphone stereo mixer L channel volume control. 
                <br/> 000 = +6dB 
                <br/> 001 = +3dB 
                <br/> ... 3dB steps downto  
                <br/> 110 = -12dB
                <br/> 111 = -15dB
            </comment>
        </bits>   
        <bits name="STEREO_HPLVU" pos="24" access="r" rst="-">
            <comment>Left stereo headphone driver volume update. 
                <br/> 0 = store STEREO_HPLVOL in intermediate latch(no gain change)
                <br/> 1 = update left and right channel gains (left=STEREO_HPLVOL, right=intermediate latch)
            </comment>
        </bits>   
        <bits name="STEREO_HPLVOL" pos="29:25" access="r" rst="-">
            <comment>Left stereo headphone driver volume control. 
                <br/> 00000 to 00010 analog mute
                <br/> 00011 = -30dB
                <br/> 00100 = -28.5dB
                <br/> ... 1.5dB steps up to 
                <br/> 11110 = +10.5dB
                <br/> 11111 = +12dB
            </comment>
        </bits>   
        <bits name="STEREO_HPRVU" pos="30" access="r" rst="-">
            <comment>Left stereo headphone driver volume update. 
                <br/> 0 = store STEREO_HPLVOL in intermediate latch(no gain change)
                <br/> 1 = update left and right channel gains (left=STEREO_HPLVOL, right=intermediate latch)
            </comment>
        </bits>   
        <bits name="STEREO_VROI" pos="31" access="r" rst="-">
            <comment>VREF to analog output resistance. 
                <br/> 0 = 1.5K Ohm
                <br/> 1 = 40K Ohm
            </comment>
        </bits>         
    </reg>     

    <reg name="STEREO_DAC_WR_REG1" protect="r"> 
        <bits name="STEREO_HPRVOL" pos="4:0" access="r" rst="-">
            <comment>Left stereo headphone driver volume control. 
                <br/> 00000 to 00010 analog mute
                <br/> 00011 = -30dB
                <br/> 00100 = -28.5dB
                <br/> ... 1.5dB steps up to 
                <br/> 11110 = +10.5dB
                <br/> 11111 = +12dB
            </comment>
        </bits>   
        <bits name="STEREO_VMIDSEL" pos="6:5" access="r" rst="-">
            <comment>VMID divider enable and select. 
                <br/> 00 = VMID disable (for OFF mode)
                <br/> 01 = 50K Ohm divider enable 
                <br/> 10 = 500K Ohm divider enable (for low power standby) 
                <br/> 11 = 5K Ohm divider enable (for fast startup) 
            </comment>
        </bits>   
        <bits name="STEREO_VSEL" pos="9:7" access="r" rst="-">
            <comment>Analog bias current optimisation. 
                <br/> 000 = -50%
                <br/> 001 = -37.5%
                <br/> 010 = -25%
                <br/> 011 = -12.5%
                <br/> 100 = 0 
                <br/> 101 = +12.5%
                <br/> 110 = +25%
                <br/> 111 = +37.5%
            </comment>
        </bits>   
        <bits name="STEREO_IMFMIX" pos="11:10" access="r" rst="-">
            <comment>Bias current modify control bit for mixers. 
                <br/> 00 = 2.5u
                <br/> 01 = 5u 
                <br/> 10 = 7.5u 
                <br/> 11 = 10u 
            </comment>
        </bits>   
        <bits name="STEREO_IMFDR" pos="13:12" access="r" rst="-">
            <comment>Bias current modify control bit for headphone and loudspeaker. 
                <br/> 00 = 2.5u
                <br/> 01 = 5u 
                <br/> 10 = 7.5u 
                <br/> 11 = 10u 
            </comment>
        </bits>   
        <bits name="STEREO_IMFDAC" pos="15:14" access="r" rst="-">
            <comment>Bias current modify control bit for analog filter of DAC. 
                <br/> 00 = 2.5u
                <br/> 01 = 5u 
                <br/> 10 = 7.5u 
                <br/> 11 = 10u 
            </comment>
        </bits>   
        <bits name="STEREO_DACIT1" pos="16" access="r" rst="-">
            <comment>Bias current modify bit of stage one in analog filter. 
                <br/> 0 = default 5 uA
                <br/> 1 = 2.5 uA
            </comment>
        </bits>   
        <bits name="STEREO_RST_L" pos="17" access="r" rst="-">
            <comment>stereo dac rst low active. 
                <br/> 0 = reset
                <br/> 1 = no reset
            </comment>
        </bits>           
        <bits name="ANA_AU_TEST_IN_0" pos="18" access="r" rst="-">
            <comment>stereo dac anlog test in. 
            </comment>
        </bits>          
        <bits name="ANA_AU_TEST_IN_1" pos="19" access="r" rst="-">
            <comment>stereo dac anlog test in. 
            </comment>
        </bits>          
        <bits name="ANA_AU_TEST_IN_2" pos="20" access="r" rst="-">
            <comment>stereo dac anlog test in. 
            </comment>
        </bits>          
        <bits name="ANA_AU_TEST_IN_3" pos="21" access="r" rst="-">
            <comment>stereo dac anlog test in. 
            </comment>
        </bits>          
        <bits name="ANA_AU_TEST_IN_4" pos="22" access="r" rst="-">
            <comment>stereo dac anlog test in. 
            </comment>
        </bits>          
        <bits name="ANA_AU_TEST_IN_5" pos="23" access="r" rst="-">
            <comment>stereo dac anlog test in. 
            </comment>
        </bits>          
        <bits name="ANA_AU_TEST_IN_6" pos="24" access="r" rst="-">
            <comment>stereo dac anlog test in. 
            </comment>
        </bits>          
        <bits name="ANA_AU_TEST_IN_7" pos="25" access="r" rst="-">
            <comment>stereo dac anlog test in. 
            </comment>
        </bits>          
        <bits name="ANA_AU_TEST_IN_8" pos="26" access="r" rst="-">
            <comment>stereo dac anlog test in. 
            </comment>
        </bits>          
        <bits name="ANA_AU_TEST_IN_9" pos="27" access="r" rst="-">
            <comment>stereo dac anlog test in. 
            </comment>
        </bits>          
        <bits name="ANA_AU_TEST_IN_10" pos="28" access="r" rst="-">
            <comment>stereo dac anlog test in. 
            </comment>
        </bits>          
        <bits name="ANA_AU_TEST_IN_11" pos="29" access="r" rst="-">
            <comment>stereo dac anlog test in. 
            </comment>
        </bits>          
        <bits name="ANA_AU_TEST_IN_12" pos="30" access="r" rst="-">
            <comment>stereo dac anlog test in. 
            </comment>
        </bits>          
        <bits name="ANA_AU_TEST_IN_13" pos="31" access="r" rst="-">
            <comment>stereo dac anlog test in. 
            </comment>
        </bits>          
    </reg>     

    <reg name="STEREO_DAC_WR_REG2" protect="r"> 
        <bits name="ANA_AU_TEST_IN_14" pos="0" access="r" rst="-">
            <comment>stereo dac anlog test in. 
            </comment>
        </bits>          
        <bits name="ANA_AU_TEST_IN_15" pos="1" access="r" rst="-">
            <comment>stereo dac anlog test in. 
            </comment>
        </bits>          
        <bits name="ANA_AU_TEST_IN_16" pos="2" access="r" rst="-">
            <comment>stereo dac anlog test in. 
            </comment>
        </bits>          
        <bits name="ANA_AU_TEST_IN_17" pos="3" access="r" rst="-">
            <comment>stereo dac anlog test in. 
            </comment>
        </bits>          
        <bits name="ANA_AU_TEST_IN_18" pos="4" access="r" rst="-">
            <comment>stereo dac anlog test in. 
            </comment>
        </bits>          
        <bits name="ANA_AU_TEST_IN_19" pos="5" access="r" rst="-">
            <comment>stereo dac anlog test in. 
            </comment>
        </bits>          
        <bits name="ANA_AU_TEST_IN_20" pos="6" access="r" rst="-">
            <comment>stereo dac anlog test in. 
            </comment>
        </bits>          
        <bits name="ANA_AU_TEST_IN_21" pos="7" access="r" rst="-">
            <comment>stereo dac anlog test in. 
            </comment>
        </bits>          
        <bits name="ANA_AU_TEST_IN_22" pos="8" access="r" rst="-">
            <comment>stereo dac anlog test in. 
            </comment>
        </bits>          
        <bits name="ANA_AU_TEST_IN_23" pos="9" access="r" rst="-">
            <comment>stereo dac anlog test in. 
            </comment>
        </bits>          
    </reg>     
    
</module>
</archive>




<archive relative='test_uart.xml' >


<module name="test_uart" cqtegory="simu_only">
    <reg name="RX_TX_Divisor_Latch_L" protect="">
    </reg>
    <reg name="Interrupt_En_Divisor_Latch_H" protect="rw">
        <bits name="ERBFI" pos="0" access="rw">
		</bits>
        <bits name="ETBEI" pos="1" access="rw">
		</bits>
        <bits name="ELSI" pos="2" access="rw">
		</bits>
        <bits name="EDSSI" pos="3" access="rw">
		</bits>
        <bits name="PTIME" pos="7" access="rw">
		</bits>
    </reg>
    <reg name="Interrupt_Identity_Fifo_Ctrl" protect="rw">
        
        <bits name="Interrupt_Identity" pos="3:0" access="rw">
            <options>
                <option name="Modem_Status_Changed" value="0" />
                <option name="NO_IRQ" value="1" />
                <option name="THR_Empty" value="2" />
                <option name="Data_Available" value="4" />
                <option name="Receiver_Stat" value="6" />
                <option name="Char_Timeout" value="12" />
            </options>
		</bits>
        <bits name="Fifo_Stat" pos="7:6" access="rw">
            <options>
                <option name="En" value="3" />
                <option name="Di" value="0" />
            </options>
		</bits>
        
        <bits name="FIFO_En" pos="0" access="rw">
		</bits>
        <bits name="RX_FIFO_Rst" pos="1" access="rw">
		</bits>
        <bits name="TX_FIFO_Rst" pos="2" access="rw">
		</bits>
        <bits name="DMA_Mode" pos="3" access="rw">
		</bits>
        <bits name="TX_Fifo_Th" pos="5:4" access="rw">
            <options>
                <option name="Empty" value="0" />
                <option name="2Char" value="1" />
                <option name="Quart" value="2" />
                <option name="Half" value="3" />
            </options>
		</bits>
        <bits name="Rx_Fifo_Th" pos="7:6" access="rw">
            <options>
                <option name="1Char" value="0" />
                <option name="Quart" value="1" />
                <option name="Half" value="2" />
                <option name="2Less" value="3" />
            </options>
		</bits>
    </reg>
    <reg name="Line_Ctrl" protect="rw">
        <bits name="Char" pos="1:0" access="rw">
            <options>
                <option name="5_BIT" value="0" />
                <option name="6_BIT" value="1" />
                <option name="7_BIT" value="2" />
                <option name="8_BIT" value="3" />
                <default/><shift/><mask/>
            </options>
		</bits>
        <bits name="Stop_Bit" pos="2" access="rw">
            <options>
                <option name="1_BIT" value="0" />
                <option name="2_BIT" value="1" />
                <default/><shift/><mask/>
            </options>
		</bits>
        <bits name="Parity" pos="3" access="rw">
            <options>
                <option name="Dis" value="0" />
                <option name="En" value="1" />
                <default/><shift/><mask/>
            </options>
		</bits>
        <bits name="Parity_Pol" pos="4" access="rw">
            <options>
                <option name="Even" value="0" />
                <option name="Odd" value="1" />
                <default/><shift/><mask/>
            </options>
		</bits>
        <bits name="Break" pos="6" access="rw">
		</bits>
        <bits name="Div_Latch_Prog" pos="7" access="rw">
		</bits>
    </reg>
    <reg name="Modem_Ctrl" protect="rw">
        <bits name="Auto_Flow_Ctrl_1" pos="1" access="rw">
		</bits>
        <bits name="IRDA_2" pos="2" access="rw">
		</bits>
        <bits name="Loopback" pos="4" access="rw">
		</bits>
        <bits name="Auto_Flow_Ctrl_5" pos="5" access="rw">
		</bits>
        <bits name="IRDA_6" pos="6" access="rw">
		</bits>
        <bitgroup name="IRDA_Output" >
            <entry ref="IRDA_2" />
            <entry ref="IRDA_6" />
        </bitgroup>
        <bitgroup name="Auto_Flow_Ctrl" >
            <entry ref="Auto_Flow_Ctrl_1" />
            <entry ref="Auto_Flow_Ctrl_5" />
        </bitgroup>
    </reg>
    <reg name="Line_Status" protect="rw">
        <bits name="Data_Ready" pos="0" access="rw">
        </bits>
        <bits name="Overrun_Err" pos="1" access="rw">
        </bits>
        <bits name="Parity_Err" pos="2" access="rw">
        </bits>
        <bits name="Framing_Err" pos="3" access="rw">
        </bits>
        <bits name="Break_Int" pos="4" access="rw">
        </bits>
        <bits name="THRE" pos="5" access="rw">
        </bits>
        <bits name="TEMT" pos="6" access="rw">
        </bits>
        <bits name="RX_FIFO_Err" pos="7" access="rw">
        </bits>
    </reg>
    <reg name="Modem_Status" protect="rw">
        <bits name="DCTS" pos="0" access="rw">
        </bits>
        <bits name="DDSR" pos="1" access="rw">
        </bits>
        <bits name="TERI" pos="2" access="rw">
        </bits>
        <bits name="DDCD" pos="3" access="rw">
        </bits>
        <bits name="CTS" pos="4" access="rw">
        </bits>
        <bits name="DSR" pos="5" access="rw">
        </bits>
        <bits name="RI" pos="6" access="rw">
        </bits>
        <bits name="DCD" pos="7" access="rw">
        </bits>
    </reg>
    <reg name="Scratch" protect="rw">
    </reg>

</module>
</archive>

<archive relative='ana_test.xml' >

<module name="ana_test" category="simu_only">
    <var name="NB_ANALOG_OUTS" value="24"/>
    <var name="NB_ANALOG_INS" value="173"/>

    <var name="NB_ANALOG_OUT_REGS" value="((NB_ANALOG_OUTS + 31) / 32)"/>
    <var name="NB_ALALOG_IN_REGS" value="((NB_ANALOG_INS  + 31) / 32)"/>

    <reg name="io_i_w" protect="rw">
        <comment>Regiter to drive a value to inputs on acco (test mode)
        </comment>
    </reg>
    <reg name="io_b_d" protect="rw">
        <comment>Regiter to set direction to bidirs on acco (test mode)
        </comment>
    </reg>
    <reg name="io_b_w" protect="rw">
        <comment>Regiter to drive a value to bidirs on acco (test mode)
        </comment>
    </reg>
    <reg name="io_b_r" protect="rw">
        <comment>Regiter to read the value of bidirs on acco (test mode)
        </comment>
    </reg>
    <reg name="ana_o" protect="rw" count="NB_ANALOG_OUT_REGS">
        <comment>Regiter to drive a value to outputs of acco_analog macro model
        </comment>
    </reg>
    <reg name="ana_i" protect="rw" count="NB_ALALOG_IN_REGS">
        <comment>Regiter to read the value of inputs of acco_analog macro model
        </comment>
    </reg>



<var name="IO_I_W_PADAC_IN" value="0"/>
<var name="IO_I_W_PADAC_CLK" value="12"/>

<var name="IO_I_W_AFC_IN" value="0"/>
<var name="IO_I_W_AFC_CLK" value="12"/>

<var name="IO_I_W_GPADC_START" value="1"/>
<var name="IO_I_W_GPADC_MCK" value="12"/>

<var name="IO_I_W_TX_DAC_IN" value="0"/>
<var name="IO_I_W_TX_DAC_CLK" value="12"/>

<var name="IO_I_W_RX_CLK_FS" value="12"/>

<var name="IO_I_W_AU_DACA_IN" value="0"/>
<var name="IO_I_W_AU_CLK_520K" value="12"/>
<var name="IO_I_W_AU_CLK_40K" value="13"/>


<var name="IO_B_R_RX_SD_OUTI" value="0"/>
<var name="IO_B_R_RX_SD_OUTQ" value="3"/>
<var name="IO_B_R_AU_SD_OUTA" value="0"/>
<var name="IO_B_R_GPADC_DATA" value="0"/>
<var name="IO_B_R_GPADC_EOC" value="10"/>


<var name="ANA_O_AU_BG_OK" value="0"/>
<var name="ANA_O_AU_SD_OUTA" value="1"/>

<var name="ANA_O_GPADC_OUT" value="4"/>

<var name="ANA_O_GPADC_EOC" value="14"/>
<var name="ANA_O_COMM_BG_OK" value="15"/>
<var name="ANA_O_TX_BG_OK" value="16"/>
<var name="ANA_O_RX_SD_OUTI" value="17"/>

<var name="ANA_O_RX_SD_OUTQ" value="20"/>

<var name="ANA_O_RX_BG_OK" value="23"/>


<var name="ANA_I_AU_MIC_MUTE" value="0"/>
<var name="ANA_I_AU_DEEP_PD" value="1"/>
<var name="ANA_I_AU_MIC_PD" value="2"/>
<var name="ANA_I_AU_SD_PD" value="3"/>
<var name="ANA_I_AU_DACA_PD" value="4"/>
<var name="ANA_I_AU_REF_ENABLE" value="5"/>
<var name="ANA_I_AU_SPK_PD" value="6"/>
<var name="ANA_I_AU_MIC_ANA_GAIN" value="7"/>

<var name="ANA_I_AU_MIC_SEL" value="11"/>
<var name="ANA_I_AU_SPK_MUTE" value="12"/>
<var name="ANA_I_AU_SPK_SEL" value="13"/>
<var name="ANA_I_AU_SPK_ANA_GAIN" value="14"/>

<var name="ANA_I_AU_BG_CTRL" value="17"/>

<var name="ANA_I_AU_BG_ENABLE" value="23"/>
<var name="ANA_I_AU_BG_STARTUP" value="24"/>
<var name="ANA_I_AU_REF_CAL" value="25"/>

<var name="ANA_I_AU_CLK_520K" value="28"/>
<var name="ANA_I_AU_RESETN" value="29"/>
<var name="ANA_I_AU_DACA_IN" value="30"/>

<var name="ANA_I_AU_DACA_CLK_40K" value="42"/>
<var name="ANA_I_AUDIO_TEST1" value="43"/>
<var name="ANA_I_AUDIO_TEST2" value="44"/>
<var name="ANA_I_AUDIO_TEST3" value="45"/>
<var name="ANA_I_PADAC_IN" value="46"/>

<var name="ANA_I_PADAC_RESETN" value="56"/>
<var name="ANA_I_PADAC_PD" value="57"/>
<var name="ANA_I_PADAC_CLK" value="58"/>
<var name="ANA_I_PA_TEST1" value="59"/>
<var name="ANA_I_AFC_CLK" value="60"/>
<var name="ANA_I_AFC_PD" value="61"/>
<var name="ANA_I_AFC_RESETN" value="62"/>
<var name="ANA_I_AFC_IN" value="63"/>

<var name="ANA_I_AFC_TEST1" value="75"/>
<var name="ANA_I_GPADC_MCK" value="76"/>
<var name="ANA_I_GPADC_START" value="77"/>
<var name="ANA_I_GPADC_PD" value="78"/>
<var name="ANA_I_GPADC_RESETN" value="79"/>
<var name="ANA_I_GPADC_SEL" value="80"/>

<var name="ANA_I_COMM_BG_CTRL" value="86"/>

<var name="ANA_I_COMM_BG_ENABLE" value="92"/>
<var name="ANA_I_COMM_BG_STARTUP" value="93"/>
<var name="ANA_I_GP_TEST1" value="94"/>
<var name="ANA_I_GP_TEST2" value="95"/>
<var name="ANA_I_PA_TEST2" value="96"/>
<var name="ANA_I_AFC_TEST2" value="97"/>
<var name="ANA_I_TX_TEST1" value="98"/>
<var name="ANA_I_TX_TEST2" value="99"/>
<var name="ANA_I_TX_TEST3" value="100"/>
<var name="ANA_I_TX_TEST4" value="101"/>
<var name="ANA_I_TX_DAC_CURRENT_CALI" value="102"/>

<var name="ANA_I_TX_DAC_INI" value="105"/>

<var name="ANA_I_TX_BG_CTRL" value="115"/>

<var name="ANA_I_TX_BG_ENABLE" value="121"/>
<var name="ANA_I_TX_BG_STARTUP" value="122"/>
<var name="ANA_I_TX_DAC_PD" value="123"/>
<var name="ANA_I_TX_LP_PD_TEST" value="124"/>
<var name="ANA_I_TX_DAC_INQ" value="125"/>

<var name="ANA_I_TX_REF_VOLTAGE_CAL" value="135"/>

<var name="ANA_I_TX_FILTER_TUNING" value="139"/>

<var name="ANA_I_TX_DAC_CLK" value="141"/>
<var name="ANA_I_TX_DAC_CURRENT_CALQ" value="142"/>

<var name="ANA_I_TX_ON_TEST" value="145"/>
<var name="ANA_I_TX_OEN_TEST" value="146"/>
<var name="ANA_I_RX_TEST1" value="147"/>
<var name="ANA_I_RX_TEST2" value="148"/>
<var name="ANA_I_RX_TEST3" value="149"/>
<var name="ANA_I_RX_TEST4" value="150"/>
<var name="ANA_I_RF_DEEP_PD" value="151"/>
<var name="ANA_I_RX_ON_TEST" value="152"/>
<var name="ANA_I_RX_CLK_FS" value="153"/>
<var name="ANA_I_RF_RESETN" value="154"/>
<var name="ANA_I_RX_REF_CAL" value="155"/>

<var name="ANA_I_RX_FILTER_BYPASS" value="158"/>
<var name="ANA_I_RX_BG_CTRL" value="159"/>

<var name="ANA_I_RX_BG_ENABLE" value="165"/>
<var name="ANA_I_RX_BG_STARTUP" value="166"/>
<var name="ANA_I_WAKEUP" value="167"/>
<var name="ANA_I_PLL_CLK_IN" value="168"/>
<var name="ANA_I_PLL_FIN" value="169"/>
<var name="ANA_I_PLL_PD_N" value="170"/>
<var name="ANA_I_PLL_CP_TUNE" value="171"/>




</module>
</archive>

<archive relative='memory_burst_adapter.xml' >

<module name="memory_burst_adapter" category="testbench">
    <reg16 name="Burst Config" protect="rw">
        <comment>This register is accessible only when CRE is set to 1.
            <br/>When read and write are not both in same mode, a cycle with CS high must be insterted between read and write access.
        </comment>
        <bits name="Read_Mode" pos="0" access="rw" rst="0">
            <options>
                <option name="Asynchronous" value="0"/>
                <option name="Synchronous" value="1"/>
            </options>
        </bits>
        <bits name="Write_Mode" pos="1" access="rw" rst="0">
            <comment>For write burst mode, WE must be asserted with CS in order to detect writes.
            </comment>
            <options>
                <option name="Asynchronous" value="0"/>
                <option name="Synchronous" value="1"/>
            </options>
        </bits>
        <bits name="Burst_Lat" pos="7:4" access="rw" rst="0">
            <comment>Initial burst latency
            </comment>
        </bits>
        <bits name="Page_Size" pos="10:8" access="rw" rst="0">
                <options>
                    <option name="4HW" value="0"><comment>4 half words </comment></option>
                    <option name="8HW" value="1"><comment>8 half words </comment></option>
                    <option name="16HW" value="2"><comment>16 half words </comment></option>
                    <option name="32HW" value="3"><comment>32 half words </comment></option>
                    <option name="64HW" value="4"><comment>64 half words </comment></option>
                    <option name="128HW" value="5"><comment>128 half words </comment></option>
                    <option name="256HW" value="6"><comment>256 half words </comment></option>
                    <option name="FULL" value="7"><comment>Full page (in burst mode, else reserved)</comment></option>
                    <default/>
                    <shift/>
                    <mask/>
                </options>
                <comment>Page size for bursts access.
                </comment>
        </bits>
    </reg16>
    <reg16 name="Scratch" protect="rw">
        <bits name="Scratch" pos="15:0" access="rw" rst="0">
        </bits>
    </reg16>

</module>
</archive>

<archive relative='greenstone.xml' >

    <include file="granite_ip.xml"/>

    <include file="regs.xml"/>
    <instance address="REG_SYS_APB_BASE + SYS_APB_STEP * SYS_ID_EXT_APB" type="regs" name="EXT_APB" />

    
    <include file="tester_chip.xml" />
    
    <include file="stereo_dac_test.xml" />
    <include file="test_uart.xml" />
    <include file="ana_test.xml" />

    
    <include file="memory_burst_adapter.xml" />

    

    <instance address="0x00900000" type="tester_chip" name="tester_chip" />
    <instance address="0x00900000 + 0x20000" type="test_uart" name="test_uart" />
    <instance address="0x00900000 + 0x20000 + 0x400" type="ana_test" name="ana_test" />
    <instance address="0x00900000 + 0x20000 + 0x600" type="stereo_dac_test" name="stereo_dac_test" />

    
    <instance address="0x01000000" type="memory_burst_adapter" name="CS0_conf" />
    <instance address="0x00000000" type="memory_burst_adapter" name="CS1_conf" />
    <instance address="0x00800000" type="memory_burst_adapter" name="CS2_conf" />
    <instance address="0x00900000" type="memory_burst_adapter" name="CS3_conf" />
    <instance address="0x00a00000" type="memory_burst_adapter" name="CS4_conf" />

</archive>


</bigarchive>
