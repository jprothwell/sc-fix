// Here is where all the model specific defines should be


#include "hal_i2c.h"
#include "camera_m.h"

typedef struct
{
    UINT32 Addr;            // Register Address
    UINT8 Data;             // Register Data
    UINT16 Wait;            // Time to wait after write
} CAM_REG_T;

typedef struct
{
    UINT16 Len;             // Size of array
    CAM_REG_T *RegVal;      // Array of registers
} CAM_REG_GROUP_T;

typedef enum
{
    CAM_MODE_IDLE,
    CAM_MODE_VIEWFINDER,
    CAM_MODE_PREP_IMG_CAPTURE,
    CAM_MODE_IMG_CAPTURE,
    CAM_MODE_PREP_VID_CAPTURE,
    CAM_MODE_VID_CAPTURE
} CAM_MODE_T;

// On FPGA platform, Pixel Clock must not be too fast or xfer screws up
#define CAM_CLK_CFG 0x81

const CAM_REG_T RG_InitPowerOnQvga[] =
{
    {0x0e,0x04,1},
    {0x0e,0x10,4},
    {0x5d,0x02,1},  // set to YUV mode, if set to RGB mode should set to 0x04
    {0xde,0x0,1},
    {0xdf,0x0,1},
    {0x0a,0x00,1},
    {0x0c,0x04,1},
    {0xe7,0x03,1},
    //{0xe8,0xae,1},
    //{0xe9,0xae,1},
    {0xe8,0xff,1},
    {0xe9,0xff,1},
    {0x9,0x17,1},
    {0xf,0x70,1},
    {0x13,0x90,1},
    {0x14,0x95,1},

    {0x17,0x32,1},

    {0x1f,0xF0,1},
    {0x20,0x00,1},
    {0x22,0x08,1},

    {0x23,0x87,1},
    {0x27,0x54,1},

    {0x28,0xa4,1},
    {0x29,0x65,1},
    {0x2a,0x9a,1},

    {0x41,0xdf,1},
    {0x43,0x43,1},
    {0x46,0x06,1},
    {0x73,0xa0,1},
    {0x5e,0x86,1},
    {0x5f,0x10,1},
    {0x65,0x30,1},

    {0x60,0xb0,1},

    {0x61,0x90,1},

    {0x62,0x50,1},

    {0x63,0x20,1},
    {0xea,0x78,1},
    {0xeb,0x58,1},
    {0xec,0x48,1},
    {0xed,0x20,1},

    {0x69,0x0a,1},
    //{0x69,0x0f,1},
    //{0x6a,0xe0,1},
    {0x6a,0xf0,1},

    {0x64,0x04,1},

    {0x66,0xB5,1},

    {0x67,0x41,1},	
    
    {0x77,0x10,1},
    {0x78,0xc5,1},

    {0x79,0xc5,1},

    {0x80,0xc3,1},
    {0xcd,0x00,1},
    {0x0d,0x19,1},

    {0x49,0x2b,1},
    {0x4a,0x0,1},
    {0x4b,0x30,1},
    {0x4c,0x0,1},
    {0x4d,0x29,1},
    {0x4e,0x0,1},
    {0x4f,0xf2,1},
    {0x50,0x3,1},
    {0x51,0x96,1},
    {0x52,0x3,1},
    {0x53,0x78,1},
    {0x54,0x0,1},
    {0x55,0x5a,1},
    {0x56,0x0,1},
    {0x57,0xb0,1},
    {0x58,0x3,1},
    {0x59,0xF5,1},
    {0x5a,0x3,1},


    {0x31,0x11,1}, 
    {0x32,0x19,1}, 
    {0x33,0x26,1}, 
    {0x34,0x2f,1}, 
    {0x35,0x37,1}, 
    {0x36,0x45,1}, 
    {0x37,0x51,1}, 
    {0x38,0x5c,1}, 
    {0x39,0x65,1}, 
    {0x3a,0x77,1}, 
    {0x3b,0x87,1}, 
    {0x3c,0x95,1}, 
    {0x3d,0xae,1}, 
    {0x3e,0xc5,1}, 
    {0x3f,0xda,1}, 
    {0x81,0x11,1}, 
    {0x82,0x19,1}, 
    {0x83,0x26,1}, 
    {0x84,0x2f,1}, 
    {0x85,0x37,1}, 
    {0x86,0x45,1}, 
    {0x87,0x51,1}, 
    {0x88,0x5c,1}, 
    {0x89,0x65,1}, 
    {0x8a,0x77,1}, 
    {0x8b,0x87,1}, 
    {0x8c,0x95,1}, 
    {0x8d,0xae,1}, 
    {0x8e,0xc5,1}, 
    {0x8f,0xda,1}, 
    {0x91,0x11,1}, 
    {0x92,0x19,1}, 
    {0x93,0x26,1}, 
    {0x94,0x2f,1}, 
    {0x95,0x37,1}, 
    {0x96,0x45,1}, 
    {0x97,0x51,1}, 
    {0x98,0x5c,1}, 
    {0x99,0x65,1}, 
    {0x9a,0x77,1}, 
    {0x9b,0x87,1}, 
    {0x9c,0x95,1}, 
    {0x9d,0xae,1}, 
    {0x9e,0xc5,1}, 
    {0x9f,0xda,1}, 
    {0xa0,0x00,1}, 
    {0xa1,0x04,1}, 
    {0xa2,0x16,1}, 
    {0xa3,0x32,1}, 
    {0xa4,0x5d,1}, 
    {0xa5,0x95,1}, 
    {0xa6,0xf5,1}, 
    {0xa7,0xf5,1}, 
    {0xa8,0xf5,1}, 
    {0xb1,0x00,1}, 
    {0xb2,0x04,1}, 
    {0xb3,0x15,1}, 
    {0xb4,0x31,1}, 
    {0xb5,0x5a,1}, 
    {0xb6,0x92,1}, 
    {0xb7,0xee,1}, 
    {0xb8,0xee,1}, 
    {0xb9,0xee,1}, 
    {0xc2,0x00,1}, 
    {0xc3,0x03,1}, 
    {0xc4,0x15,1}, 
    {0xc5,0x32,1}, 
    {0xc6,0x5c,1}, 
    {0xc7,0x94,1}, 
    {0xc8,0xea,1}, 
    {0xc9,0xea,1}, 
    {0xca,0xea,1}, 
    {0xd3,0xa0,1}, 
    {0xd4,0x78,1}, 
    {0x7c,0x05,1}, 
    {0x7d,0x25,1}, 
    {0x26,0xcc,1}, 
    {0xe0,0x81,1}, 
    {0x7a,0x87,1},
    {0x5b,0x01,1},
    {0x5c,0x42,1}
};


// use this for 640x480 (VGA) capture
const CAM_REG_T RG_InitPowerOnVga[] = 
{

    {0x0e,0x04,1},
    {0x0e,0x10,4},
    {0x5d,0x02,1},  // set to YUV mode, if set to RGB mode should set to 0x04
    {0xde,0x0,1},
    {0xdf,0x0,1},
    {0x0a,0x00,1},
    {0x0c,0x04,1},
    {0xe7,0x03,1},
    //{0xe8,0xae,1},
    //{0xe9,0xae,1},
    {0xe8,0xff,1},
    {0xe9,0xff,1},
    {0x9,0x17,1},
    {0xf,0x70,1},
    {0x13,0x90,1},
    {0x14,0x95,1},

    {0x17,0x32,1},

    {0x1f,0xF0,1},
    {0x20,0x00,1},
    {0x22,0x08,1},

    {0x23,0x87,1},
    {0x27,0x54,1},

    {0x28,0xa4,1},
    {0x29,0x65,1},
    {0x2a,0x9a,1},

    {0x41,0xdf,1},
    {0x43,0x43,1},
    {0x46,0x06,1},
    {0x73,0xa0,1},
    {0x5e,0x86,1},
    {0x5f,0x10,1},
    {0x65,0x30,1},

    {0x60,0xb0,1},

    {0x61,0x90,1},

    {0x62,0x50,1},

    {0x63,0x20,1},
    {0xea,0x78,1},
    {0xeb,0x58,1},
    {0xec,0x48,1},
    {0xed,0x20,1},

    {0x69,0x0a,1},
    //{0x69,0x0f,1},
    //{0x6a,0xe0,1},
    {0x6a,0xf0,1},

    {0x64,0x04,1},

    {0x66,0xB5,1},

    {0x67,0x41,1},	
    
    {0x77,0x10,1},
    {0x78,0xc5,1},

    {0x79,0xc5,1},

    {0x80,0xc3,1},
    {0xcd,0x00,1},
    {0x0d,0x19,1},

    {0x49,0x2b,1},
    {0x4a,0x0,1},
    {0x4b,0x30,1},
    {0x4c,0x0,1},
    {0x4d,0x29,1},
    {0x4e,0x0,1},
    {0x4f,0xf2,1},
    {0x50,0x3,1},
    {0x51,0x96,1},
    {0x52,0x3,1},
    {0x53,0x78,1},
    {0x54,0x0,1},
    {0x55,0x5a,1},
    {0x56,0x0,1},
    {0x57,0xb0,1},
    {0x58,0x3,1},
    {0x59,0xF5,1},
    {0x5a,0x3,1},


    {0x31,0x11,1}, 
    {0x32,0x19,1}, 
    {0x33,0x26,1}, 
    {0x34,0x2f,1}, 
    {0x35,0x37,1}, 
    {0x36,0x45,1}, 
    {0x37,0x51,1}, 
    {0x38,0x5c,1}, 
    {0x39,0x65,1}, 
    {0x3a,0x77,1}, 
    {0x3b,0x87,1}, 
    {0x3c,0x95,1}, 
    {0x3d,0xae,1}, 
    {0x3e,0xc5,1}, 
    {0x3f,0xda,1}, 
    {0x81,0x11,1}, 
    {0x82,0x19,1}, 
    {0x83,0x26,1}, 
    {0x84,0x2f,1}, 
    {0x85,0x37,1}, 
    {0x86,0x45,1}, 
    {0x87,0x51,1}, 
    {0x88,0x5c,1}, 
    {0x89,0x65,1}, 
    {0x8a,0x77,1}, 
    {0x8b,0x87,1}, 
    {0x8c,0x95,1}, 
    {0x8d,0xae,1}, 
    {0x8e,0xc5,1}, 
    {0x8f,0xda,1}, 
    {0x91,0x11,1}, 
    {0x92,0x19,1}, 
    {0x93,0x26,1}, 
    {0x94,0x2f,1}, 
    {0x95,0x37,1}, 
    {0x96,0x45,1}, 
    {0x97,0x51,1}, 
    {0x98,0x5c,1}, 
    {0x99,0x65,1}, 
    {0x9a,0x77,1}, 
    {0x9b,0x87,1}, 
    {0x9c,0x95,1}, 
    {0x9d,0xae,1}, 
    {0x9e,0xc5,1}, 
    {0x9f,0xda,1}, 
    {0xa0,0x00,1}, 
    {0xa1,0x04,1}, 
    {0xa2,0x16,1}, 
    {0xa3,0x32,1}, 
    {0xa4,0x5d,1}, 
    {0xa5,0x95,1}, 
    {0xa6,0xf5,1}, 
    {0xa7,0xf5,1}, 
    {0xa8,0xf5,1}, 
    {0xb1,0x00,1}, 
    {0xb2,0x04,1}, 
    {0xb3,0x15,1}, 
    {0xb4,0x31,1}, 
    {0xb5,0x5a,1}, 
    {0xb6,0x92,1}, 
    {0xb7,0xee,1}, 
    {0xb8,0xee,1}, 
    {0xb9,0xee,1}, 
    {0xc2,0x00,1}, 
    {0xc3,0x03,1}, 
    {0xc4,0x15,1}, 
    {0xc5,0x32,1}, 
    {0xc6,0x5c,1}, 
    {0xc7,0x94,1}, 
    {0xc8,0xea,1}, 
    {0xc9,0xea,1}, 
    {0xca,0xea,1}, 
    {0xd3,0xa0,1}, 
    {0xd4,0x78,1}, 
    {0x7c,0x05,1}, 
    {0x7d,0x25,1}, 
    {0x26,0xcc,1}, 
    {0xe0,0x81,1}, 
    {0x7a,0x87,1},
    {0x5b,0x01,1},
    {0x5c,0x42,1}
};



// use this for 160x120 (QQVGA) capture
const CAM_REG_T RG_InitPowerOnQqvga[] = 
{
    {0x0e,0x04,1},
    {0x0e,0x10,4},
    {0x5d,0x02,1},  // set to YUV mode, if set to RGB mode should set to 0x04
    {0xde,0x0,1},
    {0xdf,0x0,1},
    {0x0a,0x00,1},
    {0x0c,0x04,1},
    {0xe7,0x03,1},
    //{0xe8,0xae,1},
    //{0xe9,0xae,1},
    {0xe8,0xff,1},
    {0xe9,0xff,1},
    {0x9,0x17,1},
    {0xf,0x70,1},
    {0x13,0x90,1},
    {0x14,0x95,1},

    {0x17,0x32,1},

    {0x1f,0xF0,1},
    {0x20,0x00,1},
    {0x22,0x08,1},

    {0x23,0x87,1},
    {0x27,0x54,1},

    {0x28,0xa4,1},
    {0x29,0x65,1},
    {0x2a,0x9a,1},
    
		{0x2b,0x40,1},
		{0x2c,0xb8,1},
		{0x2d,0x57,1},
		{0x2e,0xa9,1},
		
    {0x41,0xdf,1},
    {0x43,0x43,1},
    {0x46,0x06,1},
    {0x73,0xa0,1},
    {0x5e,0x86,1},
    {0x5f,0x10,1},
    {0x65,0x30,1},

    {0x60,0xb0,1},

    {0x61,0x90,1},

    {0x62,0x50,1},

    {0x63,0x20,1},
    {0xea,0x78,1},
    {0xeb,0x58,1},
    {0xec,0x48,1},
    {0xed,0x20,1},

    {0x69,0x0a,1},
    //{0x69,0x0f,1},
    //{0x6a,0xe0,1},
    {0x6a,0xf0,1},

    {0x64,0x04,1},

    {0x66,0xB5,1},

    {0x67,0x41,1},	
    
    {0x77,0x10,1},
    {0x78,0xc5,1},

    {0x79,0xc5,1},

    {0x80,0xc3,1},
    {0xcd,0x00,1},
    {0x0d,0x19,1},

    {0x49,0x2b,1},
    {0x4a,0x0,1},
    {0x4b,0x30,1},
    {0x4c,0x0,1},
    {0x4d,0x29,1},
    {0x4e,0x0,1},
    {0x4f,0xf2,1},
    {0x50,0x3,1},
    {0x51,0x96,1},
    {0x52,0x3,1},
    {0x53,0x78,1},
    {0x54,0x0,1},
    {0x55,0x5a,1},
    {0x56,0x0,1},
    {0x57,0xb0,1},
    {0x58,0x3,1},
    {0x59,0xF5,1},
    {0x5a,0x3,1},


    {0x31,0x11,1}, 
    {0x32,0x19,1}, 
    {0x33,0x26,1}, 
    {0x34,0x2f,1}, 
    {0x35,0x37,1}, 
    {0x36,0x45,1}, 
    {0x37,0x51,1}, 
    {0x38,0x5c,1}, 
    {0x39,0x65,1}, 
    {0x3a,0x77,1}, 
    {0x3b,0x87,1}, 
    {0x3c,0x95,1}, 
    {0x3d,0xae,1}, 
    {0x3e,0xc5,1}, 
    {0x3f,0xda,1}, 
    {0x81,0x11,1}, 
    {0x82,0x19,1}, 
    {0x83,0x26,1}, 
    {0x84,0x2f,1}, 
    {0x85,0x37,1}, 
    {0x86,0x45,1}, 
    {0x87,0x51,1}, 
    {0x88,0x5c,1}, 
    {0x89,0x65,1}, 
    {0x8a,0x77,1}, 
    {0x8b,0x87,1}, 
    {0x8c,0x95,1}, 
    {0x8d,0xae,1}, 
    {0x8e,0xc5,1}, 
    {0x8f,0xda,1}, 
    {0x91,0x11,1}, 
    {0x92,0x19,1}, 
    {0x93,0x26,1}, 
    {0x94,0x2f,1}, 
    {0x95,0x37,1}, 
    {0x96,0x45,1}, 
    {0x97,0x51,1}, 
    {0x98,0x5c,1}, 
    {0x99,0x65,1}, 
    {0x9a,0x77,1}, 
    {0x9b,0x87,1}, 
    {0x9c,0x95,1}, 
    {0x9d,0xae,1}, 
    {0x9e,0xc5,1}, 
    {0x9f,0xda,1}, 
    {0xa0,0x00,1}, 
    {0xa1,0x04,1}, 
    {0xa2,0x16,1}, 
    {0xa3,0x32,1}, 
    {0xa4,0x5d,1}, 
    {0xa5,0x95,1}, 
    {0xa6,0xf5,1}, 
    {0xa7,0xf5,1}, 
    {0xa8,0xf5,1}, 
    {0xb1,0x00,1}, 
    {0xb2,0x04,1}, 
    {0xb3,0x15,1}, 
    {0xb4,0x31,1}, 
    {0xb5,0x5a,1}, 
    {0xb6,0x92,1}, 
    {0xb7,0xee,1}, 
    {0xb8,0xee,1}, 
    {0xb9,0xee,1}, 
    {0xc2,0x00,1}, 
    {0xc3,0x03,1}, 
    {0xc4,0x15,1}, 
    {0xc5,0x32,1}, 
    {0xc6,0x5c,1}, 
    {0xc7,0x94,1}, 
    {0xc8,0xea,1}, 
    {0xc9,0xea,1}, 
    {0xca,0xea,1}, 
    {0xd3,0xa0,1}, 
    {0xd4,0x78,1}, 
    {0x7c,0x05,1}, 
    {0x7d,0x25,1}, 
    {0x26,0xcc,1}, 
    {0xe0,0x81,1}, 
    {0x7a,0x87,1},
    {0x5b,0x01,1},
    {0x5c,0x42,1}
};

const CAM_REG_T RG_VidFormatVga[] = 
{
    {0x04, 0x04,3}, // setup clock divider and HV-mirror ;Mclk /4
    {0x05, 0x07,3}
};

const CAM_REG_T RG_VidFormatQvga[] = 
{
    {0x04,0x04,3},   // setup clock divider and HV-mirror ;Mclk /4
    {0x05,0x05,3}    // setup  output mode 240*320
};

const CAM_REG_T RG_VidFormatQqvga[] = 
{
    {0x04, 0x04,3}, // setup clock divider and HV-mirror ;Mclk /4
    {0x05, 0x04,3}
};

typedef struct
{
    // Camera information structure
    char                desc[40];	

    UINT8               snrtype;            //sensor type(RGB or YUV)
    UINT8               pclk;               //use PCLK of sensor
    UINT8               clkcfg;             //[0]: VSync delay enable; [1]: Fifo VSync delay enable; [2]: Use PCLK Negtive Edge.
    HAL_I2C_BPS_T       i2crate;            //I2C rate : KHz				
    UINT8               i2caddress;         //I2C address
    UINT8               i2cispaddress;      //ISP I2C address
    UINT8               pwrcfg;             //sensor power initial configure(SIF REG801 BIT[0]~BIT[2])
    BOOL                rstactiveh;         //sensor reset active hi/low polarity (TRUE = active hi)
    BOOL                snrrst;             //Reset sensor enable

    CAM_MODE_T          cammode;


    BOOL                capturevideo;
    BOOL                captureframe;
    UINT8               numactivebuffers;
    UINT8               currentbuf;

    UINT8               brightness;         //brightness
    UINT8               contrast;           //contrast

    CAM_FORMAT_T        format;
    CAM_SIZE_T          npixels;
    CAM_IMAGE_T         vidbuffer;

    CAM_REG_GROUP_T     standby;            //sensor standby register
    CAM_REG_GROUP_T     Initpoweron;        //SENSOR ISP initial configure

    CAM_REG_GROUP_T     sifpwronseq;        //Sif config sequence(Reg.800 bit0~2) when sensor power on
    CAM_REG_GROUP_T     sifstdbyseq;        //Sif config sequence(Reg.800 bit0~2) when sensor standby
    CAM_REG_GROUP_T     dsif;               //SIF initial configure
    //    TSnrSizeCfgGroup    snrSizeCfg;         //sensor size configure information

    // This 'callback' mechanism is not necessary because the encapsulation is taken
    // care of by the environment
    //    PSensorSetReg       snrSetRegCall;      //set reg callback
    //    PSensorGetReg       snrGetRegCall;
    //    PSnrIdChk           snrIdChkCall;
    //    PSnrMirrorFlip      snrMirrorFlipCall;
    //    PSnrContrast        snrContrastCall;
    //    PSnrBrightness      snrBrightnessCall;
    //    PSnrMode            snrModeCall;
    //    PSnrGetEt           snrGetEt;
    //    PSnrSetEt           snrSetEt;
    //    TFlashParm          flashparm;
    CAM_IRQ_HANDLER_T   camirqhandler;
} CAM_INFO_T;

volatile CAM_INFO_T gSensorInfo =
{
    "Sp80818 RGB Mode",      // char desc[40];	

    0,                      // UINT8 snrtype; (rgb)
    1,                      // UINT8 pclk; use or don't use PCLK of sensor???
    0,                      // UINT8 clkcfg; ???
    HAL_I2C_BPS_100K,       // UINT16 i2crate;
    0x18,                   // UINT8 i2caddress; this is the _REAL_ slave address.  
    //  The value written in phase 1 of a write cycle will be 0x42
    //  while the value just before the read will be 0x43
    0x18,                   // UINT8 i2cispaddress;
    0x02,                   // UINT8 pwrcfg;???
    TRUE,                   // BOOL rstactiveh;  // active high
    FALSE,                  // BOOL snrrst;

    CAM_MODE_IDLE,          // cammode

    FALSE,                  // Capture video mode
    FALSE,                  // Capturing single frame
    0,                      // Number of active buffers reserved by the upper layer
    0,                      // current frame buffer

    3,                      // UINT8 brightness;
    4,                      // UINT8 contrast;
    CAM_FORMAT_RGB565,      // Format
    CAM_NPIX_QVGA,           // npixels(VGA, QVGA, QQVGA...)
    NULL,                   // Video Buffer.  First frame buffer for video or image buffer

    {0, NULL},              // CAM_REG_GROUP_T standby;
    // Should start with QQVGA, but for testing, start with VGA
    //    {sizeof(RG_InitPowerOnQqvga) / sizeof(CAM_REG_T), (CAM_REG_T*)&RG_InitPowerOnQqvga}, // CAM_REG_GROUP_T Initpoweron;
    {sizeof(RG_InitPowerOnVga) / sizeof(CAM_REG_T), (CAM_REG_T*)&RG_InitPowerOnVga}, // CAM_REG_GROUP_T Initpoweron;

    {0, NULL},              // CAM_REG_GROUP_T sifpwronseq;
    {0, NULL},              // CAM_REG_GROUP_T sifstdbyseq;
    {0, NULL},              // CAM_REG_GROUP_T dsif; initial value
    NULL                    // IRQ Callback
};

// ############
// Private
// ############

// These are the commands specific to the SCCB
#define PHASE3_WR_PH1   0x11000     // Start & Write    Slave ID
#define PHASE3_WR_PH2   0x1000      // Write            Slave Register Address
#define PHASE3_WR_PH3   0x1100      // Stop & Write     Slave Register Data

#define PHASE2_WR_PH1   0x11000     // Start & Write    Slave ID
#define PHASE2_WR_PH2   0x1100      // Stop & Write     Slave Register Address (to read)

#define PHASE2_RD_PH1   0x11000     // Start & Write    Slave ID
#define PHASE2_RD_PH2   0x111       // Stop & Read & NACK   Slave Register Read Data

VOID camera_Delay(UINT16 Wait_mS);
VOID camera_WriteReg(CAM_REG_T RegWrite);
UINT8 camera_ReadReg(UINT8 Addr);
VOID camera_SendRgSeq(const CAM_REG_T *RegList, UINT16 Len);
VOID camera_InteruptHandler();
